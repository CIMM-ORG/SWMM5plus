var tipuesearch = {"pages":[{"text":"SWMMengine SWMMengine, pure Fortran engine for the U.S. EPA Stormwater Management Model This project is building a new parallel time-marching solver for unsteady flow solutions in the U.S. EPA Stormwater Management Model (SWMM). The prior link-node hydraulic solver has been demonstrated to have problems in maintaining mass conservation and parallelization typically is saturated with 10 or 15 processors. The new computational engine is being designed to work with the existing user interface and input files of SWMM (version 5.1). Key advances in the new engine are: Finite-volume sub-discretization of links; Representation of nodes (junctions) as physical elements with multiple faces and different possible heads on each face; Use of artificial compressibility for surcharged pipe flow; Explicit time-marching of Saint-Venant equation for simplified parallel solution, Parallelization through coarray Fortran (i.e., Fortran 2008 or later) that provides run-time parallelization on any number of processors; SWMMengine is Fortran 2008+ standard compliant; SWMMengine supports ascii , binary (Base64 encoding) and raw file formats; SWMMengine is a Free , Open Source Project under Public Domain license. Compiler Support Main features | Copyrights | Documentation | Acknowledment | Main features Parallel Support SWMMengine can be safely used in parallel environments , handling multiple procesors. We are currently working on making it parallel using the Fortran Coarrays and make it available as a next version to the community. Copyrights SWMMengine is an open source project, it is distributed under a public domain: Public Domain . Anyone is interest to use, to develop or to contribute to SWMMengine is welcome, feel free to select the license that best matches your soul! Go to Top Documentation Detailed documentation of SWMMengine is contained into this README file. Detailed documentation of SWMM can be found at U.S. EPA website. Acknowledment This project is being  developed by the National Center for Infrastructure Modeling and Management (NCIMM), under funding from the U.S. Environmental Protection Agency with Cooperative Agreement No. 83595001 awarded  to the University of Texas at Austin. Go to Top Developer Info Ben R. Hodges and Ehsan Madadi-Kandjani","title":" SWMMengine ","tags":"home","loc":"index.html"},{"text":"This file depends on sourcefile~~checking.f08~~EfferentGraph sourcefile~checking.f08 checking.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~checking.f08->sourcefile~data_keys.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~checking.f08->sourcefile~array_index.f08 sourcefile~globals.f08 globals.f08 sourcefile~checking.f08->sourcefile~globals.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~checking.f08~~AfferentGraph sourcefile~checking.f08 checking.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~checking.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules checking Source Code checking.f08 Source Code ! module checking ! ! Perform various checks of the simulation setup ! In general, these are procedures that should only be called once. ! !========================================================================== ! module checking ! ! contains generalized checking algorithms ! use array_index use data_keys use globals implicit none private public :: checking_consistency public :: checking_smallvolume_consistency integer , private :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine checking_consistency ! ! Checks consistency of parameter dimensions !   The number of upstream and downstream faces per element in an elemM !   array must be consistent with the total faces per element. !   These are parameter dimensions that are separately set (rather than !   variables) to prevent accidental change during the run, which could !   be a catastrophic bug. ! ! TODO: consider adding checking for other parameters ! character ( 64 ) :: subroutine_name = 'checking_consistency' integer :: aa !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name aa = upstream_face_per_elemM + dnstream_face_per_elemM if ( aa /= face_per_elemM ) then print * , 'upstream_face_per_elemM = ' , upstream_face_per_elemM print * , 'dnstream_face_per_elemM = ' , dnstream_face_per_elemM print * , 'face_per_elemM          = ' , face_per_elemM print * , 'error: inconsistent parameters for faces per element in ' , subroutine_name stop endif if ( nullvalueI > 0 ) then print * , 'error: nullvalueI <=0 is required in ' , subroutine_name STOP endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine checking_consistency ! !========================================================================== !========================================================================== ! subroutine checking_smallvolume_consistency & ( elem2R , elemMR ) ! ! checks the consistency of the smallvolume settings (if used) and the ! zero value settings ! character ( 64 ) :: subroutine_name = 'checking_smallvolume_consistency' real , intent ( in ) :: elem2R (:,:), elemMR (:,:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if (. not . setting % SmallVolume % UseSmallVolumes ) return if ( any ( elem2R (:, e2r_SmallVolume ) <= setting % ZeroValue % Volume ) . or . & any ( elemMR (:, eMr_SmallVolume ) <= setting % ZeroValue % Volume ) ) then print * , 'setting%ZeroValue%Volume        = ' , setting % ZeroValue % Volume print * , 'setting%SmallVolume%DepthCutoff = ' , setting % SmallVolume % DepthCutoff print * , 'user error: the setting%ZeroValue%Volume is too large.' print * , 'It must be smaller than the smallest elemR(:,SmallVolume)' print * , 'which is computed using setting%SmallVolume%DepthCutoff.' print * , 'Recommend increasing SmallVolume%DepthCutoff or reducing the ' print * , 'ZeroValue%Volume' stop endif if ( setting % SmallVolume % DepthCutoff <= setting % ZeroValue % Depth ) then print * , 'setting%SmallVolume%DepthCutoff = ' , setting % SmallVolume % DepthCutoff print * , 'setting%ZeroValue%Depth         = ' , setting % ZeroValue % Depth print * , 'user error: setting%SmallVolume%DepthCutoff <= setting%ZeroValue%Depth' print * , 'This is inconsistent. Increase the former or decrease the latter.' stop endif if ( setting % SmallVolume % MinimumTopwidth < setting % ZeroValue % Topwidth ) then print * , 'setting%SmallVolume%MinimumTopwidth = ' , setting % SmallVolume % MinimumTopwidth print * , 'setting%ZeroValue%Topwidth          = ' , setting % ZeroValue % Topwidth print * , 'user error: setting%SmallVolume%MinimumTopwidth <= setting%ZeroValue%Topwidth' print * , 'This is inconsistent. Increase the former or decrease the latter.' stop endif if ( setting % SmallVolume % MinimumArea < setting % ZeroValue % Area ) then print * , 'setting%SmallVolume%MinimumArea = ' , setting % SmallVolume % MinimumArea print * , 'setting%ZeroValue%Area          = ' , setting % ZeroValue % Area print * , 'user error: setting%SmallVolume%MinimumArea <= setting%ZeroValue%Area' print * , 'This is inconsistent. Increase the former or decrease the latter.' stop endif if ( setting % SmallVolume % MinimumPerimeter < setting % ZeroValue % Topwidth ) then print * , 'setting%SmallVolume%MinimumPerimeter = ' , setting % SmallVolume % MinimumPerimeter print * , 'setting%ZeroValue%Topwidth          = ' , setting % ZeroValue % Topwidth print * , 'user error: setting%SmallVolume%MinimumPerimeter <= setting%ZeroValue%Topwidth' print * , 'This is inconsistent. Increase the former or decrease the latter.' stop endif if ( setting % SmallVolume % MinimumHydRadius < setting % ZeroValue % Depth ) then print * , 'setting%SmallVolume%MinimumHydRadius = ' , setting % SmallVolume % MinimumHydRadius print * , 'setting%ZeroValue%Depth              = ' , setting % ZeroValue % Depth print * , 'user error: setting%SmallVolume%MinimumHydRadius <= setting%ZeroValue%Depth' print * , 'This is inconsistent. Increase the former or decrease the latter.' stop endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine checking_smallvolume_consistency ! !========================================================================== ! END OF MODULE checking !========================================================================== end module checking","title":"checking.f08 – SWMMengine","tags":"","loc":"sourcefile/checking.f08.html"},{"text":"This file depends on sourcefile~~bc.f08~~EfferentGraph sourcefile~bc.f08 bc.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~globals.f08 globals.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~utility.f08 utility.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 var pansourcefilebcf08EfferentGraph = svgPanZoom('#sourcefilebcf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~bc.f08~~AfferentGraph sourcefile~bc.f08 bc.f08 sourcefile~debug.f08 debug.f08 sourcefile~debug.f08->sourcefile~bc.f08 sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~runge_kutta.f08->sourcefile~bc.f08 sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~runge_kutta.f08->sourcefile~element_geometry.f08 sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~runge_kutta.f08->sourcefile~element_dynamics.f08 sourcefile~face_values.f08 face_values.f08 sourcefile~runge_kutta.f08->sourcefile~face_values.f08 sourcefile~diagnostic.f08 diagnostic.f08 sourcefile~runge_kutta.f08->sourcefile~diagnostic.f08 sourcefile~initial_condition.f08 initial_condition.f08 sourcefile~initial_condition.f08->sourcefile~bc.f08 sourcefile~initial_condition.f08->sourcefile~element_geometry.f08 sourcefile~initial_condition.f08->sourcefile~element_dynamics.f08 sourcefile~initial_condition.f08->sourcefile~face_values.f08 sourcefile~element_geometry.f08->sourcefile~bc.f08 sourcefile~case_y_channel.f08 case_y_channel.f08 sourcefile~case_y_channel.f08->sourcefile~bc.f08 sourcefile~element_dynamics.f08->sourcefile~bc.f08 sourcefile~face_values.f08->sourcefile~bc.f08 sourcefile~diagnostic.f08->sourcefile~bc.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~time_loop.f08->sourcefile~bc.f08 sourcefile~time_loop.f08->sourcefile~debug.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~time_loop.f08->sourcefile~face_values.f08 sourcefile~time_loop.f08->sourcefile~diagnostic.f08 sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~time_loop.f08->sourcefile~explicit_euler.f08 sourcefile~output.f08 output.f08 sourcefile~time_loop.f08->sourcefile~output.f08 sourcefile~case_simple_channel.f08 case_simple_channel.f08 sourcefile~case_simple_channel.f08->sourcefile~bc.f08 sourcefile~test_cases.f08 test_cases.f08 sourcefile~test_cases.f08->sourcefile~bc.f08 sourcefile~test_cases.f08->sourcefile~case_y_channel.f08 sourcefile~test_cases.f08->sourcefile~case_simple_channel.f08 sourcefile~explicit_euler.f08->sourcefile~bc.f08 sourcefile~explicit_euler.f08->sourcefile~element_geometry.f08 sourcefile~explicit_euler.f08->sourcefile~element_dynamics.f08 sourcefile~explicit_euler.f08->sourcefile~face_values.f08 sourcefile~output.f08->sourcefile~bc.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~bc.f08 sourcefile~main.f08->sourcefile~debug.f08 sourcefile~main.f08->sourcefile~initial_condition.f08 sourcefile~main.f08->sourcefile~diagnostic.f08 sourcefile~main.f08->sourcefile~time_loop.f08 sourcefile~main.f08->sourcefile~test_cases.f08 sourcefile~main.f08->sourcefile~output.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules bc Source Code bc.f08 Source Code ! module bc ! ! Setup and apply boundary conditions. All the BC functions and subroutines ! should be located in this module. ! ! Note that BC should only be applied on faces connected to an elem2 element. ! That is, a BC cannot be associated with a junction branch. ! !========================================================================== ! module bc ! ! boundary condition definitions and enforcement ! use array_index use data_keys use globals use setting_definition use type_definitions use utility implicit none private public :: bc_allocate public :: bc_checks public :: bc_applied_onface public :: bc_applied_onelement public :: bc_timescale_value public :: bc_nullify_ghost_elem integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine bc_allocate & ( bcdataDn , bcdataUp , ndnstreamBC , nupstreamBC , ntimepoint ) ! ! allocate storage for boundary conditions. ! HACK - possibly move this to allocation_storage module ! character ( 64 ) :: subroutine_name = 'bc_allocate' type ( bcType ), dimension (:), allocatable , intent ( out ) :: bcdataDn , bcdataUp integer , intent ( in ) :: ndnstreamBC , nupstreamBC , ntimepoint integer :: ii integer :: allocation_status character ( len = 99 ) :: emsg !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !% the Upstream and Downstream bc structure allocate ( bcdataUp ( nupstreamBC ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) allocate ( bcdataDn ( ndnstreamBC ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) !% the downstream arrays - HACK default downstream is elevation do ii = 1 , ndnstreamBC bcdataDn ( ii )% idx = ii bcdataDn ( ii )% Updn = bc_updn_downstream bcdataDn ( ii )% Category = bc_category_elevation allocate ( bcdataDn ( ii )% TimeArray ( ntimepoint ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) allocate ( bcdataDn ( ii )% ValueArray ( ntimepoint ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) bcdataDn ( ii )% NodeID = nullvalueI bcdataDn ( ii )% FaceID = nullvalueI bcdataDn ( ii )% ElemGhostID = nullvalueI bcdataDn ( ii )% ElemInsideID = nullvalueI bcdataDn ( ii )% ThisValue = nullvalueR bcdataDn ( ii )% ThisTime = nullvalueR bcdataDn ( ii )% ThisFlowrate = nullvalueR bcdataDn ( ii )% TimeArray = nullvalueR bcdataDn ( ii )% ValueArray = nullvalueR end do !% the upstream arrays = HACK default upstream is flowrate do ii = 1 , nupstreamBC bcdataUp ( ii )% idx = ii bcdataUp ( ii )% Updn = bc_updn_upstream bcdataUp ( ii )% category = bc_category_inflowrate allocate ( bcdataUp ( ii )% TimeArray ( ntimepoint ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) allocate ( bcdataUp ( ii )% ValueArray ( ntimepoint ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) bcdataUp ( ii )% NodeID = nullvalueI bcdataUp ( ii )% FaceID = nullvalueI bcdataUp ( ii )% ElemGhostID = nullvalueI bcdataUp ( ii )% ElemInsideID = nullvalueI bcdataUp ( ii )% ThisValue = nullvalueR bcdataUp ( ii )% ThisTime = nullvalueR bcdataUp ( ii )% ThisFlowrate = nullvalueR bcdataUp ( ii )% TimeArray = nullvalueR bcdataUp ( ii )% ValueArray = nullvalueR end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine bc_allocate ! !========================================================================== !========================================================================== ! subroutine bc_applied_onface & ( faceR , faceI , elem2R , elem2I , bcdataDn , bcdataUp , e2r_Velocity_new , thisTime ) ! ! Apply boundary conditions to face arrays. ! ! This requires the elem2R data because an elevation BC is enforced on the ! ghost element so the face enforcement is an interpolation across the ! boundary. ! character ( 64 ) :: subroutine_name = 'bc_applied_onface' real , intent ( in out ) :: faceR (:,:) real , intent ( in out ) :: elem2R (:,:) integer , intent ( in out ) :: faceI (:,:) integer , intent ( in ) :: elem2I (:,:) type ( bcType ), intent ( in out ) :: bcdataDn (:), bcdataUp (:) integer , intent ( in ) :: e2r_Velocity_new real , intent ( in ) :: thisTime !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name call bc_onface ( faceR , faceI , elem2R , bcdataDn , thisTime ) call bc_onface ( faceR , faceI , elem2R , bcdataUp , thisTime ) call bc_face_othervalues ( faceR , faceI , elem2R , bcdataDn ) call bc_face_othervalues ( faceR , faceI , elem2R , bcdataUp ) call bc_ghost_othervalues & ( elem2R , elem2I , faceR , faceI , bcdataUp , e2i_Mface_u , e2r_Velocity_new , & fr_Area_d , fr_Velocity_d , fr_HydDepth_d , fr_Eta_d ) call bc_ghost_othervalues & ( elem2R , elem2I , faceR , faceI , bcdataDn , e2i_Mface_d , e2r_Velocity_new , & fr_Area_u , fr_Velocity_u , fr_HydDepth_u , fr_Eta_u ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine bc_applied_onface ! !========================================================================== !========================================================================== ! subroutine bc_applied_onelement & ( elem2R , bcdataDn , bcdataUp , thisTime , thiscategory , e2r_VelocityColumn ) ! ! Apply boundary condition on elements (not faces) for bc:Category = \"thiscategory\" ! ! The e2r_VelocityColumn is only used when thiscategory = bc_category_inflowrate ! in which case it may be either the e2r_Velocity or the e2r_Velocity_new column. ! character ( 64 ) :: subroutine_name = 'bc_applied_onelement' real , intent ( in out ) :: elem2R (:,:) type ( bcType ), intent ( in out ) :: bcdataDn (:), bcdataUp (:) real , intent ( in ) :: thisTime integer , intent ( in ) :: thiscategory integer , intent ( in ) :: e2r_VelocityColumn !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name call bc_onelement ( elem2R , bcdataDn , thisTime , thiscategory , e2r_VelocityColumn ) call bc_onelement ( elem2R , bcdataUp , thisTime , thiscategory , e2r_VelocityColumn ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine bc_applied_onelement ! !========================================================================== !========================================================================== ! subroutine bc_checks & ( bcdataUp , bcdataDn , elem2I , faceI , nodeI ) ! ! checking of BC setup ! character ( 64 ) :: subroutine_name = 'bc_checks' integer , intent ( in ) :: elem2I (:,:), faceI (:,:) integer , target , intent ( in ) :: nodeI (:,:) type ( bcType ), intent ( in out ) :: bcdataUp (:), bcdataDn (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !% error checking for assignment of BC nodes to faces call bc_node_assignment_error_check ( nodeI , faceI , nBCdn ) call bc_node_assignment_error_check ( nodeI , faceI , nBCup ) !% Assign bc face ID that corresponds to nodes call bc_assign_faceID ( bcdataDn , faceI ) call bc_assign_faceID ( bcdataUp , faceI ) !% assign initial values call bc_updatevalue ( bcdataDn , setting % Time % StartTime ) call bc_updatevalue ( bcdataUp , setting % Time % StartTime ) !% check to see that the estimated simulation time is within available BC data call bc_adequate_coverage ( bcdataUp , bcdataDn ) ! if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine bc_checks ! !========================================================================== !========================================================================== ! subroutine bc_timescale_value & ( elem2R , bcdata ) ! ! set timescales on ghost elements outside boundary to max value ! character ( 64 ) :: subroutine_name = 'bc_timescale_value' real , intent ( in out ) :: elem2R (:,:) type ( bcType ), target , intent ( in ) :: bcdata (:) integer :: ii integer , pointer :: eID !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do ii = 1 , size ( bcdata ) eID => bcdata ( ii )% ElemGhostID elem2R ( eID , e2r_Timescale_u ) = setting % Limiter % Timescale % Maximum elem2R ( eID , e2r_Timescale_d ) = setting % Limiter % Timescale % Maximum end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine bc_timescale_value ! !========================================================================== !========================================================================== ! subroutine bc_nullify_ghost_elem & ( elem2R , bcdata ) ! ! This sets all the ghost elements outside of boundary faces to nullvalues ! In general this should not be needed but is useful in debugging ! character ( 64 ) :: subroutine_name = 'bc_nullify_ghost_elem' real , intent ( in out ) :: elem2R (:,:) type ( bcType ), target , intent ( in ) :: bcdata (:) integer , pointer :: eID integer :: ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do ii = 1 , size ( bcdata ) eID => bcdata ( ii )% ElemGhostID elem2R ( eID ,:) = nullvalueR end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine bc_nullify_ghost_elem ! !========================================================================== ! PRIVATE BELOW HERE !========================================================================== ! subroutine bc_adequate_coverage & ( bcdataUp , bcdataDn ) ! !check to see if the BC cover the entire simulation period ! character ( 64 ) :: subroutine_name = 'bc_adequate_coverage' type ( bcType ), intent ( in ) :: bcdataUp (:), bcdataDn (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name call bc_adequate_coverage_onedir ( bcdataUp , nBCup ) call bc_adequate_coverage_onedir ( bcdataDn , nBCdn ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine bc_adequate_coverage ! !========================================================================== !========================================================================== ! subroutine bc_onface & ( faceR , faceI , elem2R , bcdata , thisTime ) ! ! Apply boundary conditions on one face (not element) ! character ( 64 ) :: subroutine_name = 'bc_onface' real , intent ( in out ) :: faceR (:,:) real , intent ( in ) :: elem2R (:,:) integer , intent ( in out ) :: faceI (:,:) type ( bcType ), target , intent ( in out ) :: bcdata (:) real , intent ( in ) :: thisTime real , pointer :: thisval integer , pointer :: thisloc , thiscat , thisghost , thisinside integer :: ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name call bc_updatevalue ( bcdata , thisTime ) do ii = 1 , size ( bcdata ) thisloc => bcdata ( ii )% faceID thisghost => bcdata ( ii )% ElemGhostID thisinside => bcdata ( ii )% ElemInsideID thiscat => bcdata ( ii )% category thisval => bcdata ( ii )% thisValue faceI ( thisloc , fi_BC_ID ) = bcdata ( ii )% Idx if ( thiscat == bc_category_elevation ) then !%  linear interpolation using ghost and interior cells faceR ( thisloc , fr_Eta_u ) = onehalfR * ( elem2R ( thisghost , e2r_Eta ) + elem2R ( thisinside , e2r_Eta )) faceR ( thisloc , fr_Eta_d ) = faceR ( thisloc , fr_Eta_u ) elseif ( thiscat == bc_category_inflowrate ) then !%  direct enforcement of flowrate faceR ( thisloc , fr_Flowrate ) = thisval else print * , 'error: unexpected value for bcdata%category of ' , thiscat , ' in ' , subroutine_name stop endif end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine bc_onface ! !========================================================================== !========================================================================== ! subroutine bc_face_othervalues & ( faceR , faceI , elem2R , bcdata ) ! ! enforces the non-bc values on a bc face, e.g. flowrate on a face that ! has an elevation bc ! character ( 64 ) :: subroutine_name = 'bc_face_othervalues' real , target , intent ( in out ) :: faceR (:,:) real , target , intent ( in ) :: elem2R (:,:) integer , target , intent ( in ) :: faceI (:,:) type ( bcType ), target , intent ( in ) :: bcdata (:) !integer,               intent(in)  :: fi_Melem_inside real :: thisFroudeNumber , thisDepth , sideslope real , pointer :: froudeMax , Qrate , Depth , Top , Dinc , Area integer , dimension ( 3 ) :: e2rset , frset integer , pointer :: fID , eID integer :: ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name e2rset = ( / e2r_Topwidth , e2r_Area , e2r_HydDepth / ) frset = ( / fr_Topwidth , fr_Area_d , fr_HydDepth_d / ) !%  Extrapolation from the inside to the face at the boundary !%  then overwrite with the actual bc do ii = 1 , size ( bcdata ) fID => bcdata ( ii )% FaceID eID => bcdata ( ii )% ElemInsideID froudeMax => setting % Limiter % BC % FroudeInflowMaximum !%  simple extrapolation of geometry from inside element !% for area and topwidth faceR ( fID , frset ) = elem2R ( eID , e2rset ) faceR ( fID , fr_Area_u ) = faceR ( fID , fr_Area_d ) faceR ( fID , fr_HydDepth_u ) = faceR ( fID , fr_HydDepth_d ) !%  elevation at non-elevation BC by extrapolating depth if ( bcdata ( ii )% Category /= bc_category_elevation ) then !% INFLOW BC - need eta and velocity on face ! HACK need to review and document this subroutine !faceR(fID,fr_Eta_d) = elem2R(eID,e2r_eta) !faceR(fID,fr_Eta_u) = faceR(fID,fr_Eta_d) faceR ( fID , fr_Eta_d ) = faceR ( fID , fr_Zbottom ) + elem2R ( eID , e2r_HydDepth ) faceR ( fID , fr_Eta_u ) = faceR ( fID , fr_Eta_d ) if ( faceR ( fID , fr_Area_d ) > zeroR ) then faceR ( fID , fr_Velocity_d ) = faceR ( fID , fr_flowrate ) / faceR ( fID , fr_Area_d ) faceR ( fID , fr_HydDepth_d ) = faceR ( fID , fr_Area_d ) / faceR ( fID , fr_Topwidth ) thisFroudeNumber = faceR ( fID , fr_Velocity_d ) / ( sqrt ( grav * faceR ( fID , fr_HydDepth_d )) ) else faceR ( fID , fr_Velocity_d ) = setting % Limiter % Velocity % Maximum faceR ( fID , fr_HydDepth_d ) = setting % Zerovalue % Depth thisFroudeNumber = twoR * setting % Eps % InflowDepthIncreaseFroudeLimit endif faceR ( fID , fr_Velocity_u ) = faceR ( fID , fr_Velocity_d ) faceR ( fID , fr_HydDepth_u ) = faceR ( fID , fr_HydDepth_d ) !%  Froude number limiter on inflow - changes area, velocity,topwidth, and eta !%  Note that depth is not stored on face, so we use interior depth if (( thisFroudeNumber > froudeMax ) . and . & ( setting % Limiter % BC % UseInflowFroudeNumberLimiter )) then !% if max froude is exceeded, we need to adjust the inflow area and !% depth. Note we do not actually store geometry on the inflow, so !% we do this by approximation. We will assume the geometry devolves !% into a simple triangular area of Topwidth T and depth D, so that the !% area is given by !% A = TD/2. !% Then Fr&#94;2 = 4Q&#94;2 / (g T&#94;2 D&#94;3) !% The side slope is H = 2D / T so that !% T = 2D/H !% Thus, Fr&#94;2 = 4Q&#94;2 H&#94;2 / (g 4D&#94;2 D&#94;3) = (QH)&#94;2 / (g D&#94;5) !% or D&#94;5 = (QH)&#94;2 / g Fr&#94;2 !% We assume that the high froude number conditions have the same !% effective side slop of H =2D(old) / T(old) Qrate => faceR ( fID , fr_Flowrate ) ! Depth       => elem2R(eID,e2r_HydDepth) Depth => faceR ( fID , fr_HydDepth_d ) Top => faceR ( fID , fr_Topwidth ) Area => faceR ( fID , fr_Area_d ) sideslope = twoR * Depth / Top Dinc => setting % Eps % InflowDepthIncreaseFroudeLimit thisDepth = (((( Qrate * sideslope ) / froudeMax ) ** 2 ) / grav ) ** ( 1.0 / 5.0 ) thisDepth = ( oneR + Dinc ) * thisDepth faceR ( fID , fr_HydDepth_u ) = thisDepth faceR ( fID , fr_HydDepth_d ) = thisDepth !print *, 'D=', thisDepth, elem2R(eID,e2r_HydDepth) !print *, 'T=',twoR * thisDepth / sideslope, faceR(fID,fr_Topwidth) faceR ( fID , fr_Topwidth ) = twoR * thisDepth / sideslope !print *, 'A=',Top  * thisdepth / twoR, faceR(fID,fr_Area_d) faceR ( fID , fr_Area_d ) = Top * thisdepth / twoR faceR ( fID , fr_Area_u ) = faceR ( fID , fr_Area_d ) !print *, 'E=',faceR(fID,fr_Zbottom) + thisDepth, faceR(fID,fr_Eta_d) faceR ( fID , fr_Eta_d ) = faceR ( fID , fr_Zbottom ) + thisDepth faceR ( fID , fr_Eta_u ) = faceR ( fID , fr_Eta_d ) endif end if !%  flowrate at non-flowrate BC from inside if ( bcdata ( ii )% Category /= bc_category_inflowrate ) then !% ELEVATION BC faceR ( fID , fr_Flowrate ) = elem2R ( eID , e2r_Flowrate ) !%  reset the velocity if ( ( setting % ZeroValue % UseZeroValues ) . and . & ( faceR ( fID , fr_Area_d ) > setting % Zerovalue % Area )) then faceR ( fID , fr_Velocity_d ) = faceR ( fID , fr_Flowrate ) / faceR ( fID , fr_Area_d ) faceR ( fID , fr_Velocity_u ) = faceR ( fID , fr_Velocity_d ) else faceR ( fID , fr_Velocity_d ) = zeroR faceR ( fID , fr_Velocity_u ) = zeroR end if end if end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine bc_face_othervalues ! !========================================================================== !========================================================================== ! subroutine bc_onelement & ( elem2R , bcdata , thisTime , thiscategory , e2r_VelocityColumn ) ! ! Apply boundary conditions (either up or down) to an element. ! ! For elevation, this only affects a ghost cell (for use in interpolation to ! face in bc_onface). For flowrate this affects both ghost and interior cells ! for both flowrate and velocity. ! ! e2r_VelocityColumn only used when thiscategory = bc_category_inflowrate ! in which case it may be either e2r_Velocity or e2r_Velocity_new. character ( 64 ) :: subroutine_name = 'bc_onelement' real , intent ( in out ) :: elem2R (:,:) type ( bcType ), target , intent ( in out ) :: bcdata (:) real , intent ( in ) :: thisTime integer , intent ( in ) :: thiscategory , e2r_VelocityColumn real , pointer :: thisval integer , pointer :: thisloc , thiscat , thisghost integer :: ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !print *, trim(subroutine_name) !print *, elem2R(:,e2r_flowrate) call bc_updatevalue ( bcdata , thisTime ) do ii = 1 , size ( bcdata ) thisghost => bcdata ( ii )% ElemGhostID thisloc => bcdata ( ii )% ElemInsideID thiscat => bcdata ( ii )% category thisval => bcdata ( ii )% thisValue if ( thiscat == thiscategory ) then if ( thiscat == bc_category_elevation ) then !%  store elevation BC on ghost element elem2R ( thisghost , e2r_Eta ) = thisval elseif ( thiscat == bc_category_inflowrate ) then ! store the flowrate and compute the corresponding velocity on interior !elem2R(thisloc,e2r_Flowrate)       = thisval !elem2R(thisloc,e2r_VelocityColumn) = thisval / elem2R(thisloc,e2r_Area) ! store the same value on the ghost elem2R ( thisghost , e2r_Flowrate ) = thisval elem2R ( thisghost , e2r_VelocityColumn ) = thisval / elem2R ( thisloc , e2r_Area ) else print * , 'error: unexpected value for bcdata%category of ' , thiscat , ' in ' , subroutine_name stop endif endif end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine bc_onelement ! !========================================================================== !========================================================================== ! subroutine bc_updatevalue & ( bcdata , thisTime ) ! ! Interpolate the bcdata value for thisTime from the data array stored ! in TimeArray:ValueArray ! character ( 64 ) :: subroutine_name = 'bc_updatevalue' type ( bcType ), intent ( in out ) :: bcdata (:) real , intent ( in ) :: thisTime integer :: ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do ii = 1 , size ( bcdata ) bcdata % thisValue = utility_linear_interpolate_within_indexlist & ( thisTime , bcdata ( ii )% TimeArray , bcdata ( ii )% ValueArray ) bcdata % thisTime = thisTime end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine bc_updatevalue ! !========================================================================== !========================================================================== ! subroutine bc_node_assignment_error_check & ( nodeI , faceI , nBCdir ) ! ! check for node assignment errors in creating the link/node system ! character ( 64 ) :: subroutine_name = 'bc_node_assignment_error_check' integer , target , intent ( in ) :: nodeI (:,:) integer , intent ( in ) :: faceI (:,:) integer , intent ( in ) :: nBCdir character ( len = 8 ) :: cdir integer :: ii integer , pointer :: nidx !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if ( nBCdir == nBCdn ) then cdir = 'dnstream' elseif ( nBCdir == nBCup ) then cdir = 'upstream' else print * , 'error: unknown value for nBCdir in ' , subroutine_name stop endif do ii = 1 , size ( nodeI , 1 ) ! this node ID nidx => nodeI ( ii , ni_idx ) ! check to see if this node is a BC node if ( nodeI ( ii , ni_node_type ) == nBCdir ) then ! count the number of faces that use this node as a BC ! there should be only 1. select case ( count ( faceI (:, fi_node_ID ) == nidx )) case ( 0 ) print * , 'error: BC ' , cdir , ' at node ' , ii , ' with ni_idx ' , nidx , & 'does not have corresponding fi_node_ID in faceI array in ' , subroutine_name stop case ( 1 ) ! no action - all OK case default print * , 'error: BC ' , cdir , ' at node ' , ii , ' with ni_idx ' , nidx , & 'has more than one corresponding fi_node_ID in faceI array in ' , subroutine_name stop end select endif enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine bc_node_assignment_error_check ! !========================================================================== !========================================================================== ! subroutine bc_assign_faceID & ( bcdata , faceI ) ! ! Identify the faceID, ghostID and insideID for a bcdata set where the ! NodeID is already assigned ! character ( 64 ) :: subroutine_name = 'bc_assign_faceID' type ( bcType ), target , intent ( in out ) :: bcdata (:) integer , intent ( in ) :: faceI (:,:) integer , pointer :: nID , fID , insideID , ghostID , updn integer :: ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do ii = 1 , size ( bcdata ) !%  known nID => bcdata ( ii )% NodeID ! already assigned updn => bcdata ( ii )% Updn !%  unknown fID => bcdata ( ii )% FaceID insideID => bcdata ( ii )% ElemInsideID ghostID => bcdata ( ii )% ElemGhostID !%  location where the face nodeID is the same as the bc nodeID fID = minloc ( abs ( faceI (:, fi_node_ID ) - nID ), 1 ) !%  elem that is outside the face if ( updn == bc_updn_downstream ) then ghostID = faceI ( fID , fi_Melem_d ) insideID = faceI ( fid , fi_Melem_u ) elseif ( updn == bc_updn_upstream ) then ghostID = faceI ( fID , fi_Melem_u ) insideID = faceI ( fID , fi_Melem_d ) else print * , 'error: unexpected else in ' , subroutine_name stop end if end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine bc_assign_faceID ! !========================================================================== !========================================================================== ! subroutine bc_adequate_coverage_onedir & ( bcdata , nBCdir ) ! ! check to see if the BC cover the entire simulation period ! character ( 64 ) :: subroutine_name = 'bc_adequate_coverage_onedir' type ( bcType ), intent ( in ) :: bcdata (:) integer , intent ( in ) :: nBCdir real :: timelow , timehigh integer :: ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do ii = 1 , size ( bcdata ) timelow = bcdata ( ii )% TimeArray ( 1 ) !print *, timelow timehigh = bcdata ( ii )% TimeArray ( size ( bcdata ( ii )% TimeArray , 1 )) !print *, timehigh !print *, setting%Time%StartTime !print *, setting%Time%EndTime if ( timelow > setting % Time % StartTime ) then if ( nBCdir == nBCup ) then print * , 'error in bcdataUp(' , ii , ') in ' , subroutine_name elseif ( nBCdir == nBCdn ) then print * , 'error in bcdataDn(' , ii , ') in ' , subroutine_name else print * , 'error: unexpected value of nBCdir ' , nBCdir , ' in ' , subroutine_name endif print * , 'start time of (' , setting % Time % StartTime ,& ' is below lowest available BC data time ' , timelow stop endif if ( timehigh < setting % Time % EndTime ) then if ( nBCdir == nBCup ) then print * , 'error in bcdataUp(' , ii , ') in ' , subroutine_name elseif ( nBCdir == nBCdn ) then print * , 'error in bcdataDn(' , ii , ') in ' , subroutine_name else print * , 'error: unexpected value of nBCdir ' , nBCdir , ' in ' , subroutine_name endif print * , 'end time of (' , setting % Time % EndTime , & ' is greater than highest available BC data time of ' , timehigh stop endif enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine bc_adequate_coverage_onedir ! !========================================================================== ! subroutine bc_ghost_othervalues & ( elem2R , elem2I , faceR , faceI , bcdata , e2i_Mface_dir , e2r_Velocity_new , & fr_Area_dir , fr_Velocity_dir , fr_HydDepth_dir , fr_Eta_dir ) character ( 64 ) :: subroutine_name = 'bc_ghost_othervalues' real , intent ( in out ) :: elem2R (:,:) real , intent ( in ) :: faceR (:,:) integer , intent ( in ) :: elem2I (:,:) integer , target , intent ( in ) :: faceI (:,:) type ( bcType ), target , intent ( in ) :: bcdata (:) integer , intent ( in ) :: e2i_Mface_dir , e2r_Velocity_new integer , intent ( in ) :: fr_Velocity_dir , fr_HydDepth_dir integer , intent ( in ) :: fr_Eta_dir , fr_Area_dir integer , pointer :: thisghost , thisloc , thiscat , thisface integer :: colE ( 5 ), colF ( 5 ), mm , ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do ii = 1 , size ( bcdata ) thisghost => bcdata ( ii )% ElemGhostID thisloc => bcdata ( ii )% ElemInsideID thiscat => bcdata ( ii )% category thisface => faceI ( elem2I ( thisloc , e2i_Mface_dir ), fi_idx ) if ( thiscat == bc_category_elevation ) then ! store all face values except eta on ghost cell colE ( 1 : 5 ) = ( / e2r_Area , e2r_Flowrate , e2r_Velocity_new , e2r_Topwidth , e2r_HydDepth / ) colF ( 1 : 5 ) = ( / fr_Area_dir , fr_Flowrate , fr_Velocity_dir , fr_Topwidth , fr_HydDepth_dir / ) elem2R ( thisghost , colE ( 1 : 5 )) = faceR ( thisface , colF ( 1 : 5 )) elseif ( thiscat == bc_category_inflowrate ) then !%   store all face values except flow rate and velocity on ghost cell. colE ( 1 : 4 ) = ( / e2r_Area , e2r_Topwidth , e2r_HydDepth , e2r_Eta / ) colF ( 1 : 4 ) = ( / fr_Area_dir , fr_Topwidth , fr_HydDepth_dir , fr_Eta_dir / ) elem2R ( thisghost , colE ( 1 : 4 )) = faceR ( thisface , colF ( 1 : 4 )) else print * , 'error: unexpected value for bcdata%category of ' , thiscat , ' in ' , subroutine_name stop endif end do ! print *, trim(subroutine_name) ! print *, elem2R(:,e2r_Velocity) ! print *, faceR(:,fr_Velocity_dir) ! print *, thisghost, thisface if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine bc_ghost_othervalues ! !========================================================================== !========================================================================== ! END OF MODULE bc !========================================================================== end module bc","title":"bc.f08 – SWMMengine","tags":"","loc":"sourcefile/bc.f08.html"},{"text":"Contents Modules link_node Source Code link_node.f08 Source Code module link_node implicit none type date integer :: day , month , year end type date type ( date ) :: today !    today = date(14,7,1950) ! !    integer, parameter ::  n_nodes = 11 !    integer, parameter ::  n_links = 10 !    real :: link_map(n_links,3) !    real :: node_map(n_nodes,3) end module link_node","title":"link_node.f08 – SWMMengine","tags":"","loc":"sourcefile/link_node.f08.html"},{"text":"This file depends on sourcefile~~runge_kutta.f08~~EfferentGraph sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~globals.f08 globals.f08 sourcefile~runge_kutta.f08->sourcefile~globals.f08 sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~runge_kutta.f08->sourcefile~element_geometry.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~runge_kutta.f08->sourcefile~setting_definition.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~runge_kutta.f08->sourcefile~array_index.f08 sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~runge_kutta.f08->sourcefile~element_dynamics.f08 sourcefile~face_values.f08 face_values.f08 sourcefile~runge_kutta.f08->sourcefile~face_values.f08 sourcefile~diagnostic.f08 diagnostic.f08 sourcefile~runge_kutta.f08->sourcefile~diagnostic.f08 sourcefile~adjustments.f08 adjustments.f08 sourcefile~runge_kutta.f08->sourcefile~adjustments.f08 sourcefile~bc.f08 bc.f08 sourcefile~runge_kutta.f08->sourcefile~bc.f08 sourcefile~utility.f08 utility.f08 sourcefile~runge_kutta.f08->sourcefile~utility.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~runge_kutta.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~element_geometry.f08->sourcefile~globals.f08 sourcefile~element_geometry.f08->sourcefile~setting_definition.f08 sourcefile~element_geometry.f08->sourcefile~array_index.f08 sourcefile~element_geometry.f08->sourcefile~adjustments.f08 sourcefile~element_geometry.f08->sourcefile~bc.f08 sourcefile~element_geometry.f08->sourcefile~utility.f08 sourcefile~element_geometry.f08->sourcefile~data_keys.f08 sourcefile~junction.f08 junction.f08 sourcefile~element_geometry.f08->sourcefile~junction.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~element_dynamics.f08->sourcefile~globals.f08 sourcefile~element_dynamics.f08->sourcefile~setting_definition.f08 sourcefile~element_dynamics.f08->sourcefile~array_index.f08 sourcefile~element_dynamics.f08->sourcefile~adjustments.f08 sourcefile~element_dynamics.f08->sourcefile~bc.f08 sourcefile~element_dynamics.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08->sourcefile~data_keys.f08 sourcefile~element_dynamics.f08->sourcefile~junction.f08 sourcefile~face_values.f08->sourcefile~globals.f08 sourcefile~face_values.f08->sourcefile~setting_definition.f08 sourcefile~face_values.f08->sourcefile~array_index.f08 sourcefile~face_values.f08->sourcefile~adjustments.f08 sourcefile~face_values.f08->sourcefile~bc.f08 sourcefile~face_values.f08->sourcefile~utility.f08 sourcefile~face_values.f08->sourcefile~data_keys.f08 sourcefile~diagnostic.f08->sourcefile~globals.f08 sourcefile~diagnostic.f08->sourcefile~setting_definition.f08 sourcefile~diagnostic.f08->sourcefile~array_index.f08 sourcefile~diagnostic.f08->sourcefile~bc.f08 sourcefile~diagnostic.f08->sourcefile~utility.f08 sourcefile~diagnostic.f08->sourcefile~data_keys.f08 sourcefile~diagnostic.f08->sourcefile~type_definitions.f08 sourcefile~adjustments.f08->sourcefile~globals.f08 sourcefile~adjustments.f08->sourcefile~setting_definition.f08 sourcefile~adjustments.f08->sourcefile~array_index.f08 sourcefile~adjustments.f08->sourcefile~utility.f08 sourcefile~adjustments.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~junction.f08->sourcefile~globals.f08 sourcefile~junction.f08->sourcefile~setting_definition.f08 sourcefile~junction.f08->sourcefile~array_index.f08 sourcefile~junction.f08->sourcefile~utility.f08 sourcefile~junction.f08->sourcefile~data_keys.f08 var pansourcefilerunge_kuttaf08EfferentGraph = svgPanZoom('#sourcefilerunge_kuttaf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~runge_kutta.f08~~AfferentGraph sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~time_loop.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules runge_kutta Source Code runge_kutta.f08 Source Code ! module runge_kutta ! ! runge-kutta time advance for a single time step ! !========================================================================== ! module runge_kutta use adjustments use array_index use bc use data_keys use diagnostic use element_geometry use element_dynamics use face_values use globals use setting_definition use utility implicit none private public :: rk2 integer :: debuglevel = 0 contains !========================================================================== !========================================================================== ! subroutine rk2 & ( elem2R , elemMR , elem2I , elemMI , faceR , faceI , elem2YN , elemMYN , faceYN , & bcdataDn , bcdataUp , thistime , dt ) ! ! runge-kutta time advance for a single time step ! character ( 64 ) :: subroutine_name = 'rk2' real , target , intent ( in out ) :: elem2R (:,:), elemMR (:,:), faceR (:,:) integer , target , intent ( in out ) :: elem2I (:,:), elemMI (:,:), faceI (:,:) logical , target , intent ( in out ) :: elem2YN (:,:), elemMYN (:,:), faceYN (:,:) type ( bcType ), intent ( in out ) :: bcdataDn (:), bcdataUp (:) real , intent ( in ) :: thistime , dt integer , pointer :: fdn (:), fup (:) integer :: e2r_Volume_new , e2r_Velocity_new , eMr_Volume_new , eMr_Velocity_new integer :: ii real :: thiscoef ( 2 ), steptime integer :: ilink !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !%  set indexes for temporary space e2r_Volume_new = e2r_Temp ( next_e2r_temparray ) next_e2r_temparray = utility_advance_temp_array ( next_e2r_temparray , e2r_n_temp ) e2r_Velocity_new = e2r_Temp ( next_e2r_temparray ) next_e2r_temparray = utility_advance_temp_array ( next_e2r_temparray , e2r_n_temp ) eMr_Volume_new = eMr_Temp ( next_eMr_temparray ) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) eMr_Velocity_new = eMr_Temp ( next_eMr_temparray ) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) !%  zero out the temporary space elem2R (:, e2r_Volume_new ) = zeroR elem2R (:, e2r_Velocity_new ) = zeroR elemMR (:, eMr_Volume_new ) = zeroR elemMR (:, eMr_Velocity_new ) = zeroR if ( count ( elem2I (:, e2i_elem_type ) == eChannel ) & + count ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) > zeroI ) then !%  coefficients for the rk2 steps thiscoef ( 1 ) = onehalfR thiscoef ( 2 ) = oneR !%  step through the two steps of the RK2 do ii = 1 , 2 steptime = thistime + thiscoef ( ii ) * dt call sve_rk2_step & ( e2r_Volume , e2r_Velocity , eMr_Volume , eMr_Velocity , & e2r_Volume_new , e2r_Velocity_new , eMr_Volume_new , eMr_Velocity_new , & elem2R , elemMR , faceR , elem2I , elemMI , elem2YN , elemMYN , & thiscoef ( ii )) call rk2_update_auxiliary_variables & ( e2r_Velocity_new , eMr_Velocity_new , e2r_Volume_new , eMr_Volume_new , & elem2R , elem2I , elem2YN , & elemMR , elemMI , elemMYN , & faceR , faceI , faceYN , & bcdataDn , bcdataUp , steptime , ii ) if ( ii == 1 ) then !% store the net face fluxes that are used for volume advance. call diagnostic_element_volume_conservation_fluxes & ( elem2R , elem2I , elemMR , elemMI , faceR ) endif end do !% compute local element-based volume conservation call diagnostic_element_volume_conservation & ( elem2R , elem2I , elemMR , elemMI , e2r_Volume_new , eMr_Volume_new ) !%  update the velocity and volume call overwrite_old_values & ( elem2R , elem2I , e2r_Velocity , e2r_Velocity_new , & e2r_Volume , e2r_Volume_new , e2i_elem_type , eChannel , . true .) call overwrite_old_values & ( elemMR , elemMI , eMr_Velocity , eMr_Velocity_new , & eMr_Volume , eMr_Volume_new , eMi_elem_type , eJunctionChannel , . false .) endif !%  reset temporary data space elem2R (:, e2r_Volume_new ) = nullvalueR elem2R (:, e2r_Velocity_new ) = nullvalueR elemMR (:, eMr_Volume_new ) = nullvalueR elemMR (:, eMr_Velocity_new ) = nullvalueR next_e2r_temparray = next_e2r_temparray - 2 next_eMr_temparray = next_eMr_temparray - 2 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine rk2 ! !========================================================================== !========================================================================== ! subroutine sve_rk2_step & ( e2r_Volume_old , e2r_Velocity_old , eMr_Volume_old , eMr_Velocity_old , & e2r_Volume_new , e2r_Velocity_new , eMr_Volume_new , eMr_Velocity_new , & elem2R , elemMR , faceR , elem2I , elemMI , elem2YN , elemMYN , & thiscoef ) ! ! time advance - one step of RK2 ! character ( 64 ) :: subroutine_name = 'sve_rk2_step' ! indexes for old/new volume and velocity storage integer , intent ( in ) :: e2r_Volume_old , e2r_Velocity_old integer , intent ( in ) :: eMr_Volume_old , eMr_Velocity_old integer , intent ( in ) :: e2r_Volume_new , e2r_Velocity_new integer , intent ( in ) :: eMr_Volume_new , eMr_Velocity_new real , target , intent ( in out ) :: elem2R (:,:), elemMR (:,:) real , target , intent ( in ) :: faceR (:,:) integer , target , intent ( in ) :: elem2I (:,:), elemMI (:,:) logical , intent ( in out ) :: elem2YN (:,:), elemMYN (:,:) real , intent ( in ) :: thiscoef real , pointer :: fQ (:), fUdn (:), fUup (:), fAdn (:), fAup (:), fEdn (:), fEup (:) real , pointer :: kc2 (:), ku2 (:), ones2r (:) real , pointer :: kcM (:), kuM (:), onesMr (:) real , pointer :: volume2old (:), volume2new (:), velocity2old (:), velocity2new (:) real , pointer :: volumeMold (:), volumeMnew (:), velocityMold (:), velocityMnew (:) real , pointer :: eta2 (:), etaM (:), rh2 (:), mn2 (:), rhM (:), mnM (:) integer , pointer :: iup (:), idn (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !%  pointers for volume and velocity storage (updating) volume2old => elem2R (:, e2r_Volume_old ) volume2new => elem2R (:, e2r_Volume_new ) velocity2old => elem2R (:, e2r_Velocity_old ) velocity2new => elem2R (:, e2r_Velocity_new ) volumeMold => elemMR (:, eMr_Volume_old ) volumeMnew => elemMR (:, eMr_Volume_new ) velocityMold => elemMR (:, eMr_Velocity_old ) velocityMnew => elemMR (:, eMr_Velocity_new ) eta2 => elem2R (:, e2r_Eta ) rh2 => elem2R (:, e2r_HydRadius ) mn2 => elem2R (:, e2r_Roughness ) etaM => elemMR (:, eMr_Eta ) rhM => elemMR (:, eMr_HydRadius ) mnM => elemMR (:, eMr_Roughness ) !%  temporary space for channel elements kc2 => elem2R (:, e2r_Temp ( next_e2r_temparray )) next_e2r_temparray = utility_advance_temp_array ( next_e2r_temparray , e2r_n_temp ) ku2 => elem2R (:, e2r_Temp ( next_e2r_temparray )) next_e2r_temparray = utility_advance_temp_array ( next_e2r_temparray , e2r_n_temp ) ones2r => elem2R (:, e2r_Temp ( next_e2r_temparray )) next_e2r_temparray = utility_advance_temp_array ( next_e2r_temparray , e2r_n_temp ) !%  temporary space for juctions kcM => elemMR (:, eMr_Temp ( next_eMr_temparray )) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) kuM => elemMR (:, eMr_Temp ( next_eMr_temparray )) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) onesMr => elemMR (:, eMr_Temp ( next_eMr_temparray )) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) !%  zero temporary arrays kc2 = zeroR ku2 = zeroR kcM = zeroR kuM = zeroR !%  initialize ones as 1.0 ones2r = oneR onesMr = oneR !%  pointers for convenience in notation fQ => faceR (:, fr_Flowrate ) fUdn => faceR (:, fr_Velocity_d ) ! velocity on the downstream side of a face fUup => faceR (:, fr_Velocity_u ) ! velocity on the upstream side of a face fAdn => faceR (:, fr_Area_d ) fAup => faceR (:, fr_Area_u ) fEdn => faceR (:, fr_Eta_d ) fEup => faceR (:, fr_Eta_u ) !%  SOURCE TERMS ---------------------------------- !%  Channel elements (one upstream and one downstream face) !%  Using the T00 method of Hodges & Liu, 2018 for momentum iup => elem2I (:, e2i_Mface_u ) idn => elem2I (:, e2i_Mface_d ) where ( elem2I (:, e2i_elem_type ) == eChannel ) kc2 = dt * ( fQ ( iup ) - fQ ( idn ) ) ku2 = dt * ( fQ ( iup ) * fUdn ( iup ) - fQ ( idn ) * fUup ( idn ) & + grav * fAdn ( iup ) * ( fEdn ( iup ) - eta2 ) & - grav * fAup ( idn ) * ( fEup ( idn ) - eta2 ) ) endwhere !%  Junctions (upstream faces) !%  HACK -- needs factor for angle with main channel do mm = 1 , upstream_face_per_elemM iup => elemMI (:, eMi_MfaceUp ( mm )) where ( ( elemMI (:, eMi_elem_type ) == eJunctionChannel ). and . & ( elemMI (:, eMi_nfaces_u ) >= mm ) ) kcM = kcM + dt * fQ ( iup ) kuM = kuM + dt * ( fQ ( iup ) * fUdn ( iup ) & + grav * fAdn ( iup ) * ( fEdn ( iup ) - etaM ) ) endwhere enddo !%  Junctions (downstream faces) do mm = 1 , dnstream_face_per_elemM idn => elemMI (:, eMi_MfaceDn ( mm )) where ( ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMI (:, eMi_nfaces_d ) >= mm ) ) kcM = kcM - dt * fQ ( idn ) kuM = kuM - dt * ( fQ ( idn ) * fUdn ( idn ) & + grav * fAdn ( idn ) * ( fEdn ( idn ) - etaM ) ) endwhere enddo !%  UPDATES ----------------------------------------------- !%  Note the velocity2new is actually velocity*volume at this point where ( elem2I (:, e2i_elem_type ) == eChannel ) volume2new = volume2old + thiscoef * kc2 velocity2new = ( volume2old * velocity2old + thiscoef * ku2 ) & / ( oneR + thiscoef * dt * grav * ( mn2 ** 2 ) * velocity2old / ( rh2 ** ( 4.0 / 3.0 )) ) endwhere where ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) volumeMnew = volumeMold + thiscoef * kcM velocityMnew = ( volumeMold * velocityMold + thiscoef * kuM ) & / ( oneR + thiscoef * dt * grav * ( mnM ** 2 ) * velocityMold / ( rhM ** ( 4.0 / 3.0 )) ) endwhere !%  CORRECTIONS ---------------------------------------------------------- !%  remove negative volumes to prevent problems in velocity computation call adjust_negative_volume_reset ( volume2new ) call adjust_negative_volume_reset ( volumeMnew ) !%  VELOCITY - divide out the volume to get the actual velocity where ( elem2I (:, e2i_elem_type ) == eChannel ) velocity2new = velocity2new / volume2new endwhere where ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) velocityMnew = velocityMnew / volumeMnew endwhere ! release temporary arrays kc2 = nullvalueR ku2 = nullvalueR ones2r = nullvalueR kcM = nullvalueR kuM = nullvalueR onesMr = nullvalueR nullify ( kc2 , ku2 , ones2r , kcM , kuM , onesMr ) next_e2r_temparray = next_e2r_temparray - 3 next_eMr_temparray = next_eMr_temparray - 3 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine sve_rk2_step ! !========================================================================== !========================================================================== ! subroutine rk2_update_auxiliary_variables & ( e2r_Velocity_new , eMr_Velocity_new , e2r_Volume_new , eMr_Volume_new , & elem2R , elem2I , elem2YN , & elemMR , elemMI , elemMYN , & faceR , faceI , faceYN , & bcdataDn , bcdataUp , steptime , rkiteration ) character ( 64 ) :: subroutine_name = 'rk2_update_auxiliary_variables' real , target , intent ( in out ) :: elemMR (:,:) real , intent ( in out ) :: elem2R (:,:), faceR (:,:) integer , intent ( in out ) :: elem2I (:,:), elemMI (:,:), faceI (:,:) logical , intent ( in out ) :: elem2YN (:,:), elemMYN (:,:), faceYN (:,:) type ( bcType ), intent ( in out ) :: bcdataDn (:), bcdataUp (:) integer , intent ( in ) :: e2r_Velocity_new , eMr_Velocity_new integer , intent ( in ) :: e2r_Volume_new , eMr_Volume_new integer , intent ( in ) :: rkiteration real , intent ( in ) :: steptime !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !%  advance all geometry and dynamics call element_geometry_update & ( elem2R , elem2I , elem2YN , e2r_Volume_new , & elemMR , elemMI , elemMYN , eMr_Volume_new , & faceR , faceI , bcdataDn , bcdataUp , steptime , 1 ) !%  at this point, the channels and the junction main sections have the correct !%  geometry, but the junction branches have provisional geometry that is !%  a functoin of the old face free surface elevation call element_dynamics_update & ( elem2R , elemMR , faceR , elem2I , elemMI , elem2YN , elemMYN , & bcdataDn , bcdataUp , e2r_Velocity_new , eMr_Velocity_new , & e2r_Volume_new , eMr_Volume_new , steptime ) !%  Updating the face values by interpolation from neighbor elements !%  This uses the estimated values from the branches call face_update & ( elem2R , elem2I , elemMR , faceR , faceI , faceYN , & bcdataDn , bcdataUp , e2r_Velocity_new , eMr_Velocity_new , & e2r_Volume_new , eMr_Volume_new , steptime , rkiteration ) !% fix the junction branches by interp with face values call element_geometry_branch_fix ( elemMR , elemMI , faceR , faceI ) !%  Ad hoc adjustment for V-shaped flowrates across a channel element if ( setting % Method % AdjustVshapedFlowrate % Apply ) then call adjust_Vshaped_flowrate ( elem2R , faceR , elem2I , elem2YN ) endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine rk2_update_auxiliary_variables ! !========================================================================== !========================================================================== ! subroutine overwrite_old_values & ( elemR , elemI , er_Velocity , er_Velocity_new , er_Volume , er_Volume_new , & ei_elem_type , ThisElemType , overwriteGhost ) ! ! overwrite a new velocity data into the old data space. ! character ( 64 ) :: subroutine_name = 'overwrite_old_values' real , intent ( in out ) :: elemR (:,:) integer , intent ( in ) :: elemI (:,:) integer , intent ( in ) :: er_Velocity , er_Velocity_new integer , intent ( in ) :: er_Volume , er_Volume_new integer , intent ( in ) :: ei_elem_type , ThisElemType logical , intent ( in ) :: overwriteGhost !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name where ( elemI (:, ei_elem_type ) == ThisElemType ) elemR (:, er_Velocity ) = elemR (:, er_Velocity_new ) elemR (:, er_Volume ) = elemR (:, er_Volume_new ) endwhere if ( overwriteGhost ) then where ( ( elemI (:, ei_elem_type ) == eBCup ) . or . & ( elemI (:, ei_elem_type ) == eBCdn ) ) elemR (:, er_Velocity ) = elemR (:, er_Velocity_new ) elemR (:, er_Volume ) = elemR (:, er_Volume_new ) endwhere endif ! print * ! print *,trim(subroutine_name) ! print *, elemR(:,er_Velocity) ! print *, elemR(:,er_Velocity_new) ! print * if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine overwrite_old_values ! !========================================================================== ! END OF MODULE runge_kutta !========================================================================== end module runge_kutta","title":"runge_kutta.f08 – SWMMengine","tags":"","loc":"sourcefile/runge_kutta.f08.html"},{"text":"This file depends on sourcefile~~data_keys.f08~~EfferentGraph sourcefile~data_keys.f08 data_keys.f08 sourcefile~globals.f08 globals.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~data_keys.f08~~AfferentGraph sourcefile~data_keys.f08 data_keys.f08 sourcefile~friction_model.f08 friction_model.f08 sourcefile~friction_model.f08->sourcefile~data_keys.f08 sourcefile~custom_networkold.f08 custom_networkOLD.f08 sourcefile~custom_networkold.f08->sourcefile~data_keys.f08 sourcefile~face_values.f08 face_values.f08 sourcefile~face_values.f08->sourcefile~data_keys.f08 sourcefile~bc.f08 bc.f08 sourcefile~face_values.f08->sourcefile~bc.f08 sourcefile~utility.f08 utility.f08 sourcefile~face_values.f08->sourcefile~utility.f08 sourcefile~adjustments.f08 adjustments.f08 sourcefile~face_values.f08->sourcefile~adjustments.f08 sourcefile~stub.f08 stub.f08 sourcefile~stub.f08->sourcefile~data_keys.f08 sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~runge_kutta.f08->sourcefile~data_keys.f08 sourcefile~runge_kutta.f08->sourcefile~face_values.f08 sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~runge_kutta.f08->sourcefile~element_geometry.f08 sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~runge_kutta.f08->sourcefile~element_dynamics.f08 sourcefile~diagnostic.f08 diagnostic.f08 sourcefile~runge_kutta.f08->sourcefile~diagnostic.f08 sourcefile~runge_kutta.f08->sourcefile~bc.f08 sourcefile~runge_kutta.f08->sourcefile~utility.f08 sourcefile~runge_kutta.f08->sourcefile~adjustments.f08 sourcefile~element_geometry.f08->sourcefile~data_keys.f08 sourcefile~element_geometry.f08->sourcefile~bc.f08 sourcefile~element_geometry.f08->sourcefile~utility.f08 sourcefile~junction.f08 junction.f08 sourcefile~element_geometry.f08->sourcefile~junction.f08 sourcefile~element_geometry.f08->sourcefile~adjustments.f08 sourcefile~initial_condition.f08 initial_condition.f08 sourcefile~initial_condition.f08->sourcefile~data_keys.f08 sourcefile~initial_condition.f08->sourcefile~face_values.f08 sourcefile~initial_condition.f08->sourcefile~element_geometry.f08 sourcefile~initial_condition.f08->sourcefile~element_dynamics.f08 sourcefile~initial_condition.f08->sourcefile~bc.f08 sourcefile~initial_condition.f08->sourcefile~utility.f08 sourcefile~initial_condition.f08->sourcefile~junction.f08 sourcefile~checking.f08 checking.f08 sourcefile~checking.f08->sourcefile~data_keys.f08 sourcefile~test_cases.f08 test_cases.f08 sourcefile~test_cases.f08->sourcefile~data_keys.f08 sourcefile~case_y_channel.f08 case_y_channel.f08 sourcefile~test_cases.f08->sourcefile~case_y_channel.f08 sourcefile~case_simple_channel.f08 case_simple_channel.f08 sourcefile~test_cases.f08->sourcefile~case_simple_channel.f08 sourcefile~test_cases.f08->sourcefile~bc.f08 sourcefile~test_cases.f08->sourcefile~utility.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~data_keys.f08 sourcefile~main.f08->sourcefile~initial_condition.f08 sourcefile~main.f08->sourcefile~checking.f08 sourcefile~main.f08->sourcefile~test_cases.f08 sourcefile~debug.f08 debug.f08 sourcefile~main.f08->sourcefile~debug.f08 sourcefile~main.f08->sourcefile~diagnostic.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~main.f08->sourcefile~time_loop.f08 sourcefile~main.f08->sourcefile~bc.f08 sourcefile~initialization.f08 initialization.f08 sourcefile~main.f08->sourcefile~initialization.f08 sourcefile~main.f08->sourcefile~utility.f08 sourcefile~network_define.f08 network_define.f08 sourcefile~main.f08->sourcefile~network_define.f08 sourcefile~main.f08->sourcefile~junction.f08 sourcefile~output.f08 output.f08 sourcefile~main.f08->sourcefile~output.f08 sourcefile~allocate_storage.f08 allocate_storage.f08 sourcefile~main.f08->sourcefile~allocate_storage.f08 sourcefile~debug.f08->sourcefile~data_keys.f08 sourcefile~debug.f08->sourcefile~bc.f08 sourcefile~debug.f08->sourcefile~utility.f08 sourcefile~case_y_channel.f08->sourcefile~data_keys.f08 sourcefile~case_y_channel.f08->sourcefile~bc.f08 sourcefile~case_y_channel.f08->sourcefile~allocate_storage.f08 sourcefile~element_dynamics.f08->sourcefile~data_keys.f08 sourcefile~element_dynamics.f08->sourcefile~bc.f08 sourcefile~element_dynamics.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08->sourcefile~junction.f08 sourcefile~element_dynamics.f08->sourcefile~adjustments.f08 sourcefile~diagnostic.f08->sourcefile~data_keys.f08 sourcefile~diagnostic.f08->sourcefile~bc.f08 sourcefile~diagnostic.f08->sourcefile~utility.f08 sourcefile~time_loop.f08->sourcefile~data_keys.f08 sourcefile~time_loop.f08->sourcefile~face_values.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~time_loop.f08->sourcefile~debug.f08 sourcefile~time_loop.f08->sourcefile~diagnostic.f08 sourcefile~time_loop.f08->sourcefile~bc.f08 sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~time_loop.f08->sourcefile~explicit_euler.f08 sourcefile~time_loop.f08->sourcefile~output.f08 sourcefile~case_simple_channel.f08->sourcefile~data_keys.f08 sourcefile~case_simple_channel.f08->sourcefile~bc.f08 sourcefile~case_simple_channel.f08->sourcefile~allocate_storage.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~initialization.f08->sourcefile~data_keys.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~network_define.f08->sourcefile~data_keys.f08 sourcefile~network_define.f08->sourcefile~initialization.f08 sourcefile~network_define.f08->sourcefile~junction.f08 sourcefile~network_define.f08->sourcefile~allocate_storage.f08 sourcefile~junction.f08->sourcefile~data_keys.f08 sourcefile~junction.f08->sourcefile~utility.f08 sourcefile~explicit_euler.f08->sourcefile~data_keys.f08 sourcefile~explicit_euler.f08->sourcefile~face_values.f08 sourcefile~explicit_euler.f08->sourcefile~element_geometry.f08 sourcefile~explicit_euler.f08->sourcefile~element_dynamics.f08 sourcefile~explicit_euler.f08->sourcefile~bc.f08 sourcefile~explicit_euler.f08->sourcefile~utility.f08 sourcefile~explicit_euler.f08->sourcefile~adjustments.f08 sourcefile~output.f08->sourcefile~data_keys.f08 sourcefile~output.f08->sourcefile~bc.f08 sourcefile~output.f08->sourcefile~utility.f08 sourcefile~adjustments.f08->sourcefile~data_keys.f08 sourcefile~adjustments.f08->sourcefile~utility.f08 sourcefile~allocate_storage.f08->sourcefile~utility.f08 var pansourcefiledata_keysf08AfferentGraph = svgPanZoom('#sourcefiledata_keysf08AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules data_keys Source Code data_keys.f08 Source Code ! module data_keys ! ! Provides relationship between integers and keys used for different ! data types. ! ! For example, the elem2I(:,:) array has column ei_elem_type that provides ! the index to the element type for each element. The possible values are ! provided below as eChannel, ePipe, etc. ! !========================================================================== module data_keys use globals implicit none ! data types for elemI(:,ei_elem_type). faceI(:,e_type_u), faceI(:,e_type_d) integer , parameter :: eChannel = 1 ! ID for an open channel element integer , parameter :: ePipe = 2 ! ID for an pipe integer , parameter :: eJunctionChannel = 3 ! ID for a junction integer , parameter :: eJunctionPipe = 4 ! ID for a junction integer , parameter :: eCulvert = 5 ! ID for a culvert in an open channel integer , parameter :: ePump = 6 ! ID for a pump integer , parameter :: eValve = 7 ! ID for a valve integer , parameter :: eBCup = 8 ! ID for face upstream BC integer , parameter :: eBCdn = 9 ! ID for face downstream BC ! data types for faceI(:,fi_type) integer , parameter :: fChannel = eChannel ! ID for open channel on both sides integer , parameter :: fPipe = ePipe ! ID for pipe on both sides integer , parameter :: fMultiple = eJunctionChannel ! ID for moderation by separate up/dn element types integer , parameter :: fBCup = eBCup ! ID for face upstream BC integer , parameter :: fBCdn = eBCdn ! ID for face downstream BC ! date types for elemI(:,ei_geometry) integer , parameter :: eRectangular = 1 ! ID for rectangular chanel integer , parameter :: eParabolic = 2 ! ID for parabolic channel integer , parameter :: eTrapezoidal = 3 ! ID for trapezoidal channel integer , parameter :: eWidthDepth = 4 ! ID for general geometry by data pairs ! data types for elemI(:,ei_roughness_type) integer , parameter :: eManningsN = 1 ! ID for mannings n for roughness_type integer , parameter :: eCD = 2 ! ID for using drag coefficient for roughness_type ! data types for faceI(:,jump_type) integer , parameter :: jump_none = 0 ! ID for no jump integer , parameter :: jump_downstream = 1 ! ID for jump in nominal downstream direction integer , parameter :: jump_upstream = 2 ! ID for jump in nominal upstream direction ! data types for nodeI(:,ni_node_type) integer , parameter :: nJ2 = 1 ! ID for junction with 2 links integer , parameter :: nJm = 2 ! ID for junction with multiple links integer , parameter :: nBCdn = 3 ! ID for downstream BC integer , parameter :: nBCup = 4 ! iD for upstream BC ! data types for nodeI(:,ni_assigned) for assignment to faces and links integer , parameter :: nUnassigned = nullvalueI integer , parameter :: nAssigned = 1 integer , parameter :: nDeferred = - 1 ! data types for linkI(:,li_link_type) ! note that these must correspond to element types integer , parameter :: lchannel = eChannel ! ID for link that is open channel integer , parameter :: lpipe = ePipe ! ID for link that is pipe ! data types for linkI(:,li_geometry) (must corresponde with ei_geometry) integer , parameter :: lRectangular = eRectangular ! ID for link that rectangular channel integer , parameter :: lParabolic = eParabolic ! ID for parabolic channel integer , parameter :: lTrapezoidal = eTrapezoidal ! ID for trapezoidal channel integer , parameter :: lWidthDepth = eWidthDepth ! ID for general geometry by data pairs ! data types for linkII(:,li_roughness_type) integer , parameter :: lManningsN = eManningsN ! ID for mannings n for roughness_type integer , parameter :: lCD = eCD ! ID for using drag coefficient for roughness_type ! data types for linkI(:,li_assigned) for assignment to faces and links integer , parameter :: lUnassigned = nullvalueI integer , parameter :: lAssigned = 1 integer , parameter :: lDeferred = - 1 ! data types for bcdata integer , parameter :: bc_updn_downstream = 1 integer , parameter :: bc_updn_upstream = 0 integer , parameter :: bc_category_elevation = 0 integer , parameter :: bc_category_inflowrate = 1 !========================================================================== ! END OF MODULE data_keys !========================================================================== end module data_keys","title":"data_keys.f08 – SWMMengine","tags":"","loc":"sourcefile/data_keys.f08.html"},{"text":"This file depends on sourcefile~~time_loop.f08~~EfferentGraph sourcefile~time_loop.f08 time_loop.f08 sourcefile~debug.f08 debug.f08 sourcefile~time_loop.f08->sourcefile~debug.f08 sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~globals.f08 globals.f08 sourcefile~time_loop.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~time_loop.f08->sourcefile~setting_definition.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~time_loop.f08->sourcefile~array_index.f08 sourcefile~face_values.f08 face_values.f08 sourcefile~time_loop.f08->sourcefile~face_values.f08 sourcefile~diagnostic.f08 diagnostic.f08 sourcefile~time_loop.f08->sourcefile~diagnostic.f08 sourcefile~bc.f08 bc.f08 sourcefile~time_loop.f08->sourcefile~bc.f08 sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~time_loop.f08->sourcefile~explicit_euler.f08 sourcefile~output.f08 output.f08 sourcefile~time_loop.f08->sourcefile~output.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~time_loop.f08->sourcefile~data_keys.f08 sourcefile~debug.f08->sourcefile~globals.f08 sourcefile~debug.f08->sourcefile~setting_definition.f08 sourcefile~debug.f08->sourcefile~array_index.f08 sourcefile~debug.f08->sourcefile~bc.f08 sourcefile~debug.f08->sourcefile~data_keys.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~debug.f08->sourcefile~type_definitions.f08 sourcefile~utility.f08 utility.f08 sourcefile~debug.f08->sourcefile~utility.f08 sourcefile~runge_kutta.f08->sourcefile~globals.f08 sourcefile~runge_kutta.f08->sourcefile~setting_definition.f08 sourcefile~runge_kutta.f08->sourcefile~array_index.f08 sourcefile~runge_kutta.f08->sourcefile~face_values.f08 sourcefile~runge_kutta.f08->sourcefile~diagnostic.f08 sourcefile~runge_kutta.f08->sourcefile~bc.f08 sourcefile~runge_kutta.f08->sourcefile~data_keys.f08 sourcefile~adjustments.f08 adjustments.f08 sourcefile~runge_kutta.f08->sourcefile~adjustments.f08 sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~runge_kutta.f08->sourcefile~element_geometry.f08 sourcefile~runge_kutta.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~runge_kutta.f08->sourcefile~element_dynamics.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~face_values.f08->sourcefile~globals.f08 sourcefile~face_values.f08->sourcefile~setting_definition.f08 sourcefile~face_values.f08->sourcefile~array_index.f08 sourcefile~face_values.f08->sourcefile~bc.f08 sourcefile~face_values.f08->sourcefile~data_keys.f08 sourcefile~face_values.f08->sourcefile~adjustments.f08 sourcefile~face_values.f08->sourcefile~utility.f08 sourcefile~diagnostic.f08->sourcefile~globals.f08 sourcefile~diagnostic.f08->sourcefile~setting_definition.f08 sourcefile~diagnostic.f08->sourcefile~array_index.f08 sourcefile~diagnostic.f08->sourcefile~bc.f08 sourcefile~diagnostic.f08->sourcefile~data_keys.f08 sourcefile~diagnostic.f08->sourcefile~type_definitions.f08 sourcefile~diagnostic.f08->sourcefile~utility.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~explicit_euler.f08->sourcefile~globals.f08 sourcefile~explicit_euler.f08->sourcefile~setting_definition.f08 sourcefile~explicit_euler.f08->sourcefile~array_index.f08 sourcefile~explicit_euler.f08->sourcefile~face_values.f08 sourcefile~explicit_euler.f08->sourcefile~bc.f08 sourcefile~explicit_euler.f08->sourcefile~data_keys.f08 sourcefile~explicit_euler.f08->sourcefile~adjustments.f08 sourcefile~explicit_euler.f08->sourcefile~element_geometry.f08 sourcefile~explicit_euler.f08->sourcefile~utility.f08 sourcefile~explicit_euler.f08->sourcefile~element_dynamics.f08 sourcefile~output.f08->sourcefile~globals.f08 sourcefile~output.f08->sourcefile~setting_definition.f08 sourcefile~output.f08->sourcefile~array_index.f08 sourcefile~output.f08->sourcefile~bc.f08 sourcefile~output.f08->sourcefile~data_keys.f08 sourcefile~output.f08->sourcefile~utility.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~adjustments.f08->sourcefile~globals.f08 sourcefile~adjustments.f08->sourcefile~setting_definition.f08 sourcefile~adjustments.f08->sourcefile~array_index.f08 sourcefile~adjustments.f08->sourcefile~data_keys.f08 sourcefile~adjustments.f08->sourcefile~utility.f08 sourcefile~element_geometry.f08->sourcefile~globals.f08 sourcefile~element_geometry.f08->sourcefile~setting_definition.f08 sourcefile~element_geometry.f08->sourcefile~array_index.f08 sourcefile~element_geometry.f08->sourcefile~bc.f08 sourcefile~element_geometry.f08->sourcefile~data_keys.f08 sourcefile~element_geometry.f08->sourcefile~adjustments.f08 sourcefile~element_geometry.f08->sourcefile~utility.f08 sourcefile~junction.f08 junction.f08 sourcefile~element_geometry.f08->sourcefile~junction.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~element_dynamics.f08->sourcefile~globals.f08 sourcefile~element_dynamics.f08->sourcefile~setting_definition.f08 sourcefile~element_dynamics.f08->sourcefile~array_index.f08 sourcefile~element_dynamics.f08->sourcefile~bc.f08 sourcefile~element_dynamics.f08->sourcefile~data_keys.f08 sourcefile~element_dynamics.f08->sourcefile~adjustments.f08 sourcefile~element_dynamics.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08->sourcefile~junction.f08 sourcefile~junction.f08->sourcefile~globals.f08 sourcefile~junction.f08->sourcefile~setting_definition.f08 sourcefile~junction.f08->sourcefile~array_index.f08 sourcefile~junction.f08->sourcefile~data_keys.f08 sourcefile~junction.f08->sourcefile~utility.f08 var pansourcefiletime_loopf08EfferentGraph = svgPanZoom('#sourcefiletime_loopf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~time_loop.f08~~AfferentGraph sourcefile~time_loop.f08 time_loop.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~time_loop.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules time_loop Source Code time_loop.f08 Source Code ! module time_loop ! ! top-level iteration for continuity and momentum solutions ! !========================================================================== ! module time_loop use array_index use bc use data_keys use debug use diagnostic use explicit_euler use face_values use globals use output use runge_kutta use setting_definition implicit none private public :: time_marching integer :: debuglevel = 0 integer , parameter :: idummy = 0 contains ! !========================================================================== !========================================================================== ! subroutine time_marching & ( elem2R , elemMR , faceR , elem2I , elemMI , faceI , elem2YN , elemMYN , faceYN , & bcdataDn , bcdataUp , linkI , debugfile , diagnostic , threadedfile ) ! ! top-level iteration for continuity and momentum solution ! character ( 64 ) :: subroutine_name = 'time_marching' real , target , intent ( in out ) :: elem2R (:,:), elemMR (:,:), faceR (:,:) integer , target , intent ( in out ) :: elem2I (:,:), elemMI (:,:), faceI (:,:) logical , target , intent ( in out ) :: elem2YN (:,:), elemMYN (:,:), faceYN (:,:) type ( bcType ), intent ( in out ) :: bcdataDn (:), bcdataUp (:) type ( debugfileType ), target , intent ( in ) :: debugfile (:) type ( diagnosticType ), target , intent ( in out ) :: diagnostic (:) type ( threadedfileType ), intent ( in ) :: threadedfile (:) integer , intent ( in ) :: linkI (:,:) real , pointer :: rkVol (:), rkU (:) real , pointer :: fQ (:), fUdn (:), fUup (:), fAdn (:), fAup (:) real , pointer :: fEdn (:), fEup (:), eE (:) real , pointer :: thistime , nexttime integer , pointer :: thisStep , restartStep integer :: ii character ( len = 32 ) :: outdataName !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name thisStep => setting % Step % Current !%  Note that for a restart, the simulation may begin from a step other than 1 !%  In which case, diagnostic storage indexed off of the step are using the !%  step \"FromRestart\" index restartStep => setting % Step % FromRestart thistime => setting % Time % ThisTime nexttime => setting % Time % NextTime !% get the upper time nexttime = thistime + dt call bc_applied_onelement & ( elem2R , bcdataDn , bcdataUp , thistime , bc_category_inflowrate , e2r_Velocity ) call bc_applied_onelement & ( elem2R , bcdataDn , bcdataUp , thistime , bc_category_elevation , idummy ) call bc_applied_onface ( faceR , faceI , elem2R , elem2I , bcdataDn , bcdataUp , e2r_Velocity , thistime ) call diagnostic_volume_conservation & ( diagnostic , elem2R , elem2I , elemMR , elemMI , faceR , bcdataUp , bcdataDn , restartStep , 1 ) restartStep = restartStep + 1 ! HACK required for diagnostics so end of first step is index 2 call output_all_threaded_data_by_link & ( threadedfile , elem2R , elem2I , elemMR , elemMI , faceR , faceI , linkI , & bcdataUp , bcdataDn , 0 ) !% Iterate for a fixed number of steps !% HACK - need to develop better time and iteration controls do while ( thisstep <= setting % step % final ) !% display to the screen if ( setting % Debugout % DisplayInterval > 0 ) then if ( mod ( thisstep , setting % Debugout % DisplayInterval ) == 0 ) then print * , '--------------------------------------' print * , thisstep , '=current step; ' , & diagnostic_CFL ( elem2R , e2r_Timescale_u , e2r_Timescale_d ), '=CFL max' & , maxval ( abs ( elem2R ( 2 : size ( elem2R , 1 ) - 1 , e2r_Velocity ))), '=max velocity' !print *, thisstep,'=current step; ', & !         maxval(elem2R(2:size(elem2R,1)-1,e2r_Flowrate)) endif endif call debug_output & ( debugfile , elem2R , elem2I , elem2YN , elemMR , & elemMI , elemMYN , faceR , faceI , faceYN , bcdataUp , bcdataDn , thisstep ) !%  Reset the flowrate adhoc detection before flowrates are updated. !%  Note that we do not reset the small volume detection here - that is done !%  in the element_geometry module before the volumes are updated. elem2YN (:, e2YN_IsAdhocFlowrate ) = . false . elemMYN (:, eMYN_IsAdhocFlowrate ) = . false . !% Runge-Kutta 2nd-order advance call rk2 & ( elem2R , elemMR , elem2I , elemMI , faceR , faceI , elem2YN , elemMYN , faceYN , & bcdataDn , bcdataUp , thistime , dt ) !% compute the element froude number (diagnostic only) call diagnostic_froude_number ( elem2R , elem2I , elemMR , elemMI ) !% compute the volume conservation call diagnostic_volume_conservation & ( diagnostic , elem2R , elem2I , elemMR , elemMI , faceR , bcdataUp , bcdataDn , restartStep , 2 ) if ( setting % Debugout % DisplayInterval > 0 ) then if ( mod ( thisstep , setting % Debugout % DisplayInterval ) == 0 ) then print * , 'Volume Conservation (this step and total) = ' , & diagnostic ( restartStep )% Volume % ConservationThisStep , & diagnostic ( restartStep )% Volume % ConservationTotal endif endif call output_all_threaded_data_by_link & ( threadedfile , elem2R , elem2I , elemMR , elemMI , faceR , faceI , linkI , & bcdataUp , bcdataDn , thisstep ) !% TEST ROUTINES !    call explicit_euler_advance & !        (elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, faceI, faceYN, & !         bcdataDn, bcdataUp, thistime, dt) !    call explicit_test_advance & !        (elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, faceI, faceYN, & !         bcdataDn, bcdataUp, thistime, dt) ! ! increment the counters thisstep = thisstep + 1 restartStep = restartStep + 1 thistime = nexttime nexttime = thistime + dt enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine time_marching ! !========================================================================== ! END OF MODULE time_loop !========================================================================== end module time_loop","title":"time_loop.f08 – SWMMengine","tags":"","loc":"sourcefile/time_loop.f08.html"},{"text":"This file depends on sourcefile~~debug.f08~~EfferentGraph sourcefile~debug.f08 debug.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~debug.f08->sourcefile~type_definitions.f08 sourcefile~globals.f08 globals.f08 sourcefile~debug.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~debug.f08->sourcefile~setting_definition.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~debug.f08->sourcefile~array_index.f08 sourcefile~bc.f08 bc.f08 sourcefile~debug.f08->sourcefile~bc.f08 sourcefile~utility.f08 utility.f08 sourcefile~debug.f08->sourcefile~utility.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~debug.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 var pansourcefiledebugf08EfferentGraph = svgPanZoom('#sourcefiledebugf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~debug.f08~~AfferentGraph sourcefile~debug.f08 debug.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~time_loop.f08->sourcefile~debug.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~debug.f08 sourcefile~main.f08->sourcefile~time_loop.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules debug Source Code debug.f08 Source Code ! module debug ! ! Provides simple text files output of arrays for debugging. ! This module needs significant restructuring if we want to maintain ! it within the code. ! !========================================================================== ! module debug ! ! handles the debug output file opening, writing, and closing ! use array_index use bc use data_keys use globals use setting_definition use type_definitions use utility implicit none public :: debug_initialize public :: debug_output public :: debug_finalize private integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine debug_initialize & ( debugfile ) ! !   opens debug files for output (HACK - needs work to simplify) ! character ( 64 ) :: subroutine_name = 'debug_initialize' type ( debugfileType ), dimension (:), allocatable , intent ( out ) :: debugfile integer :: allocation_status character ( len = 512 ) :: emsg integer :: ndebug integer :: ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !%  skip this if files are suppressed if ( setting % Debugout % SuppressAllFiles ) return !% HACK the following is rather brittle code. The numbers representing the !% number of debug files to be opened must be exactly equal to the calls to the !% debug_singlefile_open routine. This can be made much more compact and !% efficient - but it is not clear that this is a subroutine that will be !% needed for the long term code. ndebug = 0 if ( setting % Debugout % elem2R ) then ndebug = ndebug + 22 endif if ( setting % Debugout % elem2I ) then ndebug = ndebug + 8 endif if ( setting % Debugout % elem2YN ) then ndebug = ndebug + 2 endif if ( setting % Debugout % elemMR ) then ndebug = ndebug + 43 endif if ( setting % Debugout % elemMI ) then ndebug = ndebug + 9 endif if ( setting % Debugout % elemMYN ) then ndebug = ndebug + 2 endif if ( setting % Debugout % faceR ) then ndebug = ndebug + 10 endif if ( setting % Debugout % faceI ) then ndebug = ndebug + 12 endif if ( setting % Debugout % faceYN ) then ndebug = ndebug + 0 endif if ( setting % Debugout % nodeR ) then ndebug = ndebug + nr_idx_max endif if ( setting % Debugout % nodeI ) then ndebug = ndebug + 5 endif if ( setting % Debugout % nodeYN ) then ndebug = ndebug + 0 endif if ( setting % Debugout % linkR ) then ndebug = ndebug + 4 endif if ( setting % Debugout % linkI ) then ndebug = ndebug + 12 endif if ( setting % Debugout % linkYN ) then ndebug = ndebug + 0 endif allocate ( debugfile ( ndebug ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) !%  HACK the following can be simplified by defining some string arrays !%  and an array of column indexes to use in an iterative call. ii = 1 if ( setting % Debugout % elem2R ) then call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'Volume' , e2r_Volume ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'SmallVolume' , e2r_SmallVolume ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'SmallVolumeRatio' , e2r_SmallVolumeRatio ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'Flowrate' , e2r_Flowrate ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'Velocity' , e2r_Velocity ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'Timescale_u' , e2r_Timescale_u ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'Timescale_d' , e2r_Timescale_d ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'Friction' , e2r_Friction ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'Eta' , e2r_Eta ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'Head' , e2r_Head ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'Area' , e2r_Area ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'Topwidth' , e2r_Topwidth ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'Perimeter' , e2r_Perimeter ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'HydDepth' , e2r_HydDepth ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'HydRadius' , e2r_HydRadius ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'X' , e2r_X ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'Length' , e2r_Length ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'Zbottom' , e2r_Zbottom ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'BreadthScale' , e2r_BreadthScale ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'Roughness' , e2r_Roughness ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'VolumeConservation' , e2r_VolumeConservation ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2R' , 'FroudeNumber' , e2r_FroudeNumber ) ii = ii + 1 endif if ( setting % Debugout % elem2I ) then call debug_singlefile_open ( debugfile ( ii ), 'elem2I' , 'idx' , e2i_idx ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2I' , 'elem_type' , e2i_elem_type ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2I' , 'geometry' , e2i_geometry ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2I' , 'roughness_type' , e2i_roughness_type ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2I' , 'link_ID' , e2i_link_ID ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2I' , 'link_Pos' , e2i_link_Pos ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2I' , 'Mface_u' , e2i_Mface_u ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elem2I' , 'Mface_d' , e2i_Mface_d ) ii = ii + 1 endif if ( setting % Debugout % elem2YN ) then print * , 'error: code for debug output of elem2YN not completed in ' , subroutine_name stop endif if ( setting % Debugout % elemMR ) then call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Volume' , eMr_Volume ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'SmallVolume' , eMr_SmallVolume ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'SmallVolumeRatio' , eMr_SmallVolumeRatio ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Flowrate' , eMr_Flowrate ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Velocity' , eMr_Velocity ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Friction' , eMr_Friction ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Eta' , eMr_Eta ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Head' , eMr_Head ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Area' , eMr_Area ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Topwidth' , eMr_Topwidth ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Perimeter' , eMr_Perimeter ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'HydDepth' , eMr_HydDepth ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'X' , eMr_X ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Length' , eMr_Length ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Zbottom' , eMr_Zbottom ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'BreadthScale' , eMr_BreadthScale ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Roughness' , eMr_Roughness ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'VolumeConservation' , eMr_VolumeConservation ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'FroudeNumber' , eMr_FroudeNumber ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Flowrate_u1' , eMr_Flowrate_u1 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Flowrate_u2' , eMr_Flowrate_u2 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Flowrate_d1' , eMr_Flowrate_d1 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Velocity_u1' , eMr_Velocity_u1 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Velocity_u2' , eMr_Velocity_u2 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Velocity_d1' , eMr_Velocity_d1 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Timescale_u1' , eMr_Timescale_u1 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Timescale_u2' , eMr_Timescale_u2 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Timescale_d1' , eMr_Timescale_d1 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Area_u1' , eMr_Area_u1 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Area_u2' , eMr_Area_u2 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Area_d1' , eMr_Area_d1 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Topwidth_u1' , eMr_Topwidth_u1 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Topwidth_u2' , eMr_Topwidth_u2 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Topwidth_d1' , eMr_Topwidth_d1 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Length_u1' , eMr_Length_u1 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Length_u2' , eMr_Length_u2 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Length_d1' , eMr_Length_d1 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Zbottom_u1' , eMr_Zbottom_u1 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Zbottom_u2' , eMr_Zbottom_u2 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'Zbottom_d1' , eMr_Zbottom_d1 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'BreadthScale_u1' , eMr_BreadthScale_u1 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'BreadthScale_u2' , eMr_BreadthScale_u2 ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'elemMR' , 'BreadthScale_d1' , eMr_BreadthScale_d1 ) ii = ii + 1 endif if ( setting % Debugout % elemMI ) then print * , 'error: code for debug output of elemMI not completed in ' , subroutine_name stop endif if ( setting % Debugout % elemMYN ) then print * , 'error: code for debug otuput of elemMYN not completed in ' , subroutine_name stop endif if ( setting % Debugout % faceR ) then call debug_singlefile_open ( debugfile ( ii ), 'faceR' , 'Area_d' , fr_Area_d ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceR' , 'Area_u' , fr_Area_u ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceR' , 'Eta_d' , fr_Eta_d ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceR' , 'Eta_u' , fr_Eta_u ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceR' , 'Flowrate' , fr_Flowrate ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceR' , 'Topwidth' , fr_Topwidth ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceR' , 'Velocity_d' , fr_Velocity_d ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceR' , 'Velocity_u' , fr_Velocity_u ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceR' , 'Zbottom' , fr_Zbottom ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceR' , 'X' , fr_X ) ii = ii + 1 endif if ( setting % Debugout % faceI ) then call debug_singlefile_open ( debugfile ( ii ), 'faceI' , 'idx' , fi_idx ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceI' , 'fi_type' , fi_type ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceI' , 'Melem_u' , fi_Melem_u ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceI' , 'Melem_d' , fi_Melem_d ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceI' , 'etype_u' , fi_etype_u ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceI' , 'etype_d' , fi_etype_d ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceI' , 'branch_u' , fi_branch_u ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceI' , 'branch_d' , fi_branch_d ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceI' , 'jump_type' , fi_jump_type ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceI' , 'node_ID' , fi_node_ID ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceI' , 'link_ID' , fi_link_ID ) ii = ii + 1 call debug_singlefile_open ( debugfile ( ii ), 'faceI' , 'link_Pos' , fi_link_Pos ) ii = ii + 1 endif if ( setting % Debugout % faceYN ) then print * , 'error: code for debug output of faceYN not completed in ' , subroutine_name stop endif if ( setting % Debugout % nodeR ) then print * , 'error: code for debug output of nodeR not completed in ' , subroutine_name stop endif if ( setting % Debugout % nodeI ) then print * , 'error: code for debug output of nodeI not completed in ' , subroutine_name stop endif if ( setting % Debugout % nodeYN ) then print * , 'error: code for debug output of nodeYN not completed in ' , subroutine_name stop endif if ( setting % Debugout % linkR ) then print * , 'error: code for debug output of linkR not completed in ' , subroutine_name stop endif if ( setting % Debugout % linkI ) then print * , 'error: code for debug output of linkI not completed in ' , subroutine_name stop endif if ( setting % Debugout % linkYN ) then print * , 'error: code for debug output of linkYN not completed in ' , subroutine_name stop endif if ( ii - 1 /= ndebug ) then print * , 'error: There were ' , ii - 1 , ' debug files open, but the debugfile array size was ' ,& ndebug , ' in ' , subroutine_name endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine debug_initialize ! !========================================================================== !========================================================================== ! subroutine debug_output & ( debugfile , & elem2R , elem2I , elem2YN , elemMR , elemMI , elemMYN , faceR , faceI , faceYN , & bcdataUp , bcdataDn , thisstep ) ! !   writes the output to debug files !   call this subroutine anytime you want debug output ! character ( len = 64 ) :: subroutine_name = 'debug_output' real , target , intent ( in ) :: elem2R (:,:), elemMR (:,:), faceR (:,:) integer , target , intent ( in ) :: elem2I (:,:), elemMI (:,:), faceI (:,:) logical , target , intent ( in ) :: elem2YN (:,:), elemMYN (:,:), faceYN (:,:) type ( bcType ), intent ( in ) :: bcdataUp (:), bcdataDn (:) type ( debugfileType ), target , intent ( in ) :: debugfile (:) integer , intent ( in ) :: thisstep character ( len = 32 ), pointer :: ArrayName integer , pointer :: CI , UnitNumber real , pointer :: thisdataR (:) integer , pointer :: thisdataI (:) integer :: arrayContains = 0 ! =1 for real, 2 for integer, 3 for logical integer , parameter :: dataR = 1 integer , parameter :: dataI = 2 integer , parameter :: dataYN = 3 integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !% skip this if file outpus are globally suppressed if ( setting % Debugout % SuppressAllFiles ) return if ( setting % Debugout % DisplayInterval <= 0 ) return if ( mod ( thisstep , setting % Debugout % DisplayInterval ) /= 0 ) return do mm = 1 , size ( debugfile ) UnitNumber => debugfile ( mm )% FileInfo % UnitNumber ArrayName => debugfile ( mm )% ArrayName CI => debugfile ( mm )% ColumnIndex select case ( ArrayName ) case ( 'elem2R' ) thisdataR => elem2R (:, CI ) arrayContains = dataR case ( 'elemMR' ) thisdataR => elemMR (:, CI ) arrayContains = dataR case ( 'faceR' ) thisdataR => faceR (:, CI ) arrayContains = dataR case ( 'elem2I' ) thisdataI => elem2I (:, CI ) arrayContains = dataI case ( 'elemMI' ) print * , 'error: case not handled for ArrayName of ' , ArrayName , ' in ' , subroutine_name stop case ( 'faceI' ) thisdataI => faceI (:, CI ) arrayContains = dataI case ( 'elem2YN' ) print * , 'error: case not handled for ArrayName of ' , ArrayName , ' in ' , subroutine_name stop case ( 'elemMYN' ) print * , 'error: case not handled for ArrayName of ' , ArrayName , ' in ' , subroutine_name stop case ( 'faceYN' ) print * , 'error: case not handled for ArrayName of ' , ArrayName , ' in ' , subroutine_name stop case default print * , 'error: unknown case for ArrayName of ' , ArrayName , ' in ' , subroutine_name stop end select !%  write the time info for this slice if (. not . setting % Debugout % SuppressTimeStep ) write ( UnitNumber , * ) 'step=' , setting % Step % Current if (. not . setting % Debugout % SuppressTimeValue ) write ( UnitNumber , * ) 'time=' , setting % Time % ThisTime !%  write the number of data points and the data itself select case ( arrayContains ) case ( dataR ) if (. not . setting % Debugout % SuppressNdat ) write ( UnitNumber , * ) 'ndat=' , size ( thisdataR ) write ( UnitNumber , * ) thisdataR case ( dataI ) if (. not . setting % Debugout % SuppressNdat ) write ( UnitNumber , * ) 'ndat=' , size ( thisdataI ) write ( UnitNumber , * ) thisdataI case ( dataYN ) print * , 'error: case not handled for ArrayName of dataYN in ' , subroutine_name stop case default print * , 'error: unknown case for arrayContains of ' , arrayContains , ' in ' , subroutine_name stop end select end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine debug_output ! !========================================================================== !========================================================================== ! subroutine debug_finalize & ( debugfile ) ! !   closes debug files before finishing ! character ( 64 ) :: subroutine_name = 'debug_finalize' type ( debugfileType ), intent ( in out ) :: debugfile (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !% skip this if files are suppressed if ( setting % Debugout % SuppressAllFiles ) return do mm = 1 , size ( debugfile ) if ( debugfile ( mm )% FileInfo % IsOpen ) then close ( debugfile ( mm )% FileInfo % UnitNumber ) debugfile ( mm )% FileInfo % IsOpen = . false . endif end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine debug_finalize ! !========================================================================== ! ! PRIVATE BELOW HERE ! !========================================================================== ! subroutine debug_singlefile_open & ( debugfile , ArrayName , DataName , ColumnIndex ) ! ! Opens a single debug output file for writing. ! Will not overwrite any file - instead gives an error if file is found. ! Debug files are given a timestamp of yyyymmdd_hhmm, so overwrites failure ! typically only occurs when two runs are made quickly in the same directory. ! ! On MacOS, we have seen random overwrite failures when the file actually ! does not exist. It seems likely there is a problem in the file directory of ! the Mac we were using. ! character ( 64 ) :: subroutine_name = 'debug_singlefile_open' type ( debugfileType ), intent ( in out ) :: debugfile character ( len =* ), intent ( in ) :: ArrayName , DataName integer , intent ( in ) :: ColumnIndex integer :: open_status character ( len = 512 ) :: emsg !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name open_status = 0 debugfile % FileInfo % UnitNumber = outputfile_next_unitnumber outputfile_next_unitnumber = outputfile_next_unitnumber + 1 debugfile % FileInfo % FileName = trim ( setting % Debugout % Filename ) // '_' // trim ( ArrayName ) // '_' // trim ( DataName ) debugfile % FileInfo % FolderPath = trim ( setting % Debugout % FolderPath ) // trim ( setting % Debugout % FolderName ) // '/' debugfile % FileInfo % FileStatus = 'new' debugfile % FileInfo % IsOpen = . true . debugfile % ArrayName = trim ( ArrayName ) debugfile % ColumnIndex = ColumnIndex debugfile % FileInfo % WriteName = trim ( debugfile % FileInfo % FolderPath ) // & trim ( debugfile % FileInfo % FileName ) // & trim ( setting % Time % DateTimeStamp ) // & '.txt' open ( unit = debugfile % FileInfo % Unitnumber , & file = trim ( debugfile % FileInfo % WriteName ), & status = 'new' , & access = 'sequential' , & form = 'formatted' , & action = 'write' , & iostat = open_status ) emsg = 'file exists or path/folder does not exist: file open failed in ' // trim ( subroutine_name ) & // '; filename = ' // trim ( debugfile % FileInfo % WriteName ) call utility_check_fileopen ( open_status , emsg ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine debug_singlefile_open ! !========================================================================== ! END OF MODULE debug !========================================================================== end module debug","title":"debug.f08 – SWMMengine","tags":"","loc":"sourcefile/debug.f08.html"},{"text":"This file depends on sourcefile~~stub.f08~~EfferentGraph sourcefile~stub.f08 stub.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~stub.f08->sourcefile~setting_definition.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~stub.f08->sourcefile~data_keys.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~stub.f08->sourcefile~array_index.f08 sourcefile~globals.f08 globals.f08 sourcefile~stub.f08->sourcefile~globals.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules stub Source Code stub.f08 Source Code !========================================================================== ! module stub ! use array_index use data_keys use globals use setting_definition implicit none private integer :: debuglevel = 1 contains ! !========================================================================== !========================================================================== ! subroutine x & () character ( 64 ) :: subroutine_name = 'x' !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine x ! !========================================================================== ! END OF MODULE stub !========================================================================== end module stub","title":"stub.f08 – SWMMengine","tags":"","loc":"sourcefile/stub.f08.html"},{"text":"Files dependent on this one sourcefile~~type_definitions.f08~~AfferentGraph sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~debug.f08 debug.f08 sourcefile~debug.f08->sourcefile~type_definitions.f08 sourcefile~globals.f08 globals.f08 sourcefile~debug.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~debug.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08 bc.f08 sourcefile~debug.f08->sourcefile~bc.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~debug.f08->sourcefile~array_index.f08 sourcefile~utility.f08 utility.f08 sourcefile~debug.f08->sourcefile~utility.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~debug.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~diagnostic.f08 diagnostic.f08 sourcefile~diagnostic.f08->sourcefile~type_definitions.f08 sourcefile~diagnostic.f08->sourcefile~globals.f08 sourcefile~diagnostic.f08->sourcefile~setting_definition.f08 sourcefile~diagnostic.f08->sourcefile~bc.f08 sourcefile~diagnostic.f08->sourcefile~array_index.f08 sourcefile~diagnostic.f08->sourcefile~utility.f08 sourcefile~diagnostic.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~type_definitions.f08 sourcefile~main.f08->sourcefile~debug.f08 sourcefile~main.f08->sourcefile~globals.f08 sourcefile~main.f08->sourcefile~setting_definition.f08 sourcefile~main.f08->sourcefile~diagnostic.f08 sourcefile~main.f08->sourcefile~bc.f08 sourcefile~main.f08->sourcefile~array_index.f08 sourcefile~initial_condition.f08 initial_condition.f08 sourcefile~main.f08->sourcefile~initial_condition.f08 sourcefile~test_cases.f08 test_cases.f08 sourcefile~main.f08->sourcefile~test_cases.f08 sourcefile~checking.f08 checking.f08 sourcefile~main.f08->sourcefile~checking.f08 sourcefile~allocate_storage.f08 allocate_storage.f08 sourcefile~main.f08->sourcefile~allocate_storage.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~main.f08->sourcefile~time_loop.f08 sourcefile~initialization.f08 initialization.f08 sourcefile~main.f08->sourcefile~initialization.f08 sourcefile~main.f08->sourcefile~utility.f08 sourcefile~network_define.f08 network_define.f08 sourcefile~main.f08->sourcefile~network_define.f08 sourcefile~junction.f08 junction.f08 sourcefile~main.f08->sourcefile~junction.f08 sourcefile~output.f08 output.f08 sourcefile~main.f08->sourcefile~output.f08 sourcefile~main.f08->sourcefile~data_keys.f08 sourcefile~friction_model.f08 friction_model.f08 sourcefile~friction_model.f08->sourcefile~globals.f08 sourcefile~friction_model.f08->sourcefile~setting_definition.f08 sourcefile~friction_model.f08->sourcefile~array_index.f08 sourcefile~friction_model.f08->sourcefile~data_keys.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~custom_networkold.f08 custom_networkOLD.f08 sourcefile~custom_networkold.f08->sourcefile~globals.f08 sourcefile~custom_networkold.f08->sourcefile~array_index.f08 sourcefile~custom_networkold.f08->sourcefile~data_keys.f08 sourcefile~face_values.f08 face_values.f08 sourcefile~face_values.f08->sourcefile~globals.f08 sourcefile~face_values.f08->sourcefile~setting_definition.f08 sourcefile~face_values.f08->sourcefile~bc.f08 sourcefile~face_values.f08->sourcefile~array_index.f08 sourcefile~face_values.f08->sourcefile~utility.f08 sourcefile~adjustments.f08 adjustments.f08 sourcefile~face_values.f08->sourcefile~adjustments.f08 sourcefile~face_values.f08->sourcefile~data_keys.f08 sourcefile~stub.f08 stub.f08 sourcefile~stub.f08->sourcefile~globals.f08 sourcefile~stub.f08->sourcefile~setting_definition.f08 sourcefile~stub.f08->sourcefile~array_index.f08 sourcefile~stub.f08->sourcefile~data_keys.f08 sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~runge_kutta.f08->sourcefile~globals.f08 sourcefile~runge_kutta.f08->sourcefile~setting_definition.f08 sourcefile~runge_kutta.f08->sourcefile~diagnostic.f08 sourcefile~runge_kutta.f08->sourcefile~bc.f08 sourcefile~runge_kutta.f08->sourcefile~array_index.f08 sourcefile~runge_kutta.f08->sourcefile~face_values.f08 sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~runge_kutta.f08->sourcefile~element_geometry.f08 sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~runge_kutta.f08->sourcefile~element_dynamics.f08 sourcefile~runge_kutta.f08->sourcefile~utility.f08 sourcefile~runge_kutta.f08->sourcefile~adjustments.f08 sourcefile~runge_kutta.f08->sourcefile~data_keys.f08 sourcefile~element_geometry.f08->sourcefile~globals.f08 sourcefile~element_geometry.f08->sourcefile~setting_definition.f08 sourcefile~element_geometry.f08->sourcefile~bc.f08 sourcefile~element_geometry.f08->sourcefile~array_index.f08 sourcefile~element_geometry.f08->sourcefile~utility.f08 sourcefile~element_geometry.f08->sourcefile~junction.f08 sourcefile~element_geometry.f08->sourcefile~adjustments.f08 sourcefile~element_geometry.f08->sourcefile~data_keys.f08 sourcefile~initial_condition.f08->sourcefile~globals.f08 sourcefile~initial_condition.f08->sourcefile~setting_definition.f08 sourcefile~initial_condition.f08->sourcefile~bc.f08 sourcefile~initial_condition.f08->sourcefile~array_index.f08 sourcefile~initial_condition.f08->sourcefile~face_values.f08 sourcefile~initial_condition.f08->sourcefile~element_geometry.f08 sourcefile~initial_condition.f08->sourcefile~element_dynamics.f08 sourcefile~initial_condition.f08->sourcefile~utility.f08 sourcefile~initial_condition.f08->sourcefile~junction.f08 sourcefile~initial_condition.f08->sourcefile~data_keys.f08 sourcefile~test_cases.f08->sourcefile~globals.f08 sourcefile~test_cases.f08->sourcefile~setting_definition.f08 sourcefile~test_cases.f08->sourcefile~bc.f08 sourcefile~test_cases.f08->sourcefile~array_index.f08 sourcefile~case_y_channel.f08 case_y_channel.f08 sourcefile~test_cases.f08->sourcefile~case_y_channel.f08 sourcefile~case_simple_channel.f08 case_simple_channel.f08 sourcefile~test_cases.f08->sourcefile~case_simple_channel.f08 sourcefile~test_cases.f08->sourcefile~utility.f08 sourcefile~test_cases.f08->sourcefile~data_keys.f08 sourcefile~checking.f08->sourcefile~globals.f08 sourcefile~checking.f08->sourcefile~array_index.f08 sourcefile~checking.f08->sourcefile~data_keys.f08 sourcefile~case_y_channel.f08->sourcefile~globals.f08 sourcefile~case_y_channel.f08->sourcefile~setting_definition.f08 sourcefile~case_y_channel.f08->sourcefile~bc.f08 sourcefile~case_y_channel.f08->sourcefile~array_index.f08 sourcefile~case_y_channel.f08->sourcefile~allocate_storage.f08 sourcefile~case_y_channel.f08->sourcefile~data_keys.f08 sourcefile~allocate_storage.f08->sourcefile~globals.f08 sourcefile~allocate_storage.f08->sourcefile~array_index.f08 sourcefile~allocate_storage.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08->sourcefile~globals.f08 sourcefile~element_dynamics.f08->sourcefile~setting_definition.f08 sourcefile~element_dynamics.f08->sourcefile~bc.f08 sourcefile~element_dynamics.f08->sourcefile~array_index.f08 sourcefile~element_dynamics.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08->sourcefile~junction.f08 sourcefile~element_dynamics.f08->sourcefile~adjustments.f08 sourcefile~element_dynamics.f08->sourcefile~data_keys.f08 sourcefile~time_loop.f08->sourcefile~debug.f08 sourcefile~time_loop.f08->sourcefile~globals.f08 sourcefile~time_loop.f08->sourcefile~setting_definition.f08 sourcefile~time_loop.f08->sourcefile~diagnostic.f08 sourcefile~time_loop.f08->sourcefile~bc.f08 sourcefile~time_loop.f08->sourcefile~array_index.f08 sourcefile~time_loop.f08->sourcefile~face_values.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~time_loop.f08->sourcefile~explicit_euler.f08 sourcefile~time_loop.f08->sourcefile~output.f08 sourcefile~time_loop.f08->sourcefile~data_keys.f08 sourcefile~case_simple_channel.f08->sourcefile~globals.f08 sourcefile~case_simple_channel.f08->sourcefile~setting_definition.f08 sourcefile~case_simple_channel.f08->sourcefile~bc.f08 sourcefile~case_simple_channel.f08->sourcefile~array_index.f08 sourcefile~case_simple_channel.f08->sourcefile~allocate_storage.f08 sourcefile~case_simple_channel.f08->sourcefile~data_keys.f08 sourcefile~initialization.f08->sourcefile~globals.f08 sourcefile~initialization.f08->sourcefile~array_index.f08 sourcefile~initialization.f08->sourcefile~data_keys.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~network_define.f08->sourcefile~globals.f08 sourcefile~network_define.f08->sourcefile~array_index.f08 sourcefile~network_define.f08->sourcefile~allocate_storage.f08 sourcefile~network_define.f08->sourcefile~initialization.f08 sourcefile~network_define.f08->sourcefile~junction.f08 sourcefile~network_define.f08->sourcefile~data_keys.f08 sourcefile~junction.f08->sourcefile~globals.f08 sourcefile~junction.f08->sourcefile~setting_definition.f08 sourcefile~junction.f08->sourcefile~array_index.f08 sourcefile~junction.f08->sourcefile~utility.f08 sourcefile~junction.f08->sourcefile~data_keys.f08 sourcefile~explicit_euler.f08->sourcefile~globals.f08 sourcefile~explicit_euler.f08->sourcefile~setting_definition.f08 sourcefile~explicit_euler.f08->sourcefile~bc.f08 sourcefile~explicit_euler.f08->sourcefile~array_index.f08 sourcefile~explicit_euler.f08->sourcefile~face_values.f08 sourcefile~explicit_euler.f08->sourcefile~element_geometry.f08 sourcefile~explicit_euler.f08->sourcefile~element_dynamics.f08 sourcefile~explicit_euler.f08->sourcefile~utility.f08 sourcefile~explicit_euler.f08->sourcefile~adjustments.f08 sourcefile~explicit_euler.f08->sourcefile~data_keys.f08 sourcefile~output.f08->sourcefile~globals.f08 sourcefile~output.f08->sourcefile~setting_definition.f08 sourcefile~output.f08->sourcefile~bc.f08 sourcefile~output.f08->sourcefile~array_index.f08 sourcefile~output.f08->sourcefile~utility.f08 sourcefile~output.f08->sourcefile~data_keys.f08 sourcefile~adjustments.f08->sourcefile~globals.f08 sourcefile~adjustments.f08->sourcefile~setting_definition.f08 sourcefile~adjustments.f08->sourcefile~array_index.f08 sourcefile~adjustments.f08->sourcefile~utility.f08 sourcefile~adjustments.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 var pansourcefiletype_definitionsf08AfferentGraph = svgPanZoom('#sourcefiletype_definitionsf08AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules type_definitions Source Code type_definitions.f08 Source Code ! module type defintions ! ! These are derived type definitions that are used in globals, setting, and ! elsewhere. ! ! Note that each of these is intended to be dependent only on derived ! types within this module. ! ! Types that are defined outside of here or setting_definition should ! be confined to the module in which they are defined. ! !========================================================================== module type_definitions implicit none public type string character ( len = :), allocatable :: str end type string !%  diagnostic%Volume type diagnosticVolumeType integer :: Step real :: Time real :: Volume real :: VolumeChange real :: NetInflowVolume real :: InflowRate real :: OutflowRate real :: ConservationThisStep ! + is artificial source, - is sink real :: ConservationTotal end type diagnosticVolumeType type diagnosticType type ( diagnosticVolumeType ) :: Volume end type diagnosticType !% boundary condition data type bcType integer :: Idx integer :: NodeID integer :: FaceID integer :: ElemGhostID integer :: ElemInsideID integer :: Updn ! bc_updn_...  (0 = upstream,  1 = downstream) integer :: Category ! bc_category_... (0 = elevation, 1 = inflowrate) real , dimension (:), allocatable :: TimeArray real , dimension (:), allocatable :: ValueArray real :: ThisValue real :: ThisTime real :: ThisFlowrate end type bcType !% output file location type outputfileType integer :: UnitNumber = 0 character ( 256 ) :: FileName = 'dummy.txt' character ( 256 ) :: FolderName = 'dummyFolder' character ( 256 ) :: FolderPath = './' character ( 32 ) :: FileStatus = 'new' character ( 512 ) :: WriteName = '' logical :: IsOpen = . false . end type outputfileType !% specific information for a debug file type debugfileType type ( outputfileType ) :: FileInfo character ( 32 ) :: ArrayName integer :: ColumnIndex end type debugfileType !% specific information for a threaded output file type threadedfileType type ( outputfileType ) :: FileInfo character ( 32 ) :: DataName end type threadedfileType !========================================================================== ! END OF MODULE type_definitions !========================================================================== end module type_definitions","title":"type_definitions.f08 – SWMMengine","tags":"","loc":"sourcefile/type_definitions.f08.html"},{"text":"This file depends on sourcefile~~globals.f08~~EfferentGraph sourcefile~globals.f08 globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~globals.f08~~AfferentGraph sourcefile~globals.f08 globals.f08 sourcefile~friction_model.f08 friction_model.f08 sourcefile~friction_model.f08->sourcefile~globals.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~friction_model.f08->sourcefile~array_index.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~friction_model.f08->sourcefile~data_keys.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~custom_networkold.f08 custom_networkOLD.f08 sourcefile~custom_networkold.f08->sourcefile~globals.f08 sourcefile~custom_networkold.f08->sourcefile~array_index.f08 sourcefile~custom_networkold.f08->sourcefile~data_keys.f08 sourcefile~face_values.f08 face_values.f08 sourcefile~face_values.f08->sourcefile~globals.f08 sourcefile~face_values.f08->sourcefile~array_index.f08 sourcefile~bc.f08 bc.f08 sourcefile~face_values.f08->sourcefile~bc.f08 sourcefile~utility.f08 utility.f08 sourcefile~face_values.f08->sourcefile~utility.f08 sourcefile~adjustments.f08 adjustments.f08 sourcefile~face_values.f08->sourcefile~adjustments.f08 sourcefile~face_values.f08->sourcefile~data_keys.f08 sourcefile~stub.f08 stub.f08 sourcefile~stub.f08->sourcefile~globals.f08 sourcefile~stub.f08->sourcefile~array_index.f08 sourcefile~stub.f08->sourcefile~data_keys.f08 sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~runge_kutta.f08->sourcefile~globals.f08 sourcefile~runge_kutta.f08->sourcefile~array_index.f08 sourcefile~runge_kutta.f08->sourcefile~face_values.f08 sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~runge_kutta.f08->sourcefile~element_geometry.f08 sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~runge_kutta.f08->sourcefile~element_dynamics.f08 sourcefile~diagnostic.f08 diagnostic.f08 sourcefile~runge_kutta.f08->sourcefile~diagnostic.f08 sourcefile~runge_kutta.f08->sourcefile~bc.f08 sourcefile~runge_kutta.f08->sourcefile~utility.f08 sourcefile~runge_kutta.f08->sourcefile~adjustments.f08 sourcefile~runge_kutta.f08->sourcefile~data_keys.f08 sourcefile~element_geometry.f08->sourcefile~globals.f08 sourcefile~element_geometry.f08->sourcefile~array_index.f08 sourcefile~element_geometry.f08->sourcefile~bc.f08 sourcefile~element_geometry.f08->sourcefile~utility.f08 sourcefile~junction.f08 junction.f08 sourcefile~element_geometry.f08->sourcefile~junction.f08 sourcefile~element_geometry.f08->sourcefile~adjustments.f08 sourcefile~element_geometry.f08->sourcefile~data_keys.f08 sourcefile~initial_condition.f08 initial_condition.f08 sourcefile~initial_condition.f08->sourcefile~globals.f08 sourcefile~initial_condition.f08->sourcefile~array_index.f08 sourcefile~initial_condition.f08->sourcefile~face_values.f08 sourcefile~initial_condition.f08->sourcefile~element_geometry.f08 sourcefile~initial_condition.f08->sourcefile~element_dynamics.f08 sourcefile~initial_condition.f08->sourcefile~bc.f08 sourcefile~initial_condition.f08->sourcefile~utility.f08 sourcefile~initial_condition.f08->sourcefile~junction.f08 sourcefile~initial_condition.f08->sourcefile~data_keys.f08 sourcefile~test_cases.f08 test_cases.f08 sourcefile~test_cases.f08->sourcefile~globals.f08 sourcefile~test_cases.f08->sourcefile~array_index.f08 sourcefile~case_y_channel.f08 case_y_channel.f08 sourcefile~test_cases.f08->sourcefile~case_y_channel.f08 sourcefile~case_simple_channel.f08 case_simple_channel.f08 sourcefile~test_cases.f08->sourcefile~case_simple_channel.f08 sourcefile~test_cases.f08->sourcefile~bc.f08 sourcefile~test_cases.f08->sourcefile~utility.f08 sourcefile~test_cases.f08->sourcefile~data_keys.f08 sourcefile~checking.f08 checking.f08 sourcefile~checking.f08->sourcefile~globals.f08 sourcefile~checking.f08->sourcefile~array_index.f08 sourcefile~checking.f08->sourcefile~data_keys.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~globals.f08 sourcefile~main.f08->sourcefile~array_index.f08 sourcefile~main.f08->sourcefile~initial_condition.f08 sourcefile~main.f08->sourcefile~test_cases.f08 sourcefile~main.f08->sourcefile~checking.f08 sourcefile~debug.f08 debug.f08 sourcefile~main.f08->sourcefile~debug.f08 sourcefile~allocate_storage.f08 allocate_storage.f08 sourcefile~main.f08->sourcefile~allocate_storage.f08 sourcefile~main.f08->sourcefile~diagnostic.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~main.f08->sourcefile~time_loop.f08 sourcefile~main.f08->sourcefile~bc.f08 sourcefile~initialization.f08 initialization.f08 sourcefile~main.f08->sourcefile~initialization.f08 sourcefile~main.f08->sourcefile~utility.f08 sourcefile~network_define.f08 network_define.f08 sourcefile~main.f08->sourcefile~network_define.f08 sourcefile~main.f08->sourcefile~junction.f08 sourcefile~output.f08 output.f08 sourcefile~main.f08->sourcefile~output.f08 sourcefile~main.f08->sourcefile~data_keys.f08 sourcefile~debug.f08->sourcefile~globals.f08 sourcefile~debug.f08->sourcefile~array_index.f08 sourcefile~debug.f08->sourcefile~bc.f08 sourcefile~debug.f08->sourcefile~utility.f08 sourcefile~debug.f08->sourcefile~data_keys.f08 sourcefile~case_y_channel.f08->sourcefile~globals.f08 sourcefile~case_y_channel.f08->sourcefile~array_index.f08 sourcefile~case_y_channel.f08->sourcefile~allocate_storage.f08 sourcefile~case_y_channel.f08->sourcefile~bc.f08 sourcefile~case_y_channel.f08->sourcefile~data_keys.f08 sourcefile~allocate_storage.f08->sourcefile~globals.f08 sourcefile~allocate_storage.f08->sourcefile~array_index.f08 sourcefile~allocate_storage.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08->sourcefile~globals.f08 sourcefile~element_dynamics.f08->sourcefile~array_index.f08 sourcefile~element_dynamics.f08->sourcefile~bc.f08 sourcefile~element_dynamics.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08->sourcefile~junction.f08 sourcefile~element_dynamics.f08->sourcefile~adjustments.f08 sourcefile~element_dynamics.f08->sourcefile~data_keys.f08 sourcefile~diagnostic.f08->sourcefile~globals.f08 sourcefile~diagnostic.f08->sourcefile~array_index.f08 sourcefile~diagnostic.f08->sourcefile~bc.f08 sourcefile~diagnostic.f08->sourcefile~utility.f08 sourcefile~diagnostic.f08->sourcefile~data_keys.f08 sourcefile~time_loop.f08->sourcefile~globals.f08 sourcefile~time_loop.f08->sourcefile~array_index.f08 sourcefile~time_loop.f08->sourcefile~face_values.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~time_loop.f08->sourcefile~debug.f08 sourcefile~time_loop.f08->sourcefile~diagnostic.f08 sourcefile~time_loop.f08->sourcefile~bc.f08 sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~time_loop.f08->sourcefile~explicit_euler.f08 sourcefile~time_loop.f08->sourcefile~output.f08 sourcefile~time_loop.f08->sourcefile~data_keys.f08 sourcefile~case_simple_channel.f08->sourcefile~globals.f08 sourcefile~case_simple_channel.f08->sourcefile~array_index.f08 sourcefile~case_simple_channel.f08->sourcefile~allocate_storage.f08 sourcefile~case_simple_channel.f08->sourcefile~bc.f08 sourcefile~case_simple_channel.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~initialization.f08->sourcefile~globals.f08 sourcefile~initialization.f08->sourcefile~array_index.f08 sourcefile~initialization.f08->sourcefile~data_keys.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~network_define.f08->sourcefile~globals.f08 sourcefile~network_define.f08->sourcefile~array_index.f08 sourcefile~network_define.f08->sourcefile~allocate_storage.f08 sourcefile~network_define.f08->sourcefile~initialization.f08 sourcefile~network_define.f08->sourcefile~junction.f08 sourcefile~network_define.f08->sourcefile~data_keys.f08 sourcefile~junction.f08->sourcefile~globals.f08 sourcefile~junction.f08->sourcefile~array_index.f08 sourcefile~junction.f08->sourcefile~utility.f08 sourcefile~junction.f08->sourcefile~data_keys.f08 sourcefile~explicit_euler.f08->sourcefile~globals.f08 sourcefile~explicit_euler.f08->sourcefile~array_index.f08 sourcefile~explicit_euler.f08->sourcefile~face_values.f08 sourcefile~explicit_euler.f08->sourcefile~element_geometry.f08 sourcefile~explicit_euler.f08->sourcefile~element_dynamics.f08 sourcefile~explicit_euler.f08->sourcefile~bc.f08 sourcefile~explicit_euler.f08->sourcefile~utility.f08 sourcefile~explicit_euler.f08->sourcefile~adjustments.f08 sourcefile~explicit_euler.f08->sourcefile~data_keys.f08 sourcefile~output.f08->sourcefile~globals.f08 sourcefile~output.f08->sourcefile~array_index.f08 sourcefile~output.f08->sourcefile~bc.f08 sourcefile~output.f08->sourcefile~utility.f08 sourcefile~output.f08->sourcefile~data_keys.f08 sourcefile~adjustments.f08->sourcefile~globals.f08 sourcefile~adjustments.f08->sourcefile~array_index.f08 sourcefile~adjustments.f08->sourcefile~utility.f08 sourcefile~adjustments.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 var pansourcefileglobalsf08AfferentGraph = svgPanZoom('#sourcefileglobalsf08AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules globals Source Code globals.f08 Source Code ! module globals ! ! These are global parameters and variables that are not associated with ! the 2D data storage arrays or the setting structure. ! ! The globals for data storage are found in modules array_index and data_keys ! The globals for setting are found in module setting_definition ! !========================================================================== module globals use setting_definition use type_definitions implicit none public character ( len = 99 ) :: casename ! note that nullvalueI < 0 is required integer , parameter :: nullvalueI = - 998877 real , parameter :: nullvalueR = - 9.98877e16 logical , parameter :: nullvalueL = . false . real , parameter :: zeroR = 0.0 real , parameter :: oneR = 1.0 real , parameter :: twoR = 2.0 real , parameter :: threeR = 3.0 real , parameter :: fourR = 4.0 real , parameter :: eightR = 8.0 real , parameter :: tenR = 1 0.0 real , parameter :: oneeighthR = oneR / eightR real , parameter :: onefourthR = oneR / fourR real , parameter :: onethirdR = oneR / threeR real , parameter :: onehalfR = oneR / twoR real , parameter :: twothirdR = twoR / threeR real , parameter :: threefourthR = threeR / fourR integer , parameter :: zeroI = 0 integer , parameter :: oneI = 1 integer :: N_link integer :: N_node integer :: N_elem2 integer :: N_elemM integer :: N_face integer :: N_BCupstream integer :: N_BCdnstream integer :: dummy_face_index integer :: dummy_elem2_index integer :: dummy_elemM_index integer :: next_e2i_temparray = 1 integer :: next_e2r_temparray = 1 integer :: next_e2YN_temparray = 1 integer :: next_eMi_temparray = 1 integer :: next_eMr_temparray = 1 integer :: next_eMYN_temparray = 1 integer :: next_fi_temparray = 1 integer :: next_fr_temparray = 1 integer :: next_fYN_temparray = 1 integer :: outputfile_next_unitnumber = 10 ! used for fileopening ! useful shortcuts real , pointer :: dt => setting % time % dt real , pointer :: grav => setting % constant % gravity integer :: debugcounter = 0 integer , parameter :: debuglevelall = 0 ! set to 1 to get print of subroutine calls integer :: idummyarray ( 1 ) !========================================================================== ! END OF MODULE globals !========================================================================== end module globals","title":"globals.f08 – SWMMengine","tags":"","loc":"sourcefile/globals.f08.html"},{"text":"This file depends on sourcefile~~adjustments.f08~~EfferentGraph sourcefile~adjustments.f08 adjustments.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~adjustments.f08->sourcefile~setting_definition.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~adjustments.f08->sourcefile~data_keys.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~adjustments.f08->sourcefile~array_index.f08 sourcefile~utility.f08 utility.f08 sourcefile~adjustments.f08->sourcefile~utility.f08 sourcefile~globals.f08 globals.f08 sourcefile~adjustments.f08->sourcefile~globals.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 var pansourcefileadjustmentsf08EfferentGraph = svgPanZoom('#sourcefileadjustmentsf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~adjustments.f08~~AfferentGraph sourcefile~adjustments.f08 adjustments.f08 sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~element_geometry.f08->sourcefile~adjustments.f08 sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~runge_kutta.f08->sourcefile~adjustments.f08 sourcefile~runge_kutta.f08->sourcefile~element_geometry.f08 sourcefile~face_values.f08 face_values.f08 sourcefile~runge_kutta.f08->sourcefile~face_values.f08 sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~runge_kutta.f08->sourcefile~element_dynamics.f08 sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~explicit_euler.f08->sourcefile~adjustments.f08 sourcefile~explicit_euler.f08->sourcefile~element_geometry.f08 sourcefile~explicit_euler.f08->sourcefile~face_values.f08 sourcefile~explicit_euler.f08->sourcefile~element_dynamics.f08 sourcefile~face_values.f08->sourcefile~adjustments.f08 sourcefile~element_dynamics.f08->sourcefile~adjustments.f08 sourcefile~initial_condition.f08 initial_condition.f08 sourcefile~initial_condition.f08->sourcefile~element_geometry.f08 sourcefile~initial_condition.f08->sourcefile~face_values.f08 sourcefile~initial_condition.f08->sourcefile~element_dynamics.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~time_loop.f08->sourcefile~explicit_euler.f08 sourcefile~time_loop.f08->sourcefile~face_values.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~initial_condition.f08 sourcefile~main.f08->sourcefile~time_loop.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules adjustments Source Code adjustments.f08 Source Code ! module adjustments ! ! These are utility codes that make ad hoc adjustments to the simulation ! results. These are typically to prevent negative or zero values or ! to compensate for grid-scale oscillation. ! !========================================================================== ! module adjustments ! use array_index use data_keys use setting_definition use globals use utility implicit none private public :: adjust_channel_velocity_limiter public :: adjust_junction_branch_velocity_limit public :: adjust_face_dynamic_limits public :: adjust_for_zero_geometry public :: adjust_negative_volume_reset public :: adjust_smallvolumes public :: adjust_Vshaped_flowrate public :: adjust_zero_velocity_at_zero_volume integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine adjust_channel_velocity_limiter & ( elemR , elemYN , elemI , & ei_elem_type , elemType , eYN_IsAdhocFlowrate , er_Velocity_new ) ! ! Limits the velocity in channel elements to setting%Limiter%Velocity%Maximum ! In general, this should only be needed where the volumes start getting small, ! but also could accidentally mask (or delay) an instability. ! character ( 64 ) :: subroutine_name = 'adjust_channel_velocity_limiter' real , target , intent ( in out ) :: elemR (:,:) logical , intent ( in out ) :: elemYN (:,:) integer , intent ( in ) :: elemI (:,:) integer , intent ( in ) :: ei_elem_type , elemType , eYN_IsAdhocFlowrate integer , intent ( in ) :: er_Velocity_new real , pointer :: velocity (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if ( setting % Limiter % Velocity % UseLimitMax ) then velocity => elemR (:, er_Velocity_new ) where ( ( abs ( velocity ) > setting % Limiter % Velocity % Maximum ) . and . & ( elemI (:, ei_elem_type ) == elemType ) ) velocity = sign ( 0.99 * setting % Limiter % Velocity % Maximum , velocity ) elemYN (:, eYN_IsAdhocFlowrate ) = . true . endwhere endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine adjust_channel_velocity_limiter ! !========================================================================== !========================================================================== ! subroutine adjust_junction_branch_velocity_limit & ( elemMR , elemMI ) ! ! This handles the velocity limiter only in junction branches, ! Note that the channel elements and base junction velocity limits ! are enforced in a call to adjust_channel_velocity_limiter in the ! time marching. ! ! HACK - this could be cleaned up into 2 calls to a function, but be careful ! that we don't introduce pass-by-value. ! character ( 64 ) :: subroutine_name = 'adjust_junction_branch_velocity_limit' real , target , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) real , pointer :: velocity (:), flowrate (:), area (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if ( setting % Limiter % Velocity % UseLimitMax ) then do mm = 1 , upstream_face_per_elemM velocity => elemMR (:, eMr_VelocityUp ( mm )) flowrate => elemMR (:, eMr_FlowrateUp ( mm )) area => elemMR (:, eMr_AreaUp ( mm )) where ( ( abs ( velocity ) > setting % Limiter % Velocity % Maximum ) . and . & ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMI (:, eMi_nfaces_u ) >= mm ) ) velocity = sign ( 0.99 * setting % Limiter % Velocity % Maximum , velocity ) flowrate = velocity * area endwhere enddo do mm = 1 , dnstream_face_per_elemM velocity => elemMR (:, eMr_VelocityDn ( mm )) flowrate => elemMR (:, eMr_FlowrateDn ( mm )) area => elemMR (:, eMr_AreaDn ( mm )) where ( ( abs ( velocity ) > setting % limiter % velocity % Maximum ) . and . & ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMI (:, eMi_nfaces_d ) >= mm ) ) velocity = sign ( 0.99 * setting % Limiter % Velocity % Maximum , velocity ) flowrate = velocity * area endwhere enddo endif nullify ( velocity ) nullify ( flowrate ) nullify ( area ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine adjust_junction_branch_velocity_limit ! !========================================================================== !========================================================================== ! subroutine adjust_face_dynamic_limits & ( faceR , faceI , volumeUp , volumeDn , facemask , Ltemp ) ! ! ensures face velocity and areas are within limits ! character ( 64 ) :: subroutine_name = 'adjust_face_dynamic_limits' real , intent ( in out ) :: faceR (:,:) ! note, requires that elemR be provided separately for upstream and downstream ! these can be the samy arrays (e.g. in the case of elem2R for channel-channel) real , intent ( in ) :: volumeUp (:), volumeDn (:) integer , target , intent ( in ) :: faceI (:,:) logical , intent ( in ) :: facemask (:), Ltemp real , pointer :: volFrac integer , pointer :: eUp (:), eDn (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name ! Ad hoc limit the volume that can be transported out of the upstream cell. if ( setting % Limiter % Flowrate % UseFaceVolumeTransport ) then volFrac => setting % Limiter % flowrate % FaceVolumeTransport eUp => faceI (:, fi_Melem_u ) eDn => faceI (:, fi_Melem_d ) !if (Ltemp) then !    print *, trim(subroutine_name) !    print *, facemask !    print *, faceR(:,fr_flowrate) !    print *, eUp !    print *, volumeUp !    print *, volumeUp(eUp) !    print *, eDn !    print *, volumeDn !    !stop !endif !%   for a downstream flow, limit flux from the upstream volume where (( facemask ) . and . ( faceR (:, fr_flowrate ) > zeroR )) faceR (:, fr_flowrate ) = min ( volFrac * volumeUp ( eUp ) / dt , faceR (:, fr_flowrate )) endwhere where (( facemask ) . and . ( faceR (:, fr_flowrate ) < zeroR )) faceR (:, fr_flowrate ) = - min ( volFrac * volumeDn ( eDn ) / dt , - faceR (:, fr_flowrate )) endwhere endif !%  ensure face area is not smaller than zerovalue if ( setting % ZeroValue % UseZeroValues ) then where (( facemask ) . and . ( faceR (:, fr_Area_d ) < setting % Zerovalue % Area )) faceR (:, fr_Area_d ) = setting % Zerovalue % Area endwhere where (( facemask ) . and . ( faceR (:, fr_Area_u ) < setting % Zerovalue % Area )) faceR (:, fr_Area_u ) = setting % Zerovalue % Area endwhere where (( facemask ) . and . ( faceR (:, fr_Area_d ) >= setting % Zerovalue % Area )) faceR (:, fr_Velocity_d ) = faceR (:, fr_Flowrate ) / faceR (:, fr_Area_d ) endwhere where (( facemask ) . and . ( faceR (:, fr_Area_u ) >= setting % Zerovalue % Area )) faceR (:, fr_Velocity_u ) = faceR (:, fr_Flowrate ) / faceR (:, fr_Area_u ) endwhere endif !%  limit high velocities if ( setting % Limiter % Velocity % UseLimitMax ) then where ( ( facemask ) . and . & ( abs ( faceR (:, fr_Velocity_d )) > setting % Limiter % Velocity % Maximum ) ) faceR (:, fr_Velocity_d ) = sign ( 0.99 * setting % Limiter % Velocity % Maximum , & faceR (:, fr_Velocity_d ) ) endwhere where ( ( facemask ) . and . & ( abs ( faceR (:, fr_Velocity_u )) > setting % Limiter % Velocity % Maximum ) ) faceR (:, fr_Velocity_u ) = sign ( 0.99 * setting % Limiter % Velocity % Maximum , & faceR (:, fr_Velocity_u ) ) endwhere endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine adjust_face_dynamic_limits ! !========================================================================== !========================================================================== ! subroutine adjust_for_zero_geometry & ( elem2R , elem2YN , elemMR , elemMI , elemMYN ) ! ! resets geometry to user setting%ZeroValues where the geometry is too small ! character ( 64 ) :: subroutine_name = 'adjust_for_zero_geometry' real , intent ( in out ) :: elem2R (:,:) real , target , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) logical , intent ( in ) :: elem2YN (:,:), elemMYN (:,:) real , pointer :: area (:), topwidth (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !%  Handle channels call reset_element_for_zero_values & ( elem2R , elem2YN , e2r_Area , e2r_Eta , e2r_Zbottom , e2r_Topwidth , & e2r_Perimeter , e2r_HydDepth , e2r_HydRadius , e2YN_IsSmallVolume ) !%  Handle central data for multi-branch junctions call reset_element_for_zero_values & ( elemMR , elemMYN , eMr_Area , eMr_Eta , eMr_Zbottom , eMr_Topwidth , & eMr_Perimeter , eMr_HydDepth , eMr_HydRadius , eMYN_IsSmallVolume ) !%  Handle branch data for multi-branch junctions !%  Upstream branches call reset_juctionbranches_for_zero_values & ( elemMR , elemMI , elemMYN , eMr_AreaUp , eMr_TopwidthUp , eMi_nfaces_u , upstream_face_per_elemM ) !%  Downstream branches call reset_juctionbranches_for_zero_values & ( elemMR , elemMI , elemMYN , eMr_AreaDn , eMr_TopwidthDn , eMi_nfaces_d , dnstream_face_per_elemM ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine adjust_for_zero_geometry ! !========================================================================== !========================================================================== ! subroutine adjust_negative_volume_reset & ( volume ) ! ! Ensures that any negative volumes are set to  setting%Zerovalue%Volume ! This is a limited routine called during time-stepping to ensure that ! we don't have a divide by zero (or small value) prior to the full ! geometry reset. ! character ( 64 ) :: subroutine_name = 'adjust_negative_volume_reset' real , intent ( in out ) :: volume (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if ( setting % ZeroValue % UseZeroValues ) then where ( volume < setting % Zerovalue % Volume ) volume = setting % Zerovalue % Volume endwhere else where ( volume < zeroR ) volume = zeroR endwhere endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine adjust_negative_volume_reset ! !========================================================================== !========================================================================== ! subroutine adjust_smallvolumes & ( elem2R , elem2I , elem2YN , e2r_VolumeColumn , & elemMR , elemMI , elemMYN , eMr_VolumeColumn ) ! ! Handle small volumes - ensures cells with depths that are at or below ! setting%SmallVolume%DepthCutoff have geometry set to small finite values ! from setting%SmallVolume%... ! ! Note that input includes specific VolumeColumn indexes so that the adjustments ! can be made to a temporary data column during the time march. ! character ( 64 ) :: subroutine_name = 'adjust_smallvolumes' real , intent ( in out ) :: elem2R (:,:), elemMR (:,:) integer , intent ( in ) :: elem2I (:,:), elemMI (:,:) logical , intent ( in out ) :: elem2YN (:,:), elemMYN (:,:) integer , intent ( in ) :: e2r_VolumeColumn , eMr_VolumeColumn !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if (. not . setting % SmallVolume % UseSmallVolumes ) return !%  Identify the small volumes and update the small volume ratio !%  which are stored in elemYN(:,isSmallVolume) and elemR(:,SmallVolumeRatio) call smallvolume_identification & ( elem2R , elem2I , elem2YN , e2r_VolumeColumn , & elemMR , elemMI , elemMYN , eMr_VolumeColumn ) call smallvolume_geometry ( elem2R , elem2YN , elemMR , elemMYN ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine adjust_smallvolumes ! !========================================================================== !========================================================================== ! subroutine adjust_Vshaped_flowrate & ( elem2R , faceR , elem2I , elem2YN ) ! ! Finds places where face flowrates and element flowrates are V-shaped ! The V is reduced by adjusting the element flowrate ! character ( 64 ) :: subroutine_name = 'adjust_Vshaped_flowrate' real , target , intent ( in out ) :: elem2R (:,:) real , target , intent ( in ) :: faceR (:,:) integer , target , intent ( in ) :: elem2I (:,:) logical , target , intent ( in out ) :: elem2YN (:,:) real , pointer :: elemFlow (:), faceFlow (:), elemAdjust (:), elemVel (:), elemArea (:) real , pointer :: tscaleUp (:), tscaleDn (:) integer , pointer :: mapUp (:), mapDn (:) logical , pointer :: elemMask (:) integer :: e2r_adjustflow , e2YN_mask real , pointer :: coef !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name e2r_adjustflow = e2r_Temp ( next_e2r_temparray ) next_e2r_temparray = utility_advance_temp_array ( next_e2r_temparray , e2r_n_temp ) e2YN_mask = e2YN_Temp ( next_e2YN_temparray ) next_e2YN_temparray = utility_advance_temp_array ( next_e2YN_temparray , e2YN_n_temp ) elemFlow => elem2R (:, e2r_Flowrate ) elemVel => elem2R (:, e2r_Velocity ) elemArea => elem2R (:, e2r_Area ) tscaleUp => elem2R (:, e2r_Timescale_u ) tscaleDn => elem2R (:, e2r_Timescale_d ) elemAdjust => elem2R (:, e2r_adjustflow ) elemMask => elem2YN (:, e2YN_mask ) elemMask = . false . faceFlow => faceR (:, fr_Flowrate ) mapUp => elem2I (:, e2i_Mface_u ) mapDn => elem2I (:, e2i_Mface_d ) elemAdjust => elem2R (:, e2r_adjustflow ) !% HACK - at this point only handling channel elements where ( elem2I (:, e2i_elem_type ) == eChannel ) elemMask = . true . endwhere !%  Mask is the cells where the flowrate in the element is higher than both !%  of the faces. where ( elemMask ) elemMask = ( ( utility_sign_with_ones ( faceFlow ( mapUp ) - elemFlow )) & * ( utility_sign_with_ones ( faceFlow ( mapDn ) - elemFlow )) > 0 ) endwhere !%  The adjusted element flowrate is a linear weighting of face flowrates !%  so that the face with the shorter timescale to reach has larger influence. !% !%  Arguably, this would likely be best using timescales, but we need to test !%  this further ! where (elemMask) !    elemAdjust =  (  tscaleUp * faceFlow(mapDn)   & !                   + tscaleDn * faceFlow(mapUp) ) & !                 / ( tscaleUp + tscaleDn ) ! endwhere where ( elemMask ) elemAdjust = ( 0.5 * faceFlow ( mapDn ) & + 0.5 * faceFlow ( mapUp ) ) endwhere !% apply a weighted combination based on the setting coefficient to damp the V coef => setting % Method % AdjustVshapedFlowrate % Coef where ( elemMask ) elemFlow = coef * elemAdjust + ( oneR - coef ) * elemFlow elemVel = elemFlow / elemArea endwhere !print *, elemFlow(size(elemFlow)-5:size(elemFlow)) !%  close up the temp arrays elemAdjust = nullvalueR nullify ( elemAdjust ) next_e2r_temparray = next_e2r_temparray - 1 elemMask = nullvalueL nullify ( elemMask ) next_e2YN_temparray = next_e2YN_temparray - 1 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine adjust_Vshaped_flowrate ! !========================================================================== !========================================================================== ! subroutine adjust_zero_velocity_at_zero_volume & ( elem2R , elem2YN , e2r_VelocityColumn , e2r_VolumeColumn , & elemMR , elemMYN , eMr_VelocityColumn , eMr_VolumeColumn ) ! ! ensures that volumes smaller than the user limit have dynamics ! that are set to the user limit. ! ! This can create small non-zero momentum in the flow if the user minimums ! for setting%ZeroValue%Velocity, Flowrate are non-zero ! character ( 64 ) :: subroutine_name = 'adjust_zero_velocity_at_zero_volume' real , intent ( in out ) :: elem2R (:,:), elemMR (:,:) logical , intent ( in out ) :: elem2YN (:,:), elemMYN (:,:) integer , intent ( in ) :: e2r_VelocityColumn , e2r_VolumeColumn integer , intent ( in ) :: eMr_VelocityColumn , eMr_VolumeColumn !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if ( setting % ZeroValue % Volume > zeroR ) then call zero_velocity_at_zero_volume & ( elem2R , elem2YN , e2r_VelocityColumn , e2r_VolumeColumn , e2YN_IsAdhocFlowrate ) call zero_velocity_at_zero_volume & ( elemMR , elemMYN , eMr_VelocityColumn , eMr_VolumeColumn , eMYN_IsAdhocFlowrate ) endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine adjust_zero_velocity_at_zero_volume ! !========================================================================== ! ! PRIVATE BELOW HERE ! !========================================================================== ! subroutine smallvolume_identification & ( elem2R , elem2I , elem2YN , eTr_Volume2 , & elemMR , elemMI , elemMYN , eTr_VolumeM ) ! ! updates small volume identification for different element types ! character ( 64 ) :: subroutine_name = 'smallvolume_identification' real , target , intent ( in out ) :: elem2R (:,:), elemMR (:,:) integer , target , intent ( in ) :: elem2I (:,:), elemMI (:,:) logical , target , intent ( in out ) :: elem2YN (:,:), elemMYN (:,:) integer , intent ( in ) :: eTr_Volume2 , eTr_VolumeM real , pointer :: smallvolumeratio (:), smallvolume (:), tvolume (:) integer , pointer :: elemtype (:) logical , pointer :: issmallvolume (:) integer :: thiselemtype !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if (. not . setting % SmallVolume % UseSmallVolumes ) return !%  for channel elements smallvolumeratio => elem2R (:, e2r_SmallvolumeRatio ) smallvolume => elem2R (:, e2r_Smallvolume ) issmallvolume => elem2YN (:, e2YN_IsSmallVolume ) tvolume => elem2R (:, eTr_Volume2 ) elemtype => elem2I (:, e2i_elem_type ) thiselemtype = eChannel call smallvolume_identification_for_element & ( tvolume , smallvolumeratio , smallvolume , issmallvolume , & elemtype , thiselemtype ) !%  for junction elements smallvolumeratio => elemMR (:, eMr_SmallvolumeRatio ) smallvolume => elemMR (:, eMr_Smallvolume ) issmallvolume => elemMYN (:, eMYN_IsSmallVolume ) tvolume => elemMR (:, eTr_VolumeM ) elemtype => elemMI (:, eMi_elem_type ) thiselemtype = eJunctionChannel call smallvolume_identification_for_element & ( tvolume , smallvolumeratio , smallvolume , issmallvolume , & elemtype , thiselemtype ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine smallvolume_identification ! !========================================================================== !========================================================================== ! subroutine smallvolume_identification_for_element & ( volume , smallvolumeratio , smallvolume , issmallvolume , & elemtype , thiselementtype ) ! ! updates smallvolume identification for a single element type ! character ( 64 ) :: subroutine_name = 'smallvolume_identification_for_element' real , intent ( in out ) :: volume (:), smallvolumeratio (:) real , intent ( in ) :: smallvolume (:) integer , intent ( in ) :: elemtype (:) logical , intent ( in out ) :: issmallvolume (:) integer , intent ( in ) :: thiselementtype !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if (. not . setting % SmallVolume % UseSmallVolumes ) return !%  zero out small volumes (reset further below to setting%Zerovalue%Volume !%  purpose is to ensure that volumes below the zero value will only use !%  the Chezy-Manning approximation for flow. !%  NOTE: this is a source of a small volume non-conservation of mass where (( volume < setting % Zerovalue % Volume ) . and . ( elemtype == thiselementtype )) volume = zeroR endwhere !%  Compute smallvolume_ratio where the local volume is small !%  The ratio fraction used as a blending function in small volumes !%  and is 1.0 where the element volume is exactly the small volume where (( volume < smallvolume ) . and . ( elemtype == thiselementtype )) issmallvolume = . true . smallvolumeratio = volume / smallvolume endwhere !%  reset zero volumes to small volume value where (( volume <= setting % Zerovalue % Volume ) . and . ( elemtype == thiselementtype )) volume = setting % Zerovalue % Volume endwhere if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine smallvolume_identification_for_element ! !========================================================================== !========================================================================== ! subroutine smallvolume_geometry & ( elem2R , elem2YN , & elemMR , elemMYN ) ! ! adjusts geometry that are designated as \"smallvolume\", which are derived ! from the setting%SmallDepth ! character ( 64 ) :: subroutine_name = 'smallvolume_geometry' real , intent ( in out ) :: elem2R (:,:) real , target , intent ( in out ) :: elemMR (:,:) logical , intent ( in ) :: elem2YN (:,:), elemMYN (:,:) real , pointer :: area (:), topwidth (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if (. not . setting % SmallVolume % UseSmallVolumes ) return !%  channel elements call smallvolume_element_geometry_reset & ( elem2R , elem2YN , & e2r_Area , e2r_Eta , e2r_Perimeter , e2r_Zbottom , e2r_HydDepth , e2r_HydRadius , & e2r_Topwidth , e2YN_IsSmallVolume ) !%  junction elements call smallvolume_element_geometry_reset & ( elemMR , elemMYN , & eMr_Area , eMr_Eta , eMr_Perimeter , eMr_Zbottom , eMr_HydDepth , eMr_HydRadius , & eMr_Topwidth , eMYN_IsSmallVolume ) !%  junction branches call smallvolume_junctionbranch_reset & ( elemMR , elemMYN , eMr_AreaUp , eMr_TopwidthUp , upstream_face_per_elemM ) call smallvolume_junctionbranch_reset & ( elemMR , elemMYN , eMr_AreaDn , eMr_TopwidthDn , dnstream_face_per_elemM ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine smallvolume_geometry ! !========================================================================== !========================================================================== ! subroutine smallvolume_element_geometry_reset & ( elemR , elemYN , & er_Area , er_Eta , er_Perimeter , er_Zbottom , er_HydDepth , er_HydRadius , & er_Topwidth , eYN_IsSmallVolume ) ! ! for small volumes, reset the geometry to the setting%smallvolume values ! character ( 64 ) :: subroutine_name = 'smallvolume_element_geometry_reset' real , target , intent ( in out ) :: elemR (:,:) logical , intent ( in ) :: elemYN (:,:) integer , intent ( in ) :: er_Area , er_Eta , er_Perimeter , er_Zbottom integer , intent ( in ) :: er_HydDepth , er_HydRadius , er_Topwidth integer , intent ( in ) :: eYN_IsSmallVolume real , pointer :: area (:), eta (:), perimeter (:), zbottom (:) real , pointer :: hyddepth (:), hydradius (:) real , pointer :: topwidth (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if (. not . setting % SmallVolume % UseSmallVolumes ) return area => elemR (:, er_Area ) perimeter => elemR (:, er_Perimeter ) hyddepth => elemR (:, er_Hyddepth ) hydradius => elemR (:, er_Hydradius ) topwidth => elemR (:, er_Topwidth ) eta => elemR (:, er_Eta ) zbottom => elemR (:, er_Zbottom ) where ( elemYN (:, eYN_IsSmallVolume )) area = setting % SmallVolume % MinimumArea perimeter = setting % SmallVolume % MinimumTopwidth hyddepth = setting % SmallVolume % DepthCutoff hydradius = setting % SmallVolume % MinimumHydRadius topwidth = setting % SmallVolume % MinimumTopwidth eta = setting % SmallVolume % DepthCutoff + zbottom endwhere if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine smallvolume_element_geometry_reset ! !========================================================================== !========================================================================== ! subroutine smallvolume_junctionbranch_reset & ( elemMR , elemMYN , eMr_AreaDir , eMr_TopwidthDir , & Dir_face_per_elem ) ! ! reset the values for branches in a junction that has a smallvolume ! character ( 64 ) :: subroutine_name = 'smallvolume_junctionbranch_reset' real , target , intent ( in out ) :: elemMR (:,:) logical , intent ( in ) :: elemMYN (:,:) ! dnstream_face_per_elemM or upstream_face_per_elemM integer , intent ( in ) :: Dir_face_per_elem integer , intent ( in ) :: eMr_AreaDir (:), eMr_TopwidthDir (:) real , pointer :: area (:), topwidth (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if (. not . setting % SmallVolume % UseSmallVolumes ) return do mm = 1 , Dir_face_per_elem area => elemMR (:, eMr_AreaDir ( mm )) topwidth => elemMR (:, eMr_TopwidthDir ( mm )) where ( elemMYN (:, eMYN_IsSmallVolume )) topwidth = setting % SmallVolume % MinimumTopwidth area = setting % SmallVolume % MinimumArea endwhere enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine smallvolume_junctionbranch_reset ! !========================================================================== !========================================================================== ! subroutine reset_element_for_zero_values & ( elemR , elemYN , er_Area , er_Eta , er_Zbottom , er_Topwidth , er_Perimeter , & er_HydDepth , er_HydRadius , eYN_IsSmallVolume ) ! ! Adjusts miscellaneous geometry for small or negative values ! Note thismask is true only where elemYN(:,IsSmallVolume) is false). ! That is, this only applies to elements NOT covered by the small volume ! algorithm. ! ! In general, this should not be needed, but is provided in case the ! setting%SmallVolume algorithm is turned off or if some degenerate case ! occurs where the volume is large but the element geometry is small. ! character ( 64 ) :: subroutine_name = 'reset_element_for_zero_values' real , target , intent ( in out ) :: elemR (:,:) logical , intent ( in ) :: elemYN (:,:) integer , intent ( in ) :: er_Area , er_Eta , er_Zbottom , er_Topwidth integer , intent ( in ) :: er_Perimeter , er_HydDepth , er_HydRadius integer , intent ( in ) :: eYN_IsSmallVolume real , pointer :: area (:), eta (:), topwidth (:), perimeter (:) real , pointer :: zbottom (:), hyddepth (:), hydradius (:) integer :: ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name area => elemR (:, er_Area ) eta => elemR (:, er_Eta ) topwidth => elemR (:, er_Topwidth ) perimeter => elemR (:, er_Perimeter ) hyddepth => elemR (:, er_HydDepth ) hydradius => elemR (:, er_HydRadius ) zbottom => elemR (:, er_Zbottom ) if ( setting % ZeroValue % UseZeroValues ) then where (. not . elemYN (:, eYN_IsSmallVolume )) where ( area < setting % Zerovalue % Area ) area = setting % Zerovalue % Area endwhere where ( eta - zbottom < setting % Zerovalue % Depth ) eta = zbottom + setting % Zerovalue % Depth endwhere where ( topwidth < setting % Zerovalue % Topwidth ) topwidth = setting % Zerovalue % Topwidth endwhere where ( perimeter < setting % Zerovalue % Topwidth ) perimeter = setting % Zerovalue % Topwidth endwhere where ( hyddepth < setting % Zerovalue % Depth ) hyddepth = setting % Zerovalue % Depth endwhere where ( hydradius < setting % Zerovalue % Depth ) hydradius = setting % Zerovalue % Depth endwhere endwhere else where (. not . elemYN (:, eYN_IsSmallVolume )) where ( area < zeroR ) area = zeroR endwhere where ( eta - zbottom < zeroR ) eta = zbottom endwhere where ( topwidth < zeroR ) topwidth = zeroR endwhere where ( perimeter < zeroR ) perimeter = zeroR endwhere where ( hyddepth < zeroR ) hyddepth = zeroR endwhere where ( hydradius < zeroR ) hydradius = zeroR endwhere endwhere endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine reset_element_for_zero_values ! !========================================================================== !========================================================================== ! subroutine reset_juctionbranches_for_zero_values & ( elemMR , elemMI , elemMYN , eMr_AreaDir , eMr_TopwidthDir , & eMr_nfaces_Dir , Dir_face_per_elemM ) ! ! resets values below the zero value to the zero value in ! junction branches. Applied separately for upstream and downstream branches. ! character ( 64 ) :: subroutine_name = 'reset_juctionbranches_for_zero_values' real , target , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) logical , intent ( in ) :: elemMYN (:,:) integer , intent ( in ) :: Dir_face_per_elemM , eMr_nfaces_Dir integer , intent ( in ) :: eMr_AreaDir (:), eMr_TopwidthDir (:) real , pointer :: area (:), topwidth (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do mm = 1 , Dir_face_per_elemM area => elemMR (:, eMr_AreaDir ( mm )) topwidth => elemMR (:, eMr_TopwidthDir ( mm )) if ( setting % ZeroValue % UseZeroValues ) then where ((. not . elemMYN (:, eMYN_IsSmallVolume )) . and . ( elemMI (:, eMr_nfaces_Dir ) >= mm )) where ( area < setting % Zerovalue % Area ) area = setting % Zerovalue % Area endwhere where ( topwidth < setting % Zerovalue % Topwidth ) topwidth = setting % Zerovalue % Topwidth endwhere endwhere else where ((. not . elemMYN (:, eMYN_IsSmallVolume )) . and . ( elemMI (:, eMr_nfaces_Dir ) >= mm )) where ( area < zeroR ) area = zeroR endwhere where ( topwidth < setting % Zerovalue % Topwidth ) topwidth = zeroR endwhere endwhere endif enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine reset_juctionbranches_for_zero_values ! !========================================================================== !========================================================================== ! subroutine zero_velocity_at_zero_volume & ( elemR , elemYN , er_Velocity , er_Volume , eYN_IsAdhocFlowrate ) ! ! sets velocity to minimal values if the volume is less ! than the user minimum. Note that this should only apply in volumes that ! are << elemR(:,Smallvolume) ! character ( 64 ) :: subroutine_name = 'zero_velocity_at_zero_volume' real , target , intent ( in out ) :: elemR (:,:) logical , intent ( in out ) :: elemYN (:,:) integer , intent ( in ) :: er_Velocity , er_Volume , eYN_IsAdhocFlowrate real , pointer :: velocity (:), volume (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if ( setting % ZeroValue % Volume > 0.0 ) then velocity => elemR (:, er_Velocity ) volume => elemR (:, er_Volume ) where ( volume <= setting % Zerovalue % Volume ) velocity = sign ( setting % Zerovalue % Velocity , velocity ) elemYN (:, eYN_IsAdhocFlowrate ) = . true . endwhere endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine zero_velocity_at_zero_volume ! !========================================================================== ! END OF MODULE adjustments !========================================================================== end module adjustments","title":"adjustments.f08 – SWMMengine","tags":"","loc":"sourcefile/adjustments.f08.html"},{"text":"This file depends on sourcefile~~utility.f08~~EfferentGraph sourcefile~utility.f08 utility.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~globals.f08 globals.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~utility.f08~~AfferentGraph sourcefile~utility.f08 utility.f08 sourcefile~debug.f08 debug.f08 sourcefile~debug.f08->sourcefile~utility.f08 sourcefile~bc.f08 bc.f08 sourcefile~debug.f08->sourcefile~bc.f08 sourcefile~junction.f08 junction.f08 sourcefile~junction.f08->sourcefile~utility.f08 sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~runge_kutta.f08->sourcefile~utility.f08 sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~runge_kutta.f08->sourcefile~element_geometry.f08 sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~runge_kutta.f08->sourcefile~element_dynamics.f08 sourcefile~face_values.f08 face_values.f08 sourcefile~runge_kutta.f08->sourcefile~face_values.f08 sourcefile~diagnostic.f08 diagnostic.f08 sourcefile~runge_kutta.f08->sourcefile~diagnostic.f08 sourcefile~runge_kutta.f08->sourcefile~bc.f08 sourcefile~adjustments.f08 adjustments.f08 sourcefile~runge_kutta.f08->sourcefile~adjustments.f08 sourcefile~element_geometry.f08->sourcefile~utility.f08 sourcefile~element_geometry.f08->sourcefile~junction.f08 sourcefile~element_geometry.f08->sourcefile~bc.f08 sourcefile~element_geometry.f08->sourcefile~adjustments.f08 sourcefile~allocate_storage.f08 allocate_storage.f08 sourcefile~allocate_storage.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08->sourcefile~junction.f08 sourcefile~element_dynamics.f08->sourcefile~bc.f08 sourcefile~element_dynamics.f08->sourcefile~adjustments.f08 sourcefile~face_values.f08->sourcefile~utility.f08 sourcefile~face_values.f08->sourcefile~bc.f08 sourcefile~face_values.f08->sourcefile~adjustments.f08 sourcefile~diagnostic.f08->sourcefile~utility.f08 sourcefile~diagnostic.f08->sourcefile~bc.f08 sourcefile~initial_condition.f08 initial_condition.f08 sourcefile~initial_condition.f08->sourcefile~utility.f08 sourcefile~initial_condition.f08->sourcefile~junction.f08 sourcefile~initial_condition.f08->sourcefile~element_geometry.f08 sourcefile~initial_condition.f08->sourcefile~element_dynamics.f08 sourcefile~initial_condition.f08->sourcefile~face_values.f08 sourcefile~initial_condition.f08->sourcefile~bc.f08 sourcefile~test_cases.f08 test_cases.f08 sourcefile~test_cases.f08->sourcefile~utility.f08 sourcefile~test_cases.f08->sourcefile~bc.f08 sourcefile~case_simple_channel.f08 case_simple_channel.f08 sourcefile~test_cases.f08->sourcefile~case_simple_channel.f08 sourcefile~case_y_channel.f08 case_y_channel.f08 sourcefile~test_cases.f08->sourcefile~case_y_channel.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~explicit_euler.f08->sourcefile~utility.f08 sourcefile~explicit_euler.f08->sourcefile~element_geometry.f08 sourcefile~explicit_euler.f08->sourcefile~element_dynamics.f08 sourcefile~explicit_euler.f08->sourcefile~face_values.f08 sourcefile~explicit_euler.f08->sourcefile~bc.f08 sourcefile~explicit_euler.f08->sourcefile~adjustments.f08 sourcefile~output.f08 output.f08 sourcefile~output.f08->sourcefile~utility.f08 sourcefile~output.f08->sourcefile~bc.f08 sourcefile~adjustments.f08->sourcefile~utility.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~utility.f08 sourcefile~main.f08->sourcefile~debug.f08 sourcefile~main.f08->sourcefile~junction.f08 sourcefile~main.f08->sourcefile~allocate_storage.f08 sourcefile~main.f08->sourcefile~diagnostic.f08 sourcefile~main.f08->sourcefile~initial_condition.f08 sourcefile~main.f08->sourcefile~test_cases.f08 sourcefile~main.f08->sourcefile~bc.f08 sourcefile~main.f08->sourcefile~output.f08 sourcefile~network_define.f08 network_define.f08 sourcefile~main.f08->sourcefile~network_define.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~main.f08->sourcefile~time_loop.f08 sourcefile~case_simple_channel.f08->sourcefile~allocate_storage.f08 sourcefile~case_simple_channel.f08->sourcefile~bc.f08 sourcefile~case_y_channel.f08->sourcefile~allocate_storage.f08 sourcefile~case_y_channel.f08->sourcefile~bc.f08 sourcefile~network_define.f08->sourcefile~junction.f08 sourcefile~network_define.f08->sourcefile~allocate_storage.f08 sourcefile~time_loop.f08->sourcefile~debug.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~time_loop.f08->sourcefile~face_values.f08 sourcefile~time_loop.f08->sourcefile~diagnostic.f08 sourcefile~time_loop.f08->sourcefile~bc.f08 sourcefile~time_loop.f08->sourcefile~explicit_euler.f08 sourcefile~time_loop.f08->sourcefile~output.f08 var pansourcefileutilityf08AfferentGraph = svgPanZoom('#sourcefileutilityf08AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules utility Source Code utility.f08 Source Code ! module utility ! ! utility routines that may be called in a number of places ! !========================================================================== ! module utility use array_index use data_keys use setting_definition use globals implicit none private public :: utility_advance_temp_array public :: utility_average public :: utility_check_allocation public :: utility_check_fileopen public :: utility_linear_interpolate_within_indexlist public :: utility_get_datetime_stamp public :: utility_print_values_by_link public :: utility_round_to_significant_digits public :: utility_scale_of_number public :: utility_sign_with_ones integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine utility_print_values_by_link & ( elem2R , elem2I , elemMR , elemMI , faceR , faceI , ilink , & fcolDn , fcolUp , e2col , eMcolC , eMcolDn , eMcolUp ) ! ! provides a printout of data along a link. ! fcolDn, fcolUp are (for example) fr_Area_d and fr_Area_u. If only ! one value (e.g. fr_Flowrate) then use for fcolDn and use 0 for fcolUp ! e2col is (for example) e2r_Area. ! eMcolC is (for example) eMr_Area. ! eMcolDn and eMcolUp are (for example) eMr_AreaUp and eMr_AreaDn. ! if eM up/dn do not exist (e.g. for eMr_Eta) then store a dummyarray of 0. ! note that the input dummy array must be an array rather than a scalar. ! character ( 64 ) :: subroutine_name = 'utility_print_values_by_link' real , intent ( in ) :: elem2R (:,:), elemMR (:,:), faceR (:,:) integer , intent ( in ) :: elem2I (:,:), elemMI (:,:), faceI (:,:) integer , intent ( in ) :: ilink , fcolDn , fcolUp , e2col , eMcolC , eMcolDn (:), eMcolUp (:) integer :: eStart , eEnd , ii , fd , fu , eb , eu , ed , edtype , eutype !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name eStart = minloc ( elem2I (:, e2i_link_Pos ), 1 ,( ( elem2I (:, e2i_link_ID ) == ilink ) . and . ( elem2I (:, e2i_link_Pos ) /= nullvalueI ) ) ) eEnd = maxloc ( elem2I (:, e2i_link_Pos ), 1 ,( ( elem2I (:, e2i_link_ID ) == ilink ) . and . ( elem2I (:, e2i_link_Pos ) /= nullvalueI ) ) ) print * , ilink , '=link' !% info about the element downstream of the link fd = elem2I ( eStart , e2i_Mface_d ) edtype = faceI ( fd , fi_etype_d ) print * , edtype , '=type of downstream element' if ( edtype == eJunctionChannel ) then ed = faceI ( fd , fi_Melem_d ) eb = faceI ( fd , fi_branch_d ) if ( eMcolC /= 0 ) then print * , elemMR ( ed , eMcolC ), '= elemM C ' , ed endif if ( eMcolUp ( 1 ) /= 0 ) then print * , elemMR ( ed , eMcolUp ( eb )), '= branch up,' , eb endif endif !% print information about faces and elements of the link do ii = eStart , eEnd fd = elem2I ( ii , e2i_Mface_d ) print * , faceR ( fd , fcolDn ), '= faceDn ' , fd if ( fcolUp /= 0 ) then print * , faceR ( fd , fcolUp ), '= faceUp ' , fd endif print * , elem2R ( ii , e2col ), '= elem   ' , ii end do !% print info on the last upstream face fu = elem2I ( eEnd , e2i_Mface_u ) print * , faceR ( fu , fcolDn ), '= faceDn ' , fu if ( fcolUp /= 0 ) then print * , faceR ( fu , fcolUp ), '= faceUp ' , fu endif !% print info of the next element upstream eutype = faceI ( fu , fi_etype_u ) print * , eutype , '=type of upstream element' if ( eutype == eJunctionChannel ) then eu = faceI ( fu , fi_Melem_u ) eb = faceI ( fu , fi_branch_u ) if ( eMcolDn ( 1 ) /= 0 ) then print * , elemMR ( eu , eMcolDn ( eb )), '= branch dn,' , eb endif if ( eMcolC /= 0 ) then print * , elemMR ( eu , eMcolC ), '= elemM C ' , eu endif endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine utility_print_values_by_link ! !========================================================================== !========================================================================== ! integer function utility_advance_temp_array ( next_temparray , temparraysize ) ! ! Advances a temp_array counter and checks to see if the array size is ! adequate. These arrays are columns of the 2D data structure that can be ! overwritten in any subroutine. ! ! The temp_array (e.g. e2i_Temp) have sizes that are hard-coded in the ! array_index module and then are initialized in the initialization module. ! Care must be taken when increasing the temp_array index sizes for consistency. ! integer , intent ( in ) :: next_temparray , temparraysize character ( 64 ) :: subroutine_name = 'utility_advance_temp_array' !-------------------------------------------------------------------------- if ( next_temparray > temparraysize ) then print * , 'code error: temparray is too small in ' , subroutine_name stop endif utility_advance_temp_array = next_temparray + 1 end function utility_advance_temp_array ! !========================================================================== !========================================================================== ! pure real function utility_average & ( inarray ) result ( outscalar ) ! ! computes a simple average of an array ! real , intent ( in ) :: inarray (:) !-------------------------------------------------------------------------- if ( size ( inarray ) > 0 ) then outscalar = sum ( inarray ) / real ( size ( inarray )) endif end function utility_average ! !========================================================================== !========================================================================== ! subroutine utility_check_fileopen & ( open_status , emsg ) ! ! Checks to see if a file is already open. Stops as an error if file is open. ! character ( 64 ) :: subroutine_name = 'utility_check_fileopen' integer , intent ( in ) :: open_status character ( len =* ), intent ( in ) :: emsg !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if ( open_status > 0 ) then print * , trim ( emsg ) STOP endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine utility_check_fileopen ! !========================================================================== !========================================================================== ! subroutine utility_check_allocation & ( allocation_status , emsg ) ! ! checks allocation status and stops if there is an error ! character ( 64 ) :: subroutine_name = 'utility_check_allocation' integer , intent ( in ) :: allocation_status character ( len =* ), intent ( in ) :: emsg !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if ( allocation_status > 0 ) then print * , trim ( emsg ) STOP endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine utility_check_allocation ! !========================================================================== !========================================================================== ! function utility_linear_interpolate_within_indexlist & ( thisIndex , IndexArray , ValueArray ) result ( thisValue ) ! ! IndexArray are ordered, non-repeating real numbers ! ValueArray are non-ordered values corresponding to IndexArray ! thisIndex is an index value within limits of IndexArray ! thisValue is a linearly-interpolated value ! ! This function is used in boundary condition interpolation, but is more ! general and can be used elsewhere ! character ( 64 ) :: subroutine_name = 'utility_linear_interpolate_within_indexlist' real , intent ( in ) :: IndexArray (:), ValueArray (:) real , intent ( in ) :: thisIndex real :: thisValue integer :: closeloc !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name closeloc = minloc ( abs ( thisIndex - IndexArray ), 1 ) !% get the value if the location is exactly on an index if ( thisIndex - IndexArray ( closeloc ) == 0 ) then thisValue = ValueArray ( closeloc ) !% if the close location index is below the target elseif (( thisIndex - IndexArray ( closeloc ) > 0 ) . and . & ( closeloc < size ( IndexArray , 1 )) ) then thisValue = ( ValueArray ( closeloc ) * ( IndexArray ( closeloc + 1 ) - thisIndex ) & + ValueArray ( closeloc + 1 ) * ( thisIndex - IndexArray ( closeloc ) ) ) & / ( IndexArray ( closeloc + 1 ) - IndexArray ( closeloc ) ) !% if the close location is above the target elseif (( thisIndex - IndexArray ( closeloc ) < 0 ) . and . & ( closeloc > 1 ) ) then thisValue = ( ValueArray ( closeloc ) * ( IndexArray ( closeloc ) - thisIndex ) & + ValueArray ( closeloc - 1 ) * ( thisIndex - IndexArray ( closeloc - 1 ) ) ) & / ( IndexArray ( closeloc ) - IndexArray ( closeloc - 1 ) ) else !% error condition - the index appears to be outside of the index array print * , 'error: interpolation index (thisIndex) is outside the array bounds (IndexArray) in ' , subroutine_name stop endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end function utility_linear_interpolate_within_indexlist ! !========================================================================== !========================================================================== ! subroutine utility_get_datetime_stamp & ( datetimestamp ) ! !   Gets a character(14) datetimestamp in the form _yyyymmdd_hhmm . !   Note the leading _ is used so this is convenient for adding to filenames. ! character ( 64 ) :: subroutine_name = 'utility_get_datetime_stamp' character ( 14 ), intent ( out ) :: datetimestamp ! in form _yyyymmdd_hhmm character ( 8 ) :: thisdate character ( 10 ) :: thistime character ( 5 ) :: thiszone character ( 4 ) :: cyear character ( 2 ) :: cmonth character ( 2 ) :: cday character ( 2 ) :: chour character ( 2 ) :: cmin integer :: thisvalues ( 8 ) integer :: tyear , tmonth , tday , thour , tmin !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name call date_and_time ( thisdate , thistime , thiszone , thisvalues ) tyear = thisvalues ( 1 ) tmonth = thisvalues ( 2 ) tday = thisvalues ( 3 ) thour = thisvalues ( 5 ) tmin = thisvalues ( 6 ) write ( cyear , \"(i4)\" ) tyear if ( tmonth >= 10 ) then write ( cmonth , \"(i2)\" ) tmonth else write ( cmonth , \"(i1,i1)\" ) 0 , tmonth end if if ( tday >= 10 ) then write ( cday , \"(i2)\" ) tday else write ( cday , \"(i1,i1)\" ) 0 , tday end if if ( thour >= 10 ) then write ( chour , \"(i2)\" ) thour else write ( chour , \"(i1,i1)\" ) 0 , thour end if if ( tmin >= 10 ) then write ( cmin , \"(i2)\" ) tmin else write ( cmin , \"(i1,i1)\" ) 0 , tmin end if write ( datetimestamp , \"('_',a4,a2,a2,'_',a2,a2)\" ) & cyear , cmonth , cday , & chour , cmin if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine utility_get_datetime_stamp ! !========================================================================== !========================================================================== ! pure elemental real function utility_round_to_significant_digits & ( inarray , idigits ) result ( outarray ) ! ! returns the exponent scale of the largest n where 10&#94;n < number ! real , intent ( in ) :: inarray integer , intent ( in ) :: idigits integer :: inscale !-------------------------------------------------------------------------- inscale = utility_scale_of_number ( inarray ) outarray = real ( NINT ( inarray / ( tenR ** ( inscale - ( idigits - 1 ))))) & * tenR ** real ( inscale - ( idigits - 1 )) end function utility_round_to_significant_digits ! !========================================================================== !========================================================================== ! pure elemental integer function utility_scale_of_number & ( inarray ) result ( outarray ) ! ! returns the exponent scale of the largest n where 10&#94;n < number ! real , intent ( in ) :: inarray !-------------------------------------------------------------------------- outarray = floor ( log10 ( abs ( inarray ))) end function utility_scale_of_number ! !========================================================================== !========================================================================== ! pure elemental real function utility_sign_with_ones & ( inarray ) result ( outarray ) ! ! returns is an array of real ones with the sign of the inarray argument ! real , intent ( in ) :: inarray !-------------------------------------------------------------------------- outarray = oneR outarray = sign ( outarray , inarray ) end function utility_sign_with_ones ! !========================================================================== ! END OF MODULE utility !========================================================================== end module utility","title":"utility.f08 – SWMMengine","tags":"","loc":"sourcefile/utility.f08.html"},{"text":"This file depends on sourcefile~~main.f08~~EfferentGraph sourcefile~main.f08 main.f08 sourcefile~debug.f08 debug.f08 sourcefile~main.f08->sourcefile~debug.f08 sourcefile~junction.f08 junction.f08 sourcefile~main.f08->sourcefile~junction.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~main.f08->sourcefile~type_definitions.f08 sourcefile~globals.f08 globals.f08 sourcefile~main.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~main.f08->sourcefile~setting_definition.f08 sourcefile~allocate_storage.f08 allocate_storage.f08 sourcefile~main.f08->sourcefile~allocate_storage.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~main.f08->sourcefile~array_index.f08 sourcefile~checking.f08 checking.f08 sourcefile~main.f08->sourcefile~checking.f08 sourcefile~diagnostic.f08 diagnostic.f08 sourcefile~main.f08->sourcefile~diagnostic.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~main.f08->sourcefile~time_loop.f08 sourcefile~network_define.f08 network_define.f08 sourcefile~main.f08->sourcefile~network_define.f08 sourcefile~initial_condition.f08 initial_condition.f08 sourcefile~main.f08->sourcefile~initial_condition.f08 sourcefile~test_cases.f08 test_cases.f08 sourcefile~main.f08->sourcefile~test_cases.f08 sourcefile~bc.f08 bc.f08 sourcefile~main.f08->sourcefile~bc.f08 sourcefile~initialization.f08 initialization.f08 sourcefile~main.f08->sourcefile~initialization.f08 sourcefile~output.f08 output.f08 sourcefile~main.f08->sourcefile~output.f08 sourcefile~utility.f08 utility.f08 sourcefile~main.f08->sourcefile~utility.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~main.f08->sourcefile~data_keys.f08 sourcefile~debug.f08->sourcefile~type_definitions.f08 sourcefile~debug.f08->sourcefile~globals.f08 sourcefile~debug.f08->sourcefile~setting_definition.f08 sourcefile~debug.f08->sourcefile~array_index.f08 sourcefile~debug.f08->sourcefile~bc.f08 sourcefile~debug.f08->sourcefile~utility.f08 sourcefile~debug.f08->sourcefile~data_keys.f08 sourcefile~junction.f08->sourcefile~globals.f08 sourcefile~junction.f08->sourcefile~setting_definition.f08 sourcefile~junction.f08->sourcefile~array_index.f08 sourcefile~junction.f08->sourcefile~utility.f08 sourcefile~junction.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~allocate_storage.f08->sourcefile~globals.f08 sourcefile~allocate_storage.f08->sourcefile~array_index.f08 sourcefile~allocate_storage.f08->sourcefile~utility.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~checking.f08->sourcefile~globals.f08 sourcefile~checking.f08->sourcefile~array_index.f08 sourcefile~checking.f08->sourcefile~data_keys.f08 sourcefile~diagnostic.f08->sourcefile~type_definitions.f08 sourcefile~diagnostic.f08->sourcefile~globals.f08 sourcefile~diagnostic.f08->sourcefile~setting_definition.f08 sourcefile~diagnostic.f08->sourcefile~array_index.f08 sourcefile~diagnostic.f08->sourcefile~bc.f08 sourcefile~diagnostic.f08->sourcefile~utility.f08 sourcefile~diagnostic.f08->sourcefile~data_keys.f08 sourcefile~time_loop.f08->sourcefile~debug.f08 sourcefile~time_loop.f08->sourcefile~globals.f08 sourcefile~time_loop.f08->sourcefile~setting_definition.f08 sourcefile~time_loop.f08->sourcefile~array_index.f08 sourcefile~time_loop.f08->sourcefile~diagnostic.f08 sourcefile~time_loop.f08->sourcefile~bc.f08 sourcefile~time_loop.f08->sourcefile~output.f08 sourcefile~time_loop.f08->sourcefile~data_keys.f08 sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~face_values.f08 face_values.f08 sourcefile~time_loop.f08->sourcefile~face_values.f08 sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~time_loop.f08->sourcefile~explicit_euler.f08 sourcefile~network_define.f08->sourcefile~junction.f08 sourcefile~network_define.f08->sourcefile~globals.f08 sourcefile~network_define.f08->sourcefile~allocate_storage.f08 sourcefile~network_define.f08->sourcefile~array_index.f08 sourcefile~network_define.f08->sourcefile~initialization.f08 sourcefile~network_define.f08->sourcefile~data_keys.f08 sourcefile~initial_condition.f08->sourcefile~junction.f08 sourcefile~initial_condition.f08->sourcefile~globals.f08 sourcefile~initial_condition.f08->sourcefile~setting_definition.f08 sourcefile~initial_condition.f08->sourcefile~array_index.f08 sourcefile~initial_condition.f08->sourcefile~bc.f08 sourcefile~initial_condition.f08->sourcefile~utility.f08 sourcefile~initial_condition.f08->sourcefile~data_keys.f08 sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~initial_condition.f08->sourcefile~element_geometry.f08 sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~initial_condition.f08->sourcefile~element_dynamics.f08 sourcefile~initial_condition.f08->sourcefile~face_values.f08 sourcefile~test_cases.f08->sourcefile~globals.f08 sourcefile~test_cases.f08->sourcefile~setting_definition.f08 sourcefile~test_cases.f08->sourcefile~array_index.f08 sourcefile~test_cases.f08->sourcefile~bc.f08 sourcefile~test_cases.f08->sourcefile~utility.f08 sourcefile~test_cases.f08->sourcefile~data_keys.f08 sourcefile~case_y_channel.f08 case_y_channel.f08 sourcefile~test_cases.f08->sourcefile~case_y_channel.f08 sourcefile~case_simple_channel.f08 case_simple_channel.f08 sourcefile~test_cases.f08->sourcefile~case_simple_channel.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~initialization.f08->sourcefile~globals.f08 sourcefile~initialization.f08->sourcefile~array_index.f08 sourcefile~initialization.f08->sourcefile~data_keys.f08 sourcefile~output.f08->sourcefile~globals.f08 sourcefile~output.f08->sourcefile~setting_definition.f08 sourcefile~output.f08->sourcefile~array_index.f08 sourcefile~output.f08->sourcefile~bc.f08 sourcefile~output.f08->sourcefile~utility.f08 sourcefile~output.f08->sourcefile~data_keys.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~runge_kutta.f08->sourcefile~globals.f08 sourcefile~runge_kutta.f08->sourcefile~setting_definition.f08 sourcefile~runge_kutta.f08->sourcefile~array_index.f08 sourcefile~runge_kutta.f08->sourcefile~diagnostic.f08 sourcefile~runge_kutta.f08->sourcefile~bc.f08 sourcefile~runge_kutta.f08->sourcefile~utility.f08 sourcefile~runge_kutta.f08->sourcefile~data_keys.f08 sourcefile~runge_kutta.f08->sourcefile~element_geometry.f08 sourcefile~runge_kutta.f08->sourcefile~element_dynamics.f08 sourcefile~runge_kutta.f08->sourcefile~face_values.f08 sourcefile~adjustments.f08 adjustments.f08 sourcefile~runge_kutta.f08->sourcefile~adjustments.f08 sourcefile~case_y_channel.f08->sourcefile~globals.f08 sourcefile~case_y_channel.f08->sourcefile~setting_definition.f08 sourcefile~case_y_channel.f08->sourcefile~allocate_storage.f08 sourcefile~case_y_channel.f08->sourcefile~array_index.f08 sourcefile~case_y_channel.f08->sourcefile~bc.f08 sourcefile~case_y_channel.f08->sourcefile~data_keys.f08 sourcefile~element_geometry.f08->sourcefile~junction.f08 sourcefile~element_geometry.f08->sourcefile~globals.f08 sourcefile~element_geometry.f08->sourcefile~setting_definition.f08 sourcefile~element_geometry.f08->sourcefile~array_index.f08 sourcefile~element_geometry.f08->sourcefile~bc.f08 sourcefile~element_geometry.f08->sourcefile~utility.f08 sourcefile~element_geometry.f08->sourcefile~data_keys.f08 sourcefile~element_geometry.f08->sourcefile~adjustments.f08 sourcefile~element_dynamics.f08->sourcefile~junction.f08 sourcefile~element_dynamics.f08->sourcefile~globals.f08 sourcefile~element_dynamics.f08->sourcefile~setting_definition.f08 sourcefile~element_dynamics.f08->sourcefile~array_index.f08 sourcefile~element_dynamics.f08->sourcefile~bc.f08 sourcefile~element_dynamics.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08->sourcefile~data_keys.f08 sourcefile~element_dynamics.f08->sourcefile~adjustments.f08 sourcefile~face_values.f08->sourcefile~globals.f08 sourcefile~face_values.f08->sourcefile~setting_definition.f08 sourcefile~face_values.f08->sourcefile~array_index.f08 sourcefile~face_values.f08->sourcefile~bc.f08 sourcefile~face_values.f08->sourcefile~utility.f08 sourcefile~face_values.f08->sourcefile~data_keys.f08 sourcefile~face_values.f08->sourcefile~adjustments.f08 sourcefile~case_simple_channel.f08->sourcefile~globals.f08 sourcefile~case_simple_channel.f08->sourcefile~setting_definition.f08 sourcefile~case_simple_channel.f08->sourcefile~allocate_storage.f08 sourcefile~case_simple_channel.f08->sourcefile~array_index.f08 sourcefile~case_simple_channel.f08->sourcefile~bc.f08 sourcefile~case_simple_channel.f08->sourcefile~data_keys.f08 sourcefile~explicit_euler.f08->sourcefile~globals.f08 sourcefile~explicit_euler.f08->sourcefile~setting_definition.f08 sourcefile~explicit_euler.f08->sourcefile~array_index.f08 sourcefile~explicit_euler.f08->sourcefile~bc.f08 sourcefile~explicit_euler.f08->sourcefile~utility.f08 sourcefile~explicit_euler.f08->sourcefile~data_keys.f08 sourcefile~explicit_euler.f08->sourcefile~element_geometry.f08 sourcefile~explicit_euler.f08->sourcefile~element_dynamics.f08 sourcefile~explicit_euler.f08->sourcefile~face_values.f08 sourcefile~explicit_euler.f08->sourcefile~adjustments.f08 sourcefile~adjustments.f08->sourcefile~globals.f08 sourcefile~adjustments.f08->sourcefile~setting_definition.f08 sourcefile~adjustments.f08->sourcefile~array_index.f08 sourcefile~adjustments.f08->sourcefile~utility.f08 sourcefile~adjustments.f08->sourcefile~data_keys.f08 var pansourcefilemainf08EfferentGraph = svgPanZoom('#sourcefilemainf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs main Source Code main.f08 Source Code !========================================================================== ! program main use allocate_storage use array_index use bc use checking use data_keys use debug use diagnostic use globals use initialization use initial_condition use junction use network_define use output use setting_definition use type_definitions use test_cases use time_loop use utility implicit none !%  elem2# are the values for elements that have only 2 faces real , dimension (:,:), allocatable , target :: elem2R ! real data for elements with 2 faces integer , dimension (:,:), allocatable , target :: elem2I ! integer data for elements with 2 faces logical , dimension (:,:), allocatable , target :: elem2YN ! logical data for elements with 2 faces type ( string ), dimension (:), allocatable , target :: elem2Name ! array of character strings !%  elemM# are the values for elements that have more than 2 faces real , dimension (:,:), allocatable , target :: elemMR ! real data for elements with multi faces integer , dimension (:,:), allocatable , target :: elemMI ! integer data for elements with multi faces logical , dimension (:,:), allocatable , target :: elemMYN ! logical data for elements with multi faces type ( string ), dimension (:), allocatable , target :: elemMName ! array of character strings !%  face# are the values for faces (always bounded by 2 elements) real , dimension (:,:), allocatable , target :: faceR ! real data for faces integer , dimension (:,:), allocatable , target :: faceI ! integer data for faces logical , dimension (:,:), allocatable , target :: faceYN ! logical data for face type ( string ), dimension (:), allocatable , target :: faceName ! array of character strings !%  links are the building blocks from SWMM link-node formulation real , dimension (:,:), allocatable , target :: linkR ! real data for links integer , dimension (:,:), allocatable , target :: linkI ! integer data for links logical , dimension (:,:), allocatable , target :: linkYN ! logical data for links type ( string ), dimension (:), allocatable , target :: linkName ! array of character strings !%  nodes are the building blocks from teh SWMM link-node formulation real , dimension (:,:), allocatable , target :: nodeR ! real data for nodes integer , dimension (:,:), allocatable , target :: nodeI ! integer data for nodes logical , dimension (:,:), allocatable , target :: nodeYN ! logical data for nodes type ( string ), dimension (:), allocatable , target :: nodeName ! array of character strings !%  bcdata are structures containing boundary condition data type ( bcType ), dimension (:), allocatable :: bcdataUp , bcdataDn !%  debug output file information type ( debugfileType ), dimension (:), allocatable :: debugfile !%  diagnostic information type ( diagnosticType ), allocatable , dimension (:) :: diagnostic !% threaded output files type ( threadedfileType ), allocatable , dimension (:) :: threadedfile !-------------------------------------------------------------------------- print * print * , '=====================================================' print * , 'starting main program' print * , !%  simulation controls call setting_default !=========================================================== !%  hard-code setting for test cases setting % TestCase % UseTestCase = . true . !setting%TestCase%TestName = 'simple_channel_001' setting % TestCase % TestName = 'y_channel_002' !%  hard-code for debug output setting % Debugout % SuppressAllFiles = . true . ! use this to easily suppress debug files setting % Debugout % SuppressTimeStep = . true . ! use the next 3 to suppress headers setting % Debugout % SuppressTimeValue = . true . ! which can make debug files easier setting % Debugout % SuppressNdat = . true . ! to read (but less useful) setting % Debugout % elem2R = . true . ! select arrays to have debug output setting % Debugout % elemMR = . true . ! select arrays to have debug output setting % Debugout % faceR = . true . ! note that not all are implemented !setting%OutputThreadedLink%SuppressAllFiles = .true. setting % OutputThreadedLink % UseThisOutput = . true . setting % OutputThreadedLink % area = . true . setting % OutputThreadedLink % flowrate = . true . setting % OutputThreadedLink % velocity = . true . setting % OutputThreadedLink % eta = . true . setting % OutputThreadedLink % depth = . true . !!=========================================================== !% bookkeeping routines call utility_get_datetime_stamp ( setting % Time % DateTimeStamp ) call debug_initialize ( debugfile ) call checking_consistency call initialize_arrayindex !% custom setup for hard-code test cases if ( setting % TestCase % UseTestCase ) then call test_case_initiation & ( linkR , nodeR , linkI , nodeI , linkYN , nodeYN , linkName , nodeName , & bcdataDn , bcdataUp ) else print * , 'error - code only designed for use with test cases' stop end if !% create the network of elements from link and node data call network_initiation & ( linkI , linkR , linkYN , linkName , & nodeI , nodeR , nodeYN , nodeName , & elem2R , elem2I , elem2YN , elem2Name , & elemMR , elemMI , elemMYN , elemMName , & faceR , faceI , faceYN , faceName ) !print *, 'in main' !stop !% check the boundary condition data arrays are correctly defined call bc_checks ( bcdataUp , bcdataDn , elem2I , faceI , nodeI ) !% set the initial conditions throughout call initial_condition_setup & ( elem2R , elem2I , elem2YN , elemMR , elemMI , elemMYN , faceR , faceI , faceYN , & linkR , linkI , nodeR , nodeI , bcdataDn , bcdataUp , setting % Time % StartTime ) !% check consistency of the smallvolume setup call checking_smallvolume_consistency ( elem2R , elemMR ) ! initialize the diagnostics call diagnostic_initialize & ( diagnostic , elem2R , elem2I , elemMR , elemMI , faceR , & bcdataUp , bcdataDn ) !% setting a zero starting condition is useful for robustness tests print * , 'in main setting flowrate and velocity to 0' elem2R (:, e2r_Velocity ) = 0.0 elem2R (:, e2r_Flowrate ) = 0.0 elemMR (:, eMr_Velocity ) = 0.0 elemMR (:, eMr_Flowrate ) = 0.0 elemMR (:, eMr_FlowrateUp (:)) = 0.0 elemMR (:, eMr_FlowrateDn (:)) = 0.0 elemMR (:, eMr_VelocityDn (:)) = 0.0 elemMR (:, eMr_VelocityUp (:)) = 0.0 faceR ( 1 : size ( faceR , 1 ) - 1 , fr_Velocity_d ) = 0.0 faceR ( 1 : size ( faceR , 1 ) - 1 , fr_Velocity_u ) = 0.0 faceR ( 1 : size ( faceR , 1 ) - 1 , fr_Flowrate ) = 0.0 ! initialize output by threaded link call output_threaded_by_link_initialize ( threadedfile ) !%  time marching of continuity and momentum call time_marching & ( elem2R , elemMR , faceR , elem2I , elemMI , faceI , elem2YN , elemMYN , faceYN , & bcdataDn , bcdataUp , linkI , debugfile , diagnostic , threadedfile ) !% uncomment this if you want a final debug output ! call debug_output & !    (debugfile, & !     elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, faceI, faceYN, & !     bcdataUp, bcdataDn) ! !========================================================= ! FINAL CHECKING ! !%  check that index arrays were not altered during execution call initialize_arrayindex_status !%  close out the debug files call debug_finalize ( debugfile ) print * print * , 'finished main program' print * , '=====================' print * , char ( 7 ) ! sound the system beep end program main !==========================================================================","title":"main.f08 – SWMMengine","tags":"","loc":"sourcefile/main.f08.html"},{"text":"This file depends on sourcefile~~case_y_channel.f08~~EfferentGraph sourcefile~case_y_channel.f08 case_y_channel.f08 sourcefile~globals.f08 globals.f08 sourcefile~case_y_channel.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~case_y_channel.f08->sourcefile~setting_definition.f08 sourcefile~allocate_storage.f08 allocate_storage.f08 sourcefile~case_y_channel.f08->sourcefile~allocate_storage.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~case_y_channel.f08->sourcefile~array_index.f08 sourcefile~bc.f08 bc.f08 sourcefile~case_y_channel.f08->sourcefile~bc.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~case_y_channel.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~allocate_storage.f08->sourcefile~globals.f08 sourcefile~allocate_storage.f08->sourcefile~array_index.f08 sourcefile~utility.f08 utility.f08 sourcefile~allocate_storage.f08->sourcefile~utility.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 var pansourcefilecase_y_channelf08EfferentGraph = svgPanZoom('#sourcefilecase_y_channelf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~case_y_channel.f08~~AfferentGraph sourcefile~case_y_channel.f08 case_y_channel.f08 sourcefile~test_cases.f08 test_cases.f08 sourcefile~test_cases.f08->sourcefile~case_y_channel.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~test_cases.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules case_y_channel Source Code case_y_channel.f08 Source Code ! module case_y_channel ! ! Custom setup for 3 links and 4 nodes arranged in a Y ! !========================================================================== ! module case_y_channel ! use allocate_storage use array_index use bc use data_keys use globals use setting_definition implicit none private public :: case_y_channel_initialize integer :: debuglevel = 1 contains ! !========================================================================== !========================================================================== ! subroutine case_y_channel_initialize & ( channel_length , channel_breadth , subdivide_length , lowerZ , upperZ , & initial_flowrate , depth_upstream , depth_dnstream , & ManningsN , roughness_type , idepth_type , & linkR , nodeR , linkI , nodeI , linkYN , nodeYN , linkName , nodeName , & bcdataDn , bcdataUp ) character ( 64 ) :: subroutine_name = 'case_y_channel_initialize' real , intent ( in ) :: channel_length (:), channel_breadth (:), subdivide_length (:) real , intent ( in ) :: lowerZ (:), upperZ (:), initial_flowrate (:) real , intent ( in ) :: depth_upstream (:), depth_dnstream (:) real , intent ( in ) :: ManningsN (:) integer , intent ( in ) :: roughness_type , idepth_type (:) integer , dimension (:,:), allocatable , target , intent ( out ) :: linkI integer , dimension (:,:), allocatable , target , intent ( out ) :: nodeI real , dimension (:,:), allocatable , target , intent ( out ) :: linkR real , dimension (:,:), allocatable , target , intent ( out ) :: nodeR logical , dimension (:,:), allocatable , target , intent ( out ) :: linkYN logical , dimension (:,:), allocatable , target , intent ( out ) :: nodeYN type ( string ), dimension (:), allocatable , target , intent ( out ) :: linkName type ( string ), dimension (:), allocatable , target , intent ( out ) :: nodeName type ( bcType ), dimension (:), allocatable , intent ( out ) :: bcdataUp , bcdataDn integer :: ntimepoint , ndnstreamBC , nupstreamBC !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name ntimepoint = 2 nupstreamBC = 2 ndnstreamBC = 1 ! check if call bc_allocate & ( bcdataDn , bcdataUp , ndnstreamBC , nupstreamBC , ntimepoint ) ! assign values ! downstream is default to elevation bcdataDn ( 1 )% NodeID = 1 bcdataDn ( 1 )% TimeArray ( 1 ) = setting % Time % StartTime bcdataDn ( 1 )% TimeArray ( 2 ) = setting % Time % EndTime + 10 0.0 !s bcdataDn ( 1 )% ValueArray ( 1 ) = lowerZ ( 1 ) + depth_dnstream ( 1 ) ! m bcdataDn ( 1 )% ValueArray ( 2 ) = lowerZ ( 1 ) + depth_dnstream ( 1 ) ! m ! upstream is default to flowrate bcdataUp ( 1 )% NodeID = 3 bcdataUp ( 1 )% TimeArray ( 1 ) = setting % Time % StartTime bcdataUp ( 1 )% TimeArray ( 2 ) = setting % Time % EndTime + 10 0.0 !s bcdataUp ( 1 )% ValueArray ( 1 ) = initial_flowrate ( 1 ) ! m&#94;3/s bcdataUp ( 1 )% ValueArray ( 2 ) = initial_flowrate ( 1 ) ! m&#94;3/2 bcdataUp ( 2 )% NodeID = 4 bcdataUp ( 2 )% TimeArray ( 1 ) = setting % Time % StartTime bcdataUp ( 2 )% TimeArray ( 2 ) = setting % Time % EndTime + 10 0.0 !s bcdataUp ( 2 )% ValueArray ( 1 ) = initial_flowrate ( 2 ) ! m&#94;3/s bcdataUp ( 2 )% ValueArray ( 2 ) = initial_flowrate ( 2 ) ! m&#94;3/2 call case_y_channel_links_and_nodes & ( channel_length , channel_breadth , subdivide_length , lowerZ , upperZ , & initial_flowrate , depth_upstream , depth_dnstream , ManningsN , & roughness_type , idepth_type , & linkR , nodeR , linkI , nodeI , linkYN , nodeYN , linkName , nodeName ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine case_y_channel_initialize ! !========================================================================== ! ! PRIVATE BELOW HERE ! !========================================================================== ! subroutine case_y_channel_links_and_nodes & ( channel_length , channel_breadth , subdivide_length , lowerZ , upperZ , & initial_flowrate , depth_upstream , depth_dnstream , ManningsN , & roughness_type , idepth_type , & linkR , nodeR , linkI , nodeI , linkYN , nodeYN , linkName , nodeName ) ! ! creates a simple rectangular channel with 1 link and 2 nodes ! character ( 64 ) :: subroutine_name = 'case_simple_channel_links_and_nodes' real , intent ( in ) :: channel_length (:), channel_breadth (:), subdivide_length (:) real , intent ( in ) :: lowerZ (:), upperZ (:), ManningsN (:), initial_flowrate (:) real , intent ( in ) :: depth_upstream (:), depth_dnstream (:) integer , intent ( in ) :: roughness_type , idepth_type (:) integer , dimension (:,:), allocatable , target , intent ( out ) :: linkI integer , dimension (:,:), allocatable , target , intent ( out ) :: nodeI real , dimension (:,:), allocatable , target , intent ( out ) :: linkR real , dimension (:,:), allocatable , target , intent ( out ) :: nodeR logical , dimension (:,:), allocatable , target , intent ( out ) :: linkYN logical , dimension (:,:), allocatable , target , intent ( out ) :: nodeYN type ( string ), dimension (:), allocatable , target , intent ( out ) :: linkName type ( string ), dimension (:), allocatable , target , intent ( out ) :: nodeName integer :: mm , ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name N_link = 3 N_node = 4 call allocate_linknode_storage & ( linkR , nodeR , linkI , nodeI , linkYN , nodeYN , linkName , nodeName ) ! assign the indexes linkI (:, li_idx ) = ( / ( ii , ii = 1 , N_link ) / ) nodeI (:, ni_idx ) = ( / ( ii , ii = 1 , N_node ) / ) ! assign names for links linkName ( 1 )% str = 'Channel_Downstream' linkName ( 2 )% str = 'Channel_Upstream_Right' linkName ( 3 )% str = 'Channel_Upstream_Left' ! assign zeros for accumulators nodeI (:, ni_N_link_d ) = 0 nodeI (:, ni_N_link_u ) = 0 ! assign uniform physical data linkI (:, li_roughness_type ) = roughness_type linkR (:, lr_Roughness ) = ManningsN ! designate the downstream node nodeI ( 1 , ni_node_type ) = nBCdn nodeR ( 1 , nr_Zbottom ) = lowerZ ( 1 ) nodeName ( 1 )% str = 'DownstreamBC' ! designate the junction node nodeI ( 2 , ni_node_type ) = nJm nodeR ( 2 , nr_Zbottom ) = upperZ ( 1 ) nodeName ( 2 )% str = 'Junction' ! designated the upstream nodes nodeI ( 3 , ni_node_type ) = nBCup nodeI ( 4 , ni_node_type ) = nBCup nodeR ( 3 , nr_Zbottom ) = upperZ ( 2 ) nodeR ( 4 , nr_Zbottom ) = upperZ ( 3 ) nodeName ( 3 )% str = 'UpstreamBC_Right' nodeName ( 4 )% str = 'UpstreamBC_Left' ! assign the link types linkI (:, li_link_type ) = lChannel ! assign all as rectangular channels linkI (:, li_geometry ) = lRectangular ! assign the link position and mappings linkI ( 1 , li_Mnode_d ) = 1 linkI ( 1 , li_Mnode_u ) = 2 linkI ( 2 , li_Mnode_d ) = 2 linkI ( 2 , li_Mnode_u ) = 3 linkI ( 3 , li_Mnode_d ) = 2 linkI ( 3 , li_Mnode_u ) = 4 do mm = 1 , N_link linkR ( mm , lr_Length ) = channel_length ( mm ) linkR ( mm , lr_BreadthScale ) = channel_breadth ( mm ) linkR ( mm , lr_ElementLength ) = subdivide_length ( mm ) linkR ( mm , lr_InitialFlowrate ) = initial_flowrate ( mm ) linkI ( mm , li_InitialDepthType ) = idepth_type ( mm ) enddo linkR (: , lr_InitialDnstreamDepth ) = depth_dnstream (:) linkR (: , lr_InitialUpstreamDepth ) = depth_upstream (:) !print *, initial_flowrate !print *,trim(subroutine_name) !stop if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) then print * print * , subroutine_name , '-----------------------------------' print * , 'link info' print * , linkI (:, li_idx ), ' idx' print * , linkI (:, li_link_type ), ' type' print * , linkI (:, li_Mnode_u ) , ' upstream node' print * , linkI (:, li_Mnode_d ) , ' downstream node' print * , print * , 'node info' print * , nodeI (:, ni_idx ), ' idx' print * , nodeI (:, ni_node_type ), ' type' !print *, nodeI(:,ni_N_link_d), 'number of downstream links' !print *, nodeI(:,ni_Mlink_d1), 'downstream1 link' !print *, nodeI(:,ni_N_link_u), 'number of upstream links' !print *, nodeI(:,ni_Mlink_u1), 'upstream1 link' endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine case_y_channel_links_and_nodes ! !========================================================================== ! END OF MODULE stub !========================================================================== end module case_y_channel","title":"case_y_channel.f08 – SWMMengine","tags":"","loc":"sourcefile/case_y_channel.f08.html"},{"text":"This file depends on sourcefile~~output.f08~~EfferentGraph sourcefile~output.f08 output.f08 sourcefile~globals.f08 globals.f08 sourcefile~output.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~output.f08->sourcefile~setting_definition.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~output.f08->sourcefile~array_index.f08 sourcefile~bc.f08 bc.f08 sourcefile~output.f08->sourcefile~bc.f08 sourcefile~utility.f08 utility.f08 sourcefile~output.f08->sourcefile~utility.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~output.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 var pansourcefileoutputf08EfferentGraph = svgPanZoom('#sourcefileoutputf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~output.f08~~AfferentGraph sourcefile~output.f08 output.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~time_loop.f08->sourcefile~output.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~output.f08 sourcefile~main.f08->sourcefile~time_loop.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules output Source Code output.f08 Source Code !========================================================================== ! module output ! use array_index use bc use data_keys use globals use setting_definition use utility implicit none private public :: output_threaded_by_link_initialize public :: output_all_threaded_data_by_link public :: output_one_threaded_data_by_link integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine output_threaded_by_link_initialize ( threadedfile ) character ( 64 ) :: subroutine_name = 'output_threaded_by_link_initialize' type ( threadedfileType ), dimension (:), allocatable , intent ( out ) :: threadedfile logical :: usethisdata ( 5 ) integer :: ii , mm , nfile integer :: allocation_status character ( len = 99 ) :: emsg !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if (. not . setting % OutputThreadedLink % UseThisOutput ) return if ( setting % OutputThreadedLink % SuppressAllFiles ) return usethisdata = . false . if ( setting % OutputThreadedLink % area ) usethisdata ( 1 ) = . true . if ( setting % OutputThreadedLink % flowrate ) usethisdata ( 2 ) = . true . if ( setting % OutputThreadedLink % velocity ) usethisdata ( 3 ) = . true . if ( setting % OutputThreadedLink % eta ) usethisdata ( 4 ) = . true . if ( setting % OutputThreadedLink % depth ) usethisdata ( 5 ) = . true . nfile = count ( usethisdata ) if ( nfile == 0 ) return allocate ( threadedfile ( nfile ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) mm = 1 do ii = 1 , 5 if ( usethisdata ( ii )) then select case ( ii ) case ( 1 ) threadedfile ( mm )% DataName = 'area' threadedfile ( mm )% FileInfo % FileName = trim ( setting % OutputThreadedLink % FileName ) // '_area' mm = mm + 1 case ( 2 ) threadedfile ( mm )% DataName = 'flowrate' threadedfile ( mm )% FileInfo % FileName = trim ( setting % OutputThreadedLink % FileName ) // '_flowrate' mm = mm + 1 case ( 3 ) threadedfile ( mm )% DataName = 'velocity' threadedfile ( mm )% FileInfo % FileName = trim ( setting % OutputThreadedLink % FileName ) // '_velocity' mm = mm + 1 case ( 4 ) threadedfile ( mm )% DataName = 'eta' threadedfile ( mm )% FileInfo % FileName = trim ( setting % OutputThreadedLink % FileName ) // '_eta' mm = mm + 1 case ( 5 ) threadedfile ( mm )% DataName = 'depth' threadedfile ( mm )% FileInfo % FileName = trim ( setting % OutputThreadedLink % FileName ) // '_depth_' mm = mm + 1 case default print * , 'error: unexpected value' stop end select endif enddo do mm = 1 , size ( threadedfile ) threadedfile ( mm )% FileInfo % FolderName = trim ( setting % OutputThreadedLink % FolderName ) threadedfile ( mm )% FileInfo % FolderPath = trim ( setting % OutputThreadedLink % FolderPath ) threadedfile ( mm )% FileInfo % FileStatus = 'new' threadedfile ( mm )% FileInfo % IsOpen = . false . threadedfile ( mm )% FileInfo % WriteName = trim ( threadedfile ( mm )% FileInfo % FolderPath ) // & trim ( threadedfile ( mm )% FileInfo % FolderName ) // '/' // & trim ( threadedfile ( mm )% FileInfo % FileName ) // & trim ( setting % Time % DateTimeStamp ) // & '.txt' call output_singlethreadedfile_open ( threadedfile ( mm )) enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine output_threaded_by_link_initialize ! !========================================================================== !========================================================================== ! subroutine output_all_threaded_data_by_link & ( threadedfile , elem2R , elem2I , elemMR , elemMI , faceR , faceI , linkI ,& bcdataUp , bcdataDn , thisstep ) character ( 64 ) :: subroutine_name = 'output_all_threaded_data_by_link' type ( threadedfileType ), intent ( in ) :: threadedfile (:) real , target , intent ( in ) :: elem2R (:,:), elemMR (:,:), faceR (:,:) integer , target , intent ( in ) :: elem2I (:,:), elemMI (:,:), faceI (:,:) integer , target , intent ( in ) :: linkI (:,:) type ( bcType ), intent ( in ) :: bcdataUp (:), bcdataDn (:) integer , intent ( in ) :: thisstep logical :: usethisdata ( 5 ) character ( len = 32 ) :: outdataName integer :: thisUnit , ii , mm , nfile !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if ( setting % OutputThreadedLink % SuppressAllFiles ) return if ( setting % OutputThreadedLink % DisplayInterval <= 0 ) return if ( mod ( thisstep , setting % OutputThreadedLink % DisplayInterval ) /= 0 ) return usethisdata = . false . if ( setting % OutputThreadedLink % area ) usethisdata ( 1 ) = . true . if ( setting % OutputThreadedLink % flowrate ) usethisdata ( 2 ) = . true . if ( setting % OutputThreadedLink % velocity ) usethisdata ( 3 ) = . true . if ( setting % OutputThreadedLink % eta ) usethisdata ( 4 ) = . true . if ( setting % OutputThreadedLink % depth ) usethisdata ( 5 ) = . true . nfile = count ( usethisdata ) if ( nfile == 0 ) return mm = 1 do ii = 1 , 5 if ( usethisdata ( ii )) then select case ( ii ) case ( 1 ) outdataName = 'area' thisUnit = threadedfile ( mm )% FileInfo % Unitnumber mm = mm + 1 case ( 2 ) outdataName = 'flowrate' thisUnit = threadedfile ( mm )% FileInfo % Unitnumber mm = mm + 1 case ( 3 ) outdataName = 'velocity' thisUnit = threadedfile ( mm )% FileInfo % Unitnumber mm = mm + 1 case ( 4 ) outdataName = 'eta' thisUnit = threadedfile ( mm )% FileInfo % Unitnumber mm = mm + 1 case ( 5 ) outdataName = 'depth' thisUnit = threadedfile ( mm )% FileInfo % Unitnumber mm = mm + 1 case default print * , 'error: unexpected case value in ' , trim ( subroutine_name ) stop end select call output_one_threaded_data_by_link & ( outdataName , thisUnit , thisstep , & elem2R , elem2I , elemMR , elemMI , faceR , faceI , linkI , bcdataUp , bcdataDn , ii ) ! if (ii==2) then !    print *, trim(subroutine_name) !    stop ! endif end if end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine output_all_threaded_data_by_link ! !========================================================================== !========================================================================== ! subroutine output_one_threaded_data_by_link & ( outdataName , thisUnit , thisstep , & elem2R , elem2I , elemMR , elemMI , faceR , faceI , linkI , bcdataUp , bcdataDn , itemp ) ! ! provides an output that threads the downstream BC, element or junction ! along with faces and links into a single array for visualization ! character ( 64 ) :: subroutine_name = 'output_one_threaded_data_by_link' character ( len =* ), intent ( in ) :: outdataName integer , intent ( in ) :: thisUnit real , target , intent ( in ) :: elem2R (:,:), elemMR (:,:), faceR (:,:) integer , target , intent ( in ) :: elem2I (:,:), elemMI (:,:), faceI (:,:) integer , target , intent ( in ) :: linkI (:,:) type ( bcType ), intent ( in ) :: bcdataUp (:), bcdataDn (:) integer , intent ( in ) :: thisstep , itemp real , dimension (:), allocatable , save :: thisdata , thisx integer :: ElemCol , FaceCol_u , FaceCol_d , JunctionCol integer :: BranchColUp ( upstream_face_per_elemM ), BranchColDn ( dnstream_face_per_elemM ) integer , pointer :: fdn , ftypDn , edn , bcidxDn , bdn , Lidx integer , pointer :: fup , ftypUp , eup , bcidxUp , bup integer :: maxelements_in_link , nelem , eStart , eEnd , eLast integer :: en , ii , mm , ndata integer :: allocation_status character ( len = 99 ) :: emsg !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if ( setting % OutputThreadedLink % SuppressAllFiles ) return !% allocate space for combining data on elements, face up, face dn, and the upstream !% and downstream adjacent element or BC if (. not . allocated ( thisdata )) then maxelements_in_link = maxval ( linkI (:, li_N_element ), 1 ,( linkI (:, li_N_element ) /= nullvalueI )) allocate ( thisdata ( 3 * maxelements_in_link + 7 ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) allocate ( thisX ( 3 * maxelements_in_link + 7 ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) endif thisdata = nullvalueR thisX = nullvalueR select case ( trim ( outdataName )) case ( 'area' ) ElemCol = e2r_Area FaceCol_u = fr_Area_u FaceCol_d = fr_Area_d JunctionCol = eMr_Area BranchColUp = eMr_AreaUp BranchColDn = eMr_AreaDn case ( 'flowrate' ) ElemCol = e2r_Flowrate FaceCol_u = fr_Flowrate FaceCol_d = fr_Flowrate JunctionCol = eMr_Flowrate BranchColUp = eMr_FlowrateUp BranchColDn = eMr_FlowrateDn case ( 'velocity' ) ElemCol = e2r_Velocity FaceCol_u = fr_Velocity_u FaceCol_d = fr_Velocity_d JunctionCol = eMr_Velocity BranchColUp = eMr_VelocityUp BranchColDn = eMr_VelocityDn case ( 'eta' ) ElemCol = e2r_Eta FaceCol_u = fr_Eta_u FaceCol_d = fr_Eta_d JunctionCol = eMr_Eta BranchColUp = eMr_EtaUp BranchColDn = eMr_EtaDn case ( 'depth' ) ElemCol = e2r_HydDepth FaceCol_u = fr_HydDepth_u FaceCol_d = fr_HydDepth_d JunctionCol = eMr_HydDepth BranchColUp = eMr_HydDepthUp BranchColDn = eMr_HydDepthDn case default print * , trim ( subroutine_name ) print * , outdataName print * , 'error: unexpected outdataName of ' , outdataName , ' in ' , trim ( subroutine_name ) stop end select do ii = 1 , N_link !%  this link Lidx => linkI ( ii , li_idx ) !%  start and end elements on this link eStart = minloc ( elem2I (:, e2i_link_Pos ), 1 ,( ( elem2I (:, e2i_link_ID ) == Lidx ) . and . ( elem2I (:, e2i_link_Pos ) /= nullvalueI ) ) ) eEnd = maxloc ( elem2I (:, e2i_link_Pos ), 1 ,( ( elem2I (:, e2i_link_ID ) == Lidx ) . and . ( elem2I (:, e2i_link_Pos ) /= nullvalueI ) ) ) nelem = eEnd - eStart + 1 !%  the downstream element beyond this link fdn => elem2I ( eStart , e2i_Mface_d ) ftypDn => faceI ( fdn , fi_type ) edn => faceI ( fdn , fi_Melem_d ) bcidxDn => faceI ( fdn , fi_BC_ID ) thisdata = nullvalueR thisX = nullvalueR ! get the data of the element (or BC) downstream of link select case ( ftypDn ) case ( fChannel ) ! downstream last element from previous link - upstream face thisdata ( 1 ) = faceR ( elem2I ( edn , e2i_Mface_d ), FaceCol_u ) thisX ( 1 ) = - elem2R ( edn , e2r_Length ) ! downstream last element from previous linke - center thisdata ( 2 ) = elem2R ( edn , elemCol ) thisX ( 2 ) = - onehalfR * elem2R ( edn , e2r_Length ) ! face downstream at link connection (node) thisdata ( 3 ) = faceR ( fdn , FaceCol_d ) thisX ( 3 ) = - oneeighthR * elem2R ( edn , e2r_Length ) ! face upstream at link connection (node) thisdata ( 4 ) = faceR ( fdn , FaceCol_u ) thisX ( 4 ) = zeroR case ( fPipe ) print * , 'error: pipe output not handled' stop case ( fMultiple ) bdn => faceI ( fdn , fi_branch_d ) ! downstram junction center thisdata ( 1 ) = elemMR ( edn , JunctionCol ) thisX ( 1 ) = - onehalfR * elemMR ( edn , eMr_Length ) ! downstrream branch thisdata ( 2 ) = elemMR ( edn , BranchColUp ( bdn )) thisX ( 2 ) = - onehalfR * elemMR ( edn , eMr_LengthUp ( bdn )) ! face downstream thisdata ( 3 ) = faceR ( fdn , FaceCol_d ) thisX ( 3 ) = - oneeighthR * elemMR ( edn , eMr_LengthUp ( bdn )) ! face upstream thisdata ( 4 ) = faceR ( fdn , FaceCol_u ) thisX ( 4 ) = zeroR case ( fBCup ) print * , 'error: fBCup not expected on a downstream face' stop case ( fBCdn ) ! ghost element thisdata ( 2 ) = elem2R ( edn , ElemCol ) thisX ( 2 ) = - onehalfR * elem2R ( eStart , e2r_Length ) ! bc data if ( trim ( outdataName ) == 'eta' ) then thisdata ( 1 ) = bcdataDn ( bcidxDn )% ThisValue else thisdata ( 1 ) = thisdata ( 2 ) endif thisX ( 1 ) = - elem2R ( eStart , e2r_Length ) ! Face downstream thisdata ( 3 ) = faceR ( fdn , FaceCol_d ) thisX ( 3 ) = - elem2R ( eStart , e2r_Length ) * 0.01 ! face upstream thisdata ( 4 ) = faceR ( fdn , FaceCol_u ) thisX ( 4 ) = zeroR case default print * , trim ( subroutine_name ) print * , ftypDn print * , 'error: unexpected face type Dn of ' , ftypDn , ' in ' , trim ( subroutine_name ) stop end select !%  thread the data as element, upstream face, downstream face, element... thisdata ( 5 ) = elem2R ( eStart , ElemCol ) thisX ( 5 ) = onehalfR * elem2R ( eStart , e2r_Length ) en = eStart do mm = 0 , nelem - 1 fup => elem2I ( en , e2i_Mface_u ) ! data on center thisdata ( 3 * mm + 5 ) = elem2R ( en , ElemCol ) thisX ( 3 * mm + 5 ) = thisX ( 3 * mm + 4 ) + 0.5 * elem2R ( en , e2r_Length ) ! downstream data on upstream face thisdata ( 3 * mm + 6 ) = faceR ( fup , FaceCol_d ) thisX ( 3 * mm + 6 ) = thisX ( 3 * mm + 5 ) + 0.49 * elem2R ( en , e2r_Length ) ! upstream data on upstream face thisdata ( 3 * mm + 7 ) = faceR ( fup , FaceCol_u ) thisX ( 3 * mm + 7 ) = thisX ( 3 * mm + 5 ) + 0.5 * elem2R ( en , e2r_Length ) en = en + 1 enddo eLast = 3 * nelem + 4 !% maps to the upstream face and element beyond this link fup => elem2I ( eEnd , e2i_Mface_u ) ftypUp => faceI ( fup , fi_type ) eup => faceI ( fup , fi_Melem_u ) bcidxUp => faceI ( fup , fi_BC_ID ) !    if (itemp == 2) then !    if (ii == 2) then !    print *, trim(subroutine_name) !    print *, ftypUp !    print *, fChannel, fPipe, fMultiple, fBCup, fBCdn !    print *, eLast,'= eLast' !    print *, eEnd,'=eEnd' !    print *, eup,'=eup' !    print *, bcidxUp,'=bcidxUp' !    print *, size(thisdata,1),'=size thisdata' !    print *, size(thisX,1),'=size thisx' !    print *, size(elem2R,1),'=size elem2R' ! ! !print *, thisdata(eLast+1) !print *, elem2R(eup,ElemCol) !print *, thisX(eLast+1) !print *, thisX(eLast) + onehalfR * elem2R(eEnd,e2r_Length) !!            ! BC !            if (trim(outdataName) == 'flowrate') then !print *, thisdata(eLast+2) !print *, bcidxUp !print *, size(bcdataUp) !print *, bcdataUp(bcidxUp)%ThisValue !            else !!print *, thisdata(eLast+2) !            endif !!print *, thisX(eLast+2) !!print *, thisX(eLast) +  elem2R(eEnd,e2r_Length) !    stop !    endif !    endif ! select case ( ftypUp ) case ( fChannel ) !%  First element of the next upstream link thisdata ( eLast + 1 ) = elem2R ( eup , ElemCol ) thisX ( eLast + 1 ) = thisX ( eLast ) + onehalfR * elem2R ( eup , e2r_Length ) thisdata ( eLast + 2 ) = faceR ( elem2I ( eup , e2i_Mface_u ), FaceCol_d ) thisX ( eLast + 2 ) = thisX ( eLast ) + elem2R ( eup , e2r_Length ) case ( fPipe ) print * , 'error: pipe not handled yet in ' , trim ( subroutine_name ) stop case ( fMultiple ) !% an upstream junction bup => faceI ( fup , fi_branch_u ) ! branch values thisdata ( eLast + 1 ) = elemMR ( eup , BranchColDn ( bup )) thisX ( eLast + 1 ) = thisX ( eLast ) + onehalfR * elemMR ( eup , eMr_LengthDn ( bup )) ! junction center values thisdata ( eLast + 2 ) = elemMR ( eup , JunctionCol ) thisX ( eLast + 2 ) = thisX ( eLast ) + onehalfR * elemMR ( eup , eMr_Length ) case ( fBCup ) ! an upstream BC with ghost element thisdata ( eLast + 1 ) = elem2R ( eup , ElemCol ) thisX ( eLast + 1 ) = thisX ( eLast ) + onehalfR * elem2R ( eEnd , e2r_Length ) ! BC if ( trim ( outdataName ) == 'flowrate' ) then thisdata ( eLast + 2 ) = bcdataUp ( bcidxUp )% ThisValue else thisdata ( eLast + 2 ) = thisdata ( eLast + 1 ) endif thisX ( eLast + 2 ) = thisX ( eLast ) + elem2R ( eEnd , e2r_Length ) case ( fBCdn ) print * , 'error: fBCdn not expected on an upstream face in ' , trim ( subroutine_name ) stop case default print * , trim ( subroutine_name ) print * , ftypUp print * , 'error: unexpected face type Up of ' , ftypUp , ' in ' , trim ( subroutine_name ) stop end select ndata = eLast + 2 !    do mm=1,ndata !        print *, mm, thisX(mm), thisdata(mm) !    end do write ( thisUnit , * ) thisstep , '=this step' write ( thisUnit , * ) Lidx , '=this_link_index' write ( thisUnit , * ) ndata , '=items_this_link' write ( thisUnit , * ) 2 , '=rows_this_link_X_data' write ( thisUnit , * ) thisX ( 1 : ndata ) write ( thisUnit , * ) thisdata ( 1 : ndata ) end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine output_one_threaded_data_by_link !========================================================================== ! ! PRIVATE BELOW HERE ! !========================================================================== ! subroutine output_singlethreadedfile_open ( threadedfile ) ! ! Opens a single file for output writing ! character ( 64 ) :: subroutine_name = 'output_singlethreadedfile_open' type ( threadedfileType ), intent ( in out ) :: threadedfile integer :: open_status character ( len = 512 ) :: emsg !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name open_status = 0 threadedfile % FileInfo % UnitNumber = outputfile_next_unitnumber outputfile_next_unitnumber = outputfile_next_unitnumber + 1 open ( unit = threadedfile % FileInfo % Unitnumber , & file = trim ( threadedfile % FileInfo % WriteName ), & status = trim ( threadedfile % FileInfo % FileStatus ), & access = 'sequential' , & form = 'formatted' , & action = 'write' , & iostat = open_status ) emsg = 'file exists or path/folder does not exist: file open failed in ' // trim ( subroutine_name ) & // '; filename = ' // trim ( threadedfile % FileInfo % WriteName ) call utility_check_fileopen ( open_status , emsg ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine output_singlethreadedfile_open ! !========================================================================== ! END OF MODULE output !========================================================================== end module output","title":"output.f08 – SWMMengine","tags":"","loc":"sourcefile/output.f08.html"},{"text":"This file depends on sourcefile~~network_define.f08~~EfferentGraph sourcefile~network_define.f08 network_define.f08 sourcefile~globals.f08 globals.f08 sourcefile~network_define.f08->sourcefile~globals.f08 sourcefile~allocate_storage.f08 allocate_storage.f08 sourcefile~network_define.f08->sourcefile~allocate_storage.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~network_define.f08->sourcefile~array_index.f08 sourcefile~junction.f08 junction.f08 sourcefile~network_define.f08->sourcefile~junction.f08 sourcefile~initialization.f08 initialization.f08 sourcefile~network_define.f08->sourcefile~initialization.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~network_define.f08->sourcefile~data_keys.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~allocate_storage.f08->sourcefile~globals.f08 sourcefile~allocate_storage.f08->sourcefile~array_index.f08 sourcefile~utility.f08 utility.f08 sourcefile~allocate_storage.f08->sourcefile~utility.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~junction.f08->sourcefile~globals.f08 sourcefile~junction.f08->sourcefile~array_index.f08 sourcefile~junction.f08->sourcefile~data_keys.f08 sourcefile~junction.f08->sourcefile~setting_definition.f08 sourcefile~junction.f08->sourcefile~utility.f08 sourcefile~initialization.f08->sourcefile~globals.f08 sourcefile~initialization.f08->sourcefile~array_index.f08 sourcefile~initialization.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 var pansourcefilenetwork_definef08EfferentGraph = svgPanZoom('#sourcefilenetwork_definef08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~network_define.f08~~AfferentGraph sourcefile~network_define.f08 network_define.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~network_define.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules network_define Source Code network_define.f08 Source Code ! ! module network_define ! ! Handles relationship between coarse link-node network and high-resolution ! element-face network. ! ! This module defines all the indexes and mappings ! !========================================================================== ! module network_define ! use allocate_storage use array_index use initialization use data_keys use globals use junction implicit none private public :: network_initiation integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine network_initiation & ( linkI , linkR , linkYN , linkName , & nodeI , nodeR , nodeYN , nodeName , & elem2R , elem2I , elem2YN , elem2Name , & elemMR , elemMI , elemMYN , elemMName , & faceR , faceI , faceYN , faceName ) ! ! Initializes a element-face network from a link-node network. ! Requires network links and nodes before execution (e.g. module test_cases) ! character ( 64 ) :: subroutine_name = 'network_initiation' integer , target , intent ( in out ) :: linkI (:,:) integer , target , intent ( in out ) :: nodeI (:,:) real , intent ( in out ) :: linkR (:,:) real , target , intent ( in out ) :: nodeR (:,:) type ( string ), intent ( in out ) :: linkName (:) type ( string ), intent ( in out ) :: nodeName (:) logical , intent ( in out ) :: linkYN (:,:) logical , intent ( out ) :: nodeYN (:,:) !%   elem2# are the values for elements that have only 2 faces real , dimension (:,:), allocatable , target :: elem2R ! real data for elements with 2 faces integer , dimension (:,:), allocatable , target :: elem2I ! integer data for elements with 2 faces logical , dimension (:,:), allocatable , target :: elem2YN ! logical data for elements with 2 faces type ( string ), dimension (:), allocatable , target :: elem2Name ! array of character strings !%   elemM# are the values for elements that have more than 2 faces real , dimension (:,:), allocatable , target :: elemMR ! real data for elements with multi faces integer , dimension (:,:), allocatable , target :: elemMI ! integer data for elements with multi faces logical , dimension (:,:), allocatable , target :: elemMYN ! logical data for elements with multi faces type ( string ), dimension (:), allocatable , target :: elemMName ! array of character strings !%   face# are the values for faces (always bounded by 2 elements) real , dimension (:,:), allocatable , target :: faceR ! real data for faces integer , dimension (:,:), allocatable , target :: faceI ! integer data for faces logical , dimension (:,:), allocatable , target :: faceYN ! logical data for face type ( string ), dimension (:), allocatable , target :: faceName ! array of character strings integer :: ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !%   assign links to nodes call network_node_assignment ( nodeI , linkI ) !%   confirm that the link-node network is valid call network_check_node_link_match ( linkI , nodeI ) !%   check that sufficient BC locations have been identified call network_check_BC ( nodeI , N_node ) !%   get the slope of each link given the node Z values call network_get_link_slope ( linkR , nodeR , linkI , nodeI ) ! HACK - need a check here to look for non-monotonic zbottom in the link/node ! system. Where found the system needs to be subdivided into monotonic links. ! Typically this should only be an issue where the links are representing a ! high-resolution natural channel. !%   add sections of links to the nodes to create junctions call network_adjust_link_length ( linkR , nodeR , linkI , nodeI ) !%   determine the system size call network_count_elements_and_faces ( nodeR , linkI , nodeI ) !%   allocate all the data storage call allocate_data_storage & ( elem2R , elemMR , faceR , elem2I , elemMI , faceI , elem2YN , elemMYN , faceYN , & elem2Name , elemMname , faceName ) !%   ensure elemMR (junction) array has zero values in the multiple geometry storage call initialize_array_zerovalues ( elemMR ) call initialize_dummy_values & ( elem2R , elem2I , elem2YN , & elemMR , elemMI , elemMYN , & faceR , faceI , faceYN ) !%   store the data from the network in the element and face arrays call network_data_create & ( elem2R , elemMR , faceR , linkR , nodeR , elem2I , elemMI , faceI , & linkI , nodeI , nodeYN , elem2Name , elemMName , faceName , linkName , nodeName ) !%   setup the geometric relationships between the junction branches and the main values call junction_geometry_setup ( elemMR , elemMI ) !%   assign branch mappings for faces call junction_branch_assigned_to_faces ( faceI , elemMI ) !% Debug output if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) then print * , subroutine_name , '----------------------------------------' print * , first_elem2_index , first_elem2_index + N_elem2 - 1 ! Printout network for debugging print * print * , 'a)       ii  ,   e2i_idx  ,  e2i_elem_type  ' do ii = first_elem2_index , first_elem2_index + N_elem2 - 1 print * , ii , elem2I ( ii , e2i_idx ), elem2I ( ii , e2i_elem_type ) enddo print * print * , 'b)       ii  ,e2i_geometry, e2i_link_ID, e2i_link_Pos' do ii = first_elem2_index , first_elem2_index + N_elem2 - 1 print * , ii , elem2I ( ii , e2i_geometry ), elem2I ( ii , e2i_link_ID ), elem2I ( ii , e2i_link_Pos ) enddo print * print * , 'c)       ii  ,e2i_roughness_type, e2i_link_ID, e2i_link_Pos' do ii = first_elem2_index , first_elem2_index + N_elem2 - 1 print * , ii , elem2I ( ii , e2i_roughness_type ), elem2I ( ii , e2i_link_ID ), elem2I ( ii , e2i_link_Pos ) enddo print * print * , 'd)       ii  ,e2i_Mface_u, e2i_Mface_d,  e2i_link_ID, e2i_link_Pos' do ii = first_elem2_index , first_elem2_index + N_elem2 - 1 print * , ii , elem2I ( ii , e2i_Mface_u ), elem2I ( ii , e2i_Mface_d ), elem2I ( ii , e2i_link_ID ), elem2I ( ii , e2i_link_Pos ) enddo print * print * , 'e)       ii  ,e2r_Length, e2r_Topwidth, e2r_Zbottom' do ii = first_elem2_index , first_elem2_index + N_elem2 - 1 print * , ii , elem2R ( ii , e2r_Length ), elem2R ( ii , e2r_Topwidth ), elem2R ( ii , e2r_Zbottom ) enddo print * print * , '------------- faces -----------------expecting ' , N_face print * print * , 'h)       ii,         idx,     Melem_u,    Melem_d,    etype_u,    etype_d' do ii = first_face_index , first_face_index + N_face - 1 print * , ii , faceI ( ii , fi_idx ), faceI ( ii , fi_Melem_u ), faceI ( ii , fi_Melem_d ), & faceI ( ii , fi_etype_u ), faceI ( ii , fi_etype_d ) enddo print * print * , 'i)       ii,         Zbottom,     Topwidth' do ii = first_face_index , first_face_index + N_face - 1 print * , ii , faceR ( ii , fr_Zbottom ), faceR ( ii , fr_Topwidth ) enddo print * print * , '------------- junctions ---------------------' print * print * , 'j)       ii  , face maps u1, u2, d1 ' do ii = first_elemM_index , first_elemM_index + N_elemM - 1 print * , ii , elemMI ( ii , eMi_Mface_u1 ), elemMI ( ii , eMi_Mface_u2 ), elemMI ( ii , eMi_Mface_d1 ) enddo print * print * , 'k)       ii  , Length, u1,  u2, d1, ' do ii = first_elemM_index , first_elemM_index + N_elemM - 1 print * , ii , elemMR ( ii , eMr_Length ), elemMR ( ii , eMr_Length_u1 ), elemMR ( ii , eMr_Length_u2 ), elemMR ( ii , eMr_Length_d1 ) enddo print * print * , 'l)       ii  , Topwidth, u1, u2, d1 ' do ii = first_elemM_index , first_elemM_index + N_elemM - 1 print * , ii , elemMR ( ii , eMr_Topwidth ), elemMR ( ii , eMr_Topwidth_u1 ), elemMR ( ii , eMr_Topwidth_u2 ), elemMR ( ii , eMr_Topwidth_d1 ) enddo print * print * , 'm)       ii  , Zbottom, u1, u2, d1 ' do ii = first_elemM_index , first_elemM_index + N_elemM - 1 print * , ii , elemMR ( ii , eMr_Zbottom ), elemMR ( ii , eMr_Zbottom_u1 ), elemMR ( ii , eMr_Zbottom_u2 ), elemMR ( ii , eMr_Zbottom_d1 ) enddo endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine network_initiation ! !========================================================================== ! ! PRIVATE BELOW HERE ! !========================================================================== ! subroutine network_node_assignment & ( nodeI , linkI ) ! ! assign maps from nodes to links that are consistent with link maps ! This assumes that all links are assigned with maps to nodes correctly ! character ( 64 ) :: subroutine_name = 'network_node_assignment' integer , intent ( in out ) :: nodeI (:,:) integer , intent ( in ) :: linkI (:,:) integer :: ii , thisnode !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name ! assign zeros for accumulators nodeI (:, ni_N_link_d ) = 0 nodeI (:, ni_N_link_u ) = 0 nodeI (:, ni_Mlink_d1 ) = nullvalueI nodeI (:, ni_Mlink_d2 ) = nullvalueI nodeI (:, ni_Mlink_d3 ) = nullvalueI nodeI (:, ni_Mlink_u1 ) = nullvalueI nodeI (:, ni_Mlink_u2 ) = nullvalueI nodeI (:, ni_Mlink_u3 ) = nullvalueI !%  cycle through links to assign nodes do ii = 1 , N_link !%  get the upstream node of the link thisnode = linkI ( ii , li_Mnode_u ) print * , thisnode if (( thisnode < 1 ) . or . ( thisnode > N_node )) then print * , ii , '= this link' print * , thisnode , '= upstream node assigned' print * , 'error: problem in link-node definitions' stop else nodeI ( thisnode , ni_N_link_d ) = nodeI ( thisnode , ni_N_link_d ) + 1 endif if ( nodeI ( thisnode , ni_N_link_d ) > dnstream_face_per_elemM ) then print * , dnstream_face_per_elemM , ' = allowed downstream links per node' print * , ii , '= this link' print * , thisnode , '= this node' print * , 'error: attempt to assign too many downstream links to one node' stop endif select case ( nodeI ( thisnode , ni_N_link_d )) case ( 1 ) nodeI ( thisnode , ni_Mlink_d1 ) = ii case ( 2 ) nodeI ( thisnode , ni_Mlink_d2 ) = ii case ( 3 ) nodeI ( thisnode , ni_Mlink_d3 ) = ii case default print * , 'error - attempt to assign more than 3 downstream links to one node' stop end select !    print *, '----------' !    print *, ii !    print *, nodeI(:,ni_Mlink_d1) !    print *, nodeI(:,ni_Mlink_d2) !    print *, nodeI(:,ni_Mlink_d3) !    print *, nodeI(:,ni_N_link_d) ! !% get the downstream node of the link thisnode = linkI ( ii , li_Mnode_d ) if (( thisnode < 1 ) . or . ( thisnode > N_node )) then print * , ii , '= this link' print * , thisnode , '= downstream node assigned' print * , 'error: problem in link-node definitions' stop else nodeI ( thisnode , ni_N_link_u ) = nodeI ( thisnode , ni_N_link_u ) + 1 endif if ( nodeI ( thisnode , ni_N_link_u ) > upstream_face_per_elemM ) then print * , upstream_face_per_elemM , ' = allowed upstream links per node' print * , ii , '= this link' print * , thisnode , '= this node' print * , 'error: attempt to assign too many upstream links to one node' stop endif select case ( nodeI ( thisnode , ni_N_link_u )) case ( 1 ) nodeI ( thisnode , ni_Mlink_u1 ) = ii case ( 2 ) nodeI ( thisnode , ni_Mlink_u2 ) = ii case ( 3 ) nodeI ( thisnode , ni_Mlink_u3 ) = ii case default print * , 'error - attempt to assign more than 3 uptream links to one node' stop end select !    print *, '----------' !    print *, ii !    print *, nodeI(:,ni_Mlink_u1) !    print *, nodeI(:,ni_Mlink_u2) !    print *, nodeI(:,ni_Mlink_u3) !    print *, nodeI(:,ni_N_link_u) ! end do !%  cycle through links to assign nodes ! do ii=1,N_link ! !    !%  get the upstream node of the link (if it exists) !    thisnode = linkI(ii,li_Mnode_u) ! !    print *, ii,'=Link; ', thisnode,'= upstream node assigned' ! !    !%  look for next available downstream link position !    if (thisnode > 0) then !        if (nodeI(thisnode,ni_Mlink_d1) == nullvalueI) then !            nodeI(thisnode,ni_Mlink_d1) = ii !        else !            print *, 'node ',thisnode !            print *, 'error: attempt to assign 2 downstream links to 1 node in ',subroutine_name !            stop !        endif ! !        !%  increment the downstream link counter !        nodeI(thisnode,ni_N_link_d) = nodeI(thisnode,ni_N_link_d)+1 !    endif ! !    !%  get the downstream node of the link (if it exists) !    thisnode = linkI(ii,li_Mnode_d) ! !    print *, ii,'=Link; ', thisnode,'= downstream node assigned' ! !    !%  look for the next available upstream link position !    if (thisnode > 0) then ! !        if (nodeI(thisnode,ni_Mlink_u1) == nullvalueI) then !            nodeI(thisnode,ni_Mlink_u1) = ii !        elseif (nodeI(thisnode,ni_Mlink_u2) == nullvalueI) then !                nodeI(thisnode,ni_Mlink_u2) = ii !        else !            print *, 'node ',thisnode !            print *, 'error: attempt to assign 3 upstream links to 1 node in ',subroutine_name !            stop !        endif ! !        !%  increment the upstream link counter !        nodeI(thisnode,ni_N_link_u) = nodeI(thisnode,ni_N_link_u)+1 !    endif ! enddo ! if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine network_node_assignment ! !========================================================================== !========================================================================== ! subroutine network_check_node_link_match & ( linkI , nodeI ) ! ! check that the upstream and downstream linkages are consistent ! and complete ! character ( 64 ) :: subroutine_name = 'network_check_node_link_match' integer , target , intent ( in ) :: linkI (:,:) integer , intent ( in ) :: nodeI (:,:) integer :: ii , mm integer , pointer :: Unode , Dnode logical :: ifound !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do ii = 1 , N_link !%  upstream and downstream nodes to this link Unode => linkI ( ii , li_Mnode_u ) Dnode => linkI ( ii , li_Mnode_d ) !%  check that upstream node has the correct downstream link ifound = . false . do mm = 1 , dnstream_face_per_elemM if ( nodeI ( Unode , ni_MlinkDn ( mm )) == ii ) then ifound = . true . endif enddo if (. not . ifound ) then print * , 'downstream link ' , ii , ' not found for node ' , Unode stop endif !%  check that downstream node has the correct upstream link ifound = . false . do mm = 1 , upstream_face_per_elemM if ( nodeI ( Dnode , ni_MlinkUp ( mm )) == ii ) then ifound = . true . endif enddo if (. not . ifound ) then print * , 'upstream link ' , ii , ' not found for node ' , Dnode stop endif enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine network_check_node_link_match ! !========================================================================== !========================================================================== ! subroutine network_check_BC & ( nodeI , N_node ) ! ! check that BC nodes have correct upstream and downstream links ! character ( 64 ) :: subroutine_name = 'network_check_BC' integer , intent ( in ) :: N_node integer , intent ( in ) :: nodeI (:,:) integer :: ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do ii = 1 , N_node if ( nodeI ( ii , ni_node_type ) == nBCup ) then if ( nodeI ( ii , ni_Mlink_d1 ) < 1 ) then print * , 'node = ' , ii print * , 'error: A downstream link is required at an upstream BC node in ' , subroutine_name stop endif if ( nodeI ( ii , ni_N_link_d ) > 1 ) then print * , 'node = ' , ii print * , 'error: An upstream BC node can only have one downstream link in ' , subroutine_name STOP endif if ( nodeI ( ii , ni_Mlink_u1 ) > 1 ) then print * , 'node = ' , ii print * , 'link = ' , nodeI ( ii , ni_Mlink_u1 ) print * , 'error: Upstream BC node cannot have upstream link in ' , subroutine_name stop endif endif if ( nodeI ( ii , ni_node_type ) == nBCdn ) then if ( nodeI ( ii , ni_Mlink_u1 ) < 1 ) then print * , 'node = ' , ii print * , 'error: An upstream link is required at downstream BC node in ' , subroutine_name stop endif if ( nodeI ( ii , ni_N_link_u ) > 1 ) then print * , 'node = ' , ii print * , 'error: A downstream BC node can only have one upstream link in ' , subroutine_name STOP endif if ( nodeI ( ii , ni_Mlink_d1 ) > 1 ) then print * , 'node = ' , ii print * , 'link = ' , nodeI ( ii , ni_Mlink_d1 ) print * , 'error: Downstream BC node cannot have downstream link in ' , subroutine_name stop endif endif enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine network_check_BC ! !========================================================================== !========================================================================== ! subroutine network_get_link_slope & ( linkR , nodeR , linkI , nodeI ) ! ! compute the slope across each link ! character ( 64 ) :: subroutine_name = 'network_get_link_slope' integer , target , intent ( in ) :: linkI (:,:) integer , target , intent ( in ) :: nodeI (:,:) real , intent ( in out ) :: linkR (:,:) real , target , intent ( in ) :: nodeR (:,:) integer , pointer :: nUp , nDn real , pointer :: zUp , zDn integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do mm = 1 , N_link nUp => linkI ( mm , li_Mnode_u ) nDn => linkI ( mm , li_Mnode_d ) zUp => nodeR ( nUp , nr_Zbottom ) zDn => nodeR ( nDn , nr_Zbottom ) linkR ( mm , lr_Slope ) = ( zUp - zDn ) / linkR ( mm , lr_Length ) end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) then !% provide output for debugging print * , subroutine_name , '--------------------------------' print * , 'link ID,  Slope, length' do mm = 1 , N_link print * , mm , linkR ( mm , lr_Slope ), linkR ( mm , lr_Length ) end do endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine network_get_link_slope ! !========================================================================== !========================================================================== ! subroutine network_adjust_link_length & ( linkR , nodeR , linkI , nodeI ) ! ! Adjust the link lengths so that a portion goes to each junction ! when the junctions need physical dimensions. This is necessary when ! a junction has more than an single upstream and downstream reach. ! ! We take away a portion of a nominal element length at a junction if ! there is more than one element in the upstream or downstream link. ! If there is only one element in the link, then subtract a portion of ! the actual link length. ! ! The \"lost\" link length is added to the junction (node) ! character ( 64 ) :: subroutine_name = 'network_adjust_link_length' integer , target , intent ( in out ) :: linkI (:,:) integer , intent ( in ) :: nodeI (:,:) real , target , intent ( in out ) :: linkR (:,:) real , target , intent ( in out ) :: nodeR (:,:) integer :: ii , mm real :: delta real , pointer :: linkLength (:) integer , pointer :: linkNelem (:) real , pointer :: element_nominal_length (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name linkLength => linkR (:, lr_Length ) element_nominal_length => linkR (:, lr_ElementLength ) linkNelem => linkI (:, li_N_element ) do ii = 1 , N_node !%   only applies to nJm junctions -- not to nJ2 junctions if ( nodeI ( ii , ni_node_type ) == nJm ) then !%   shorten the upstream links if ( nodeI ( ii , ni_N_link_u ) > 0 ) then call link_shortening & ( linkLength , nodeR , nodeI , ii , & ni_N_link_u , ni_MlinkUp , nr_ElementLengthUp , element_nominal_length ) endif !%   shorten the downstream links if ( nodeI ( ii , ni_N_link_d ) > 0 ) then call link_shortening & ( linkLength , nodeR , nodeI , ii , & ni_N_link_d , ni_MlinkDn , nr_ElementLengthDn , element_nominal_length ) endif endif enddo !%  get the uniform elements that subdivide a link do ii = 1 , N_link linkNelem ( ii ) = floor ( linkLength ( ii ) / element_nominal_length ( ii )) if ( linkNelem ( ii ) > 0 ) then delta = ( linkLength ( ii ) - element_nominal_length ( ii ) * linkNelem ( ii )) & / linkNelem ( ii ) linkR ( ii , lr_ElementLength ) = element_nominal_length ( ii ) + delta else !%  for case when only 1 nominal element will fit in link linkNelem ( ii ) = 1 linkR ( ii , lr_ElementLength ) = linkLength ( ii ) endif enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) then !%  debugging output print * print * , subroutine_name , '----------------------------------' print * , 'link number, element_length, N_element' do ii = 1 , N_link print * , ii , linkR ( ii , lr_ElementLength ), linkI ( ii , li_N_element ) enddo endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine network_adjust_link_length ! !========================================================================== !========================================================================== ! subroutine network_count_elements_and_faces & ( nodeR , linkI , nodeI ) ! ! computes global values for element, face, and BC counts ! character ( 64 ) :: subroutine_name = 'network_count_elements_and_faces' real , intent ( in ) :: nodeR (:,:) integer , intent ( in ) :: linkI (:,:) integer , intent ( in ) :: nodeI (:,:) integer :: ii , NupstreamBC , NdownstreamJ , NdnstreamBC !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !% sum the number of elements in the links N_elem2 = sum ( linkI (:, li_N_element ), MASK = ( linkI (:, li_N_element ) > 0 )) !% add junctions that have physical dimesions - these become elements do ii = 1 , N_node if ( ( nodeR ( ii , nr_ElementLength_u1 ) > 0.0 ) . or . & ( nodeR ( ii , nr_ElementLength_d1 ) > 0.0 ) ) then N_elemM = N_elemM + 1 endif enddo !% count the number of upstream BC nodes NupstreamBC = count ( nodeI (:, ni_node_type ) == nBCup ) !% count the number of upstream BC nodes NdnstreamBC = count ( nodeI (:, ni_node_type ) == nBCdn ) !% Add ghost elements outside of BC N_elem2 = N_elem2 + NupstreamBC + NdnstreamBC !% count the numer of downstream faces at junction elements NdownstreamJ = sum ( nodeI (:, ni_N_link_d ), MASK = ( nodeI (:, ni_node_type ) == nJm )) !% Faces are between elem2, upstream BC, and all downstreamJ. !% Note the NdnstreamBC are already counted in the initial link count. N_face = sum ( linkI (:, li_N_element )) + NupstreamBC + NdownstreamJ if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) then !%  debugging output print * print * , subroutine_name , '----------------------------------' print * , 'expecting # elem2 = ' , N_elem2 print * , 'expecting # elemM = ' , N_elemM print * , 'expecting # face  = ' , N_face endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine network_count_elements_and_faces ! !========================================================================== !========================================================================== ! subroutine network_data_create & ( elem2R , elemMR , faceR , linkR , nodeR , elem2I , elemMI , faceI , & linkI , nodeI , nodeYN , elem2Name , elemMName , faceName , linkName , nodeName ) ! ! creates the network of elements and junctions from nodes and links ! character ( 64 ) :: subroutine_name = 'network_data_create' integer , intent ( in out ) :: elem2I (:,:), elemMI (:,:), faceI (:,:) real , intent ( in out ) :: elem2R (:,:), elemMR (:,:), faceR (:,:) integer , intent ( in out ) :: linkI (:,:) integer , target , intent ( in out ) :: nodeI (:,:) real , target , intent ( in ) :: linkR (:,:), nodeR (:,:) logical , target , intent ( in ) :: nodeYN (:,:) integer :: ii , lastElem2 , thisElem2 , lastElemM , thisElemM , lastFace , thisFace integer :: N_BCnodes_d , thisNode , thisLink logical , pointer :: nodeYNmask (:) integer , pointer :: nodesDownstream (:) real , pointer :: Zdownstream type ( string ), intent ( in out ) :: elem2Name (:), elemMName (:), faceName (:) type ( string ), intent ( in ) :: linkName (:), nodeName (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name lastElem2 = zeroI ! last elem2 that was assigned lastElemM = zeroI ! last elemM that was assigned thisElem2 = first_elem2_index ! this elem2 that is ready to be assigned thisElemM = first_elemM_index ! this elemM that is ready to be assigned lastFace = zeroI thisFace = first_face_index nodeYNmask => nodeYN (:, nYN_temp1 ) nodeYNmask = ( nodeI (:, ni_node_type ) == nBCdn ) nodesDownstream => nodeI (:, ni_temp1 ) N_BCnodes_d = count ( nodeYNmask ) if ( N_BCnodes_d == 0 ) then print * , 'No downstream channel boundary nodes found - code development incomplete for dowstream pipe' STOP elseif ( N_BCnodes_d > 0 ) then !NOTE - need to test/modify this for multiple downstream nodes. ! get a list of downstream nodes nodesDownstream ( 1 : N_BCnodes_d ) = pack ( nodeI (:, ni_idx ), nodeYNmask ) else print * , 'N_BCnodes_d ' , N_BCnodes_d print * , 'error: unexpected else in ' , subroutine_name stop endif do ii = 1 , N_BCnodes_d if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) then print * , 'starting downstream node ' , nodesDownstream ( ii ) endif thisNode = nodesDownstream ( ii ) if ( nodeI ( thisNode , ni_assigned ) == nAssigned ) then cycle ! node is already assigned! endif nodeI ( thisNode , ni_assigned ) = setAssigned ( thisNode , ni_assigned , nUnassigned , nAssigned , nodeI ) !% error checking for downstream BC if ( nodeI ( thisNode , ni_N_link_d ) /= 0 ) then print * , 'error: A downstream BC node should not have a downstream link in ' , subroutine_name STOP endif if ( nodeI ( thisNode , ni_N_link_u ) /= 1 ) then print * , 'error: A downstream BC node must have exactly one upstream link in ' , subroutine_name STOP endif !% set the upstream link (one only) of the downstream BC node thisLink = nodeI ( thisNode , ni_Mlink_u1 ) if ( linkI ( thisLink , li_assigned ) == lAssigned ) then print * , 'error: it is not clear how the node was not assigned but the link is assigned in ' , subroutine_name stop endif linkI ( thisLink , li_assigned ) = setAssigned ( thisLink , li_assigned , lUnassigned , lAssigned , linkI ) !% Assign the ghost element - use values for upstream link elem2I ( thisElem2 , e2i_idx ) = thisElem2 elem2I ( thisElem2 , e2i_elem_type ) = eBCdn elem2I ( thisElem2 , e2i_geometry ) = linkI ( thisLink , li_geometry ) elem2I ( thisElem2 , e2i_roughness_type ) = linkI ( thisLink , li_roughness_type ) elem2I ( thisElem2 , e2i_link_ID ) = thisLink elem2I ( thisElem2 , e2i_link_Pos ) = nullvalueI elem2I ( thisElem2 , e2i_Mface_u ) = thisFace elem2I ( thisElem2 , e2i_Mface_d ) = nullvalueI elem2R ( thisElem2 , e2r_Length ) = linkR ( thislink , lr_ElementLength ) !% note the following has a minus as we are going downstream for the ghost elem2R ( thisElem2 , e2r_Zbottom ) = nodeR ( thisNode , nr_Zbottom ) & - 0.5 * linkR ( thisLink , lr_Slope ) & * linkR ( thislink , lr_ElementLength ) select case ( linkI ( thisLink , li_geometry )) case ( lRectangular ) elem2R ( thisElem2 , e2r_Topwidth ) = linkR ( thisLink , lr_BreadthScale ) elem2R ( thisElem2 , e2r_BreadthScale ) = linkR ( thisLink , lr_BreadthScale ) !faceR(thisFace,fr_Topwidth)    = linkR(thisLink,lr_Breadth) case default print * , 'error: case statement is incomplete in ' , subroutine_name stop end select ! use the node name for the ghost element elem2Name ( thisElem2 ) = nodeName ( thisNode ) ! store the face info for the downstream BC node faceI ( thisFace , fi_idx ) = thisFace faceI ( thisFace , fi_type ) = fBCdn faceI ( thisFace , fi_Melem_u ) = thisElem2 + 1 faceI ( thisFace , fi_Melem_d ) = thisElem2 faceI ( thisFace , fi_etype_u ) = linkI ( thisLink , li_link_type ) faceI ( thisFace , fi_etype_d ) = elem2I ( thisElem2 , e2i_elem_type ) faceI ( thisFace , fi_jump_type ) = nullvalueI faceI ( thisFace , fi_link_ID ) = nullvalueI faceI ( thisFace , fi_link_Pos ) = nullvalueI faceI ( thisFace , fi_node_ID ) = thisNode faceR ( thisFace , fr_Zbottom ) = nodeR ( thisNode , nr_Zbottom ) faceName ( thisFace ) = nodeName ( thisNode ) lastFace = thisFace thisFace = thisFace + 1 lastElem2 = thisElem2 thisElem2 = thisElem2 + 1 !% subdivide the first link upstream of the downstream BC (only one link allowed) Zdownstream => nodeR ( thisNode , nr_Zbottom ) call subdivide_link_going_upstream & ( lastElem2 , thisElem2 , lastFace , thisFace , thisLink , & elem2I , faceI , linkI , elem2R , faceR , linkR , nodeR , Zdownstream ) nullify ( Zdownstream ) !% advance the node counter thisNode = linkI ( thisLink , li_Mnode_u ) if ( nodeI ( thisNode , ni_assigned ) == nAssigned ) then cycle ! node is already assigned! endif nodeI ( thisNode , ni_assigned ) = setAssigned ( thisNode , ni_assigned , nUnassigned , nAssigned , nodeI ) !% deal with the next node call handle_thisnode & ( lastElem2 , thisElem2 , lastElemM , thisElemM , & lastFace , thisFace , thisNode , thisLink , & elem2I , elemMI , faceI , linkI , nodeI , elem2R , elemMR , faceR , linkR , nodeR , & elem2Name , elemMName , faceName , linkName , nodeName ) enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine network_data_create !========================================================================== !========================================================================== ! recursive subroutine handle_thisnode & ( lastElem2 , thisElem2 , lastElemM , thisElemM , & lastFace , thisFace , thisNode , thisLink , & elem2I , elemMI , faceI , linkI , nodeI , elem2R , elemMR , faceR , linkR , nodeR , & elem2Name , elemMName , faceName , linkName , nodeName ) ! ! Subroutine to handle a node, identify its links, and create elements ! Called recursively in a crawl through the node/link system ! character ( 64 ) :: subroutine_name = 'handle_thisnode' integer , intent ( in out ) :: lastElem2 , thisElem2 , lastElemM , thisElemM , lastFace , thisFace integer , intent ( in out ) :: thisNode , thisLink integer , intent ( in out ) :: elem2I (:,:), elemMI (:,:), faceI (:,:) integer , intent ( in out ) :: linkI (:,:) integer , target , intent ( in out ) :: nodeI (:,:) real , intent ( in out ) :: elem2R (:,:), elemMR (:,:), faceR (:,:) real , target , intent ( in ) :: linkR (:,:), nodeR (:,:) type ( string ), intent ( in out ) :: elem2Name (:), elemMName (:), faceName (:) type ( string ), intent ( in ) :: linkName (:), nodeName (:) integer :: ii , mm , jElem integer , pointer :: dlink real :: zDownstream integer , dimension ( upstream_face_per_elemM ) :: linkSet !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if ( nodeI ( thisNode , ni_node_type ) == nBCup ) then if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) then print * print * , subroutine_name , '----------------------------------------' print * , 'this node is nBCup ' , thisnode endif ! note that only one downstream link is allowed to an upstream BC if ( nodeI ( thisNode , ni_N_link_d ) > 1 ) then print * , 'error: only 1 downstream link allowed on an upstream BC node in ' , subroutine_name stop endif ! get the downstream link - note there can only be one at an upstream BC dlink => nodeI ( thisNode , ni_Mlink_d1 ) ! the face that was previously defined when the link was subdivided thisFace = linkI ( dlink , li_Mface_u ) ! store the ghost element elem2I ( thisElem2 , e2i_idx ) = thisElem2 elem2I ( thisElem2 , e2i_elem_type ) = eBCup elem2I ( thisElem2 , e2i_geometry ) = elem2I ( lastElem2 , e2i_geometry ) elem2I ( thisElem2 , e2i_roughness_type ) = elem2I ( lastElem2 , e2i_roughness_type ) elem2I ( thisElem2 , e2i_link_ID ) = dLink elem2I ( thisElem2 , e2i_link_Pos ) = nullvalueI elem2I ( thisElem2 , e2i_Mface_u ) = nullvalueI elem2I ( thisElem2 , e2i_Mface_d ) = thisFace elem2R ( thisElem2 , e2r_Length ) = elem2R ( lastElem2 , e2r_Length ) elem2R ( thisElem2 , e2r_Zbottom ) = nodeR ( thisNode , nr_Zbottom ) & + 0.5 * linkR ( dlink , lr_Slope ) & * elem2R ( lastElem2 , e2r_Length ) select case ( elem2I ( thisElem2 , e2i_geometry )) case ( eRectangular ) elem2R ( thisElem2 , e2r_Topwidth ) = elem2R ( lastElem2 , e2r_Topwidth ) elem2R ( thisElem2 , e2r_BreadthScale ) = elem2R ( lastElem2 , e2r_BreadthScale ) !faceR(thisFace,fr_Topwidth)    = elem2R(lastElem2,e2r_Topwidth) case default print * , 'error: case statement is incomplete in ' , subroutine_name stop end select ! use the node name for the ghost element elem2Name ( thisElem2 ) = nodeName ( thisNode ) faceR ( thisFace , fr_Zbottom ) = nodeR ( thisNode , nr_Zbottom ) faceI ( thisFace , fi_idx ) = thisFace faceI ( thisFace , fi_type ) = fBCup faceI ( thisFace , fi_Melem_u ) = thisElem2 faceI ( thisFace , fi_Melem_d ) = linkI ( dlink , li_Melem_u ) faceI ( thisFace , fi_etype_u ) = eBCup faceI ( thisFace , fi_etype_d ) = elem2I ( linkI ( dlink , li_Melem_u ), e2i_elem_type ) faceI ( thisFace , fi_jump_type ) = nullvalueI faceI ( thisFace , fi_link_ID ) = nullvalueI faceI ( thisFace , fi_link_Pos ) = nullvalueI faceI ( thisFace , fi_node_ID ) = thisNode faceName ( thisFace ) = nodeName ( thisNode ) nullify ( dlink ) ! set these values to null as the next step will not be connected thisNode = nullvalueI lastFace = nullvalueI lastElem2 = nullvalueI ! increment counters thisFace = thisFace + 1 thisElem2 = thisElem2 + 1 elseif ( nodeI ( thisNode , ni_node_type ) == nBCdn ) then print * print * , 'this node is nBCdn ' , thisnode print * , 'error: A downstream BC is not expected during the node cycling in ' , subroutine_name stop elseif ( nodeI ( thisNode , ni_node_type ) == nJ2 ) then if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) then print * print * , subroutine_name , '----------------------------------------' print * , 'this node is nJ2 ' , thisnode endif thisLink = nodeI ( thisNode , ni_Mlink_u1 ) linkI ( thisLink , li_assigned ) = setAssigned ( thisLink , li_assigned , lUnassigned , lAssigned , linkI ) !%  data that were unassigned for last face faceI ( lastFace , fi_Melem_u ) = thisElem2 faceI ( lastFace , fi_etype_u ) = linkI ( thisLink , li_link_type ) faceI ( lastFace , fi_node_ID ) = thisNode !faceI(lastFace,fi_idx)          = lastFace !faceI(lastFace,fi_Melem_d)      = lastElem2 !faceI(lastFace,fi_etype_d)      = elem2I(lastElem2,e2i_elem_type) !faceI(lastFace,fi_jump_type)    = nullvalueI !faceI(lastFace,fi_link_ID)      = nullvalueI !faceI(lastFace,fi_link_Pos)     = nullvalueI faceR ( lastface , fr_Zbottom ) = nodeR ( thisNode , nr_Zbottom ) faceI ( lastFace , fi_type ) = setFaceType & ( faceI ( lastFace , fi_etype_u ), faceI ( lastFace , fi_etype_d )) faceName ( lastFace ) = nodeName ( thisNode ) zDownstream = nodeR ( thisNode , nr_Zbottom ) call subdivide_link_going_upstream & ( lastElem2 , thisElem2 , lastFace , thisFace , thisLink , & elem2I , faceI , linkI , elem2R , faceR , linkR , nodeR , zDownstream ) !%  get the next upstream link thisNode = linkI ( thisLink , li_Mnode_u ) if ( thisNode > 0 ) then if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , 'Recursion: handle_thisnode ' , thisNode call handle_thisnode & ( lastElem2 , thisElem2 , lastElemM , thisElemM , & lastFace , thisFace , thisNode , thisLink , & elem2I , elemMI , faceI , linkI , nodeI , elem2R , elemMR , faceR , linkR , nodeR , & elem2Name , elemMName , faceName , linkName , nodeName ) endif elseif ( nodeI ( thisNode , ni_node_type ) == nJm ) then if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) then print * print * , subroutine_name , '----------------------------------------' print * , 'this node is nJm ' , thisnode !, nodeI(thisNode,ni_N_link_u) endif linkSet (:) = nullvalueI !%  assign the link ID for the links connected to the node linkSet ( 1 ) = nodeI ( thisNode , ni_Mlink_u1 ) do ii = 2 , 3 if ( upstream_face_per_elemM > ii - 1 ) then if ( nodeI ( thisNode , ni_N_link_u ) > ii - 1 ) then linkSet ( ii ) = nodeI ( thisNode , ni_MlinkUp ( ii )) endif endif enddo if ( upstream_face_per_elemM > 3 ) then print * , 'error: code not designed for upstream_face_per_elem > 3 in ' , subroutine_name STOP endif if ( nodeI ( thisNode , ni_N_link_u ) > 3 ) then print * , 'error: attempt to use more than 3 upstream links in ' , subroutine_name STOP endif print * , 'Junction with downstream of thisLink ' , thisLink !print *, 'linkSet ',linkSet(:) !print *, 'linkAss ',linkI(linkSet(1),li_assigned),linkI(linkSet(2),li_assigned) !%  Create the junction element we will use here and increment for the next(recursion) jElem = thisElemM lastElemM = thisElemM thisElemM = thisElemM + 1 elemMI ( jElem , eMi_idx ) = jElem elemMI ( jElem , eMi_elem_type ) = eJunctionChannel ! HACK - PIPE NOT HANDLED elemMI ( jElem , eMi_geometry ) = eRectangular ! HACK - NEED AN APPROACH TO ASSIGN elemMI ( jElem , eMi_nfaces ) = nodeI ( thisNode , ni_N_link_u ) + nodeI ( thisNode , ni_N_link_d ) elemMI ( jElem , eMi_nfaces_d ) = nodeI ( thisNode , ni_N_link_d ) elemMI ( jElem , eMi_nfaces_u ) = nodeI ( thisNode , ni_N_link_u ) elemMI ( jElem , eMi_roughness_type ) = nullvalueI elemMI ( jElem , eMi_node_ID ) = thisNode !elemMI(jElem,eMi_link_Pos)        = nullvalueI !%  the following assumes the topwidth and length are functions of branches elemMR ( jElem , eMr_Topwidth ) = zeroR ! do not use nullvalueR with geometry elemMR ( jElem , eMr_BreadthScale ) = zeroR ! do not use nullvalueR with geometry elemMR ( jElem , eMr_Length ) = zeroR ! do not use nullvalueR with geometry elemMR ( jElem , eMr_Zbottom ) = nodeR ( thisNode , nr_Zbottom ) !%  assign values from adjacent downstream elements/links do mm = 1 , nodeI ( thisNode , ni_N_link_d ) dlink => nodeI ( thisNode , ni_MlinkDn ( mm )) elemMR ( jElem , eMr_LengthDn ( mm )) = nodeR ( thisNode , nr_ElementLengthDn ( mm )) elemMR ( jElem , eMr_ZbottomDn ( mm )) = nodeR ( thisNode , nr_Zbottom ) & - 0.5 * elemMR ( jElem , eMr_LengthDn ( mm )) & * linkR ( dlink , lr_Slope ) select case ( elemMI ( jElem , eMi_geometry )) case ( eRectangular ) elemMR ( jElem , eMr_TopwidthDn ( mm )) = linkR ( dlink , lr_BreadthScale ) elemMR ( jElem , eMr_BreadthscaleDn ( mm )) = linkR ( dlink , lr_BreadthScale ) case default print * , 'elemMI(jElem,eMi_geometry) ' , elemMI ( jElem , eMi_geometry ) print * , 'error: case statement is incomplete in ' , subroutine_name stop end select end do elemMName ( JElem ) = nodeName ( thisNode ) nullify ( dlink ) !%  assign values from adjacent upstream elements/links do mm = 1 , nodeI ( thisNode , ni_N_link_u ) dlink => nodeI ( thisNode , ni_MlinkUp ( mm )) elemMR ( jElem , eMr_LengthUp ( mm )) = nodeR ( thisNode , nr_ElementLengthUp ( mm )) elemMR ( jElem , eMr_ZbottomUp ( mm )) = nodeR ( thisNode , nr_Zbottom ) & + 0.5 * elemMR ( jElem , eMr_LengthUp ( mm )) & * linkR ( dlink , lr_Slope ) select case ( elemMI ( jElem , eMi_geometry )) case ( eRectangular ) elemMR ( jElem , eMr_TopwidthUp ( mm )) = linkR ( dlink , lr_BreadthScale ) elemMR ( jElem , eMr_BreadthScaleUp ( mm )) = linkR ( dlink , lr_BreadthScale ) case default print * , 'error: case statement is incomplete in ' , subroutine_name stop end select end do nullify ( dlink ) !%  Check for downstream elements that have been assigned and store mappings do mm = 1 , nodeI ( thisNode , ni_N_link_d ) dlink => nodeI ( thisNode , ni_MlinkDn ( mm )) if ( linkI ( dlink , li_assigned ) == lAssigned ) then !print *, dlink elemMI ( jElem , eMi_MfaceDn ( mm )) = linkI ( dlink , li_Mface_u ) faceI ( linkI ( dlink , li_Mface_u ), fi_Melem_u ) = jElem faceI ( linkI ( dlink , li_Mface_u ), fi_etype_u ) = elemMI ( jElem , eMi_elem_type ) faceI ( linkI ( dlink , li_Mface_u ), fi_type ) = setFaceType & ( faceI ( linkI ( dlink , li_Mface_u ), fi_etype_u ), & faceI ( linkI ( dlink , li_Mface_u ), fi_etype_d ) ) endif enddo nullify ( dlink ) !%  remove already-assigned links from the set to be cycled do mm = 1 , upstream_face_per_elemM if ( linkSet ( mm ) > 0 ) then if ( linkI ( linkSet ( mm ), li_assigned ) == lAssigned ) then linkSet ( mm ) = 0 endif endif enddo !%  assign the faces around the junction for upstream faces do mm = 1 , upstream_face_per_elemM dlink => nodeI ( thisNode , ni_MlinkUp ( mm )) if ( linkSet ( mm ) > 0 ) then elemMI ( jElem , eMi_MfaceUp ( mm )) = thisFace faceI ( thisFace , fi_idx ) = thisFace faceI ( thisFace , fi_type ) = nullvalueI ! assigned later faceI ( thisFace , fi_Melem_u ) = nullvalueI ! upstream element assigned later, before subdivide_link faceI ( thisFace , fi_Melem_d ) = jElem faceI ( thisFace , fi_etype_u ) = linkI ( linkSet ( mm ), li_link_type ) faceI ( thisFace , fi_etype_d ) = eJunctionChannel faceI ( thisFace , fi_jump_type ) = nullvalueI faceI ( thisFace , fi_node_ID ) = thisNode faceI ( thisFace , fi_link_ID ) = linkSet ( mm ) faceI ( thisFace , fi_link_Pos ) = nullvalueI faceR ( thisFace , fr_Zbottom ) = nodeR ( thisNode , nr_Zbottom ) & + elemMR ( jElem , eMr_LengthUp ( mm )) & * linkR ( dlink , lr_Slope ) faceName ( thisFace ) = nodeName ( thisNode ) lastFace = thisFace thisFace = thisFace + 1 endif enddo nullify ( dlink ) !%  cycle through the links and subdivide do mm = 1 , upstream_face_per_elemM if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , 'cycle through linkSet ' , mm if ( linkSet ( mm ) > 0 ) then if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , 'linkSet(mm) found ' , mm lastElemM = jElem ! back to the element we created (otherise lastElemM has recursion) lastFace = elemMI ( jElem , eMi_MfaceUp ( mm )) faceI ( lastFace , fi_Melem_u ) = thisElem2 faceI ( lastFace , fi_type ) = setFaceType & ( faceI ( lastFace , fi_etype_u ), faceI ( lastFace , fi_etype_d )) zDownstream = faceR ( lastFace , fr_Zbottom ) call subdivide_link_going_upstream & ( lastElem2 , thisElem2 , lastFace , thisFace , linkSet ( mm ), & elem2I , faceI , linkI , elem2R , faceR , linkR , nodeR , zDownstream ) ! choose the next node to analyze thisNode = linkI ( linkSet ( mm ), li_Mnode_u ) ! note that the prior link has been assigned elements linkI ( linkSet ( mm ), li_assigned ) = setAssigned & ( linkSet ( mm ), li_assigned , lUnassigned , lAssigned , linkI ) linkSet ( mm ) = 0 if ( thisNode > 0 ) then if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , 'Recursion: handle_thisnode ' , thisNode call handle_thisnode & ( lastElem2 , thisElem2 , lastElemM , thisElemM , & lastFace , thisFace , thisNode , thisLink , & elem2I , elemMI , faceI , linkI , nodeI , elem2R , elemMR , faceR , linkR , nodeR , & elem2Name , elemMName , faceName , linkName , nodeName ) endif endif enddo else print * , 'error: Unknown value for ni_node_type of ' , ni_node_type , ' in ' , subroutine_name STOP endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine handle_thisnode !========================================================================== !========================================================================== ! subroutine subdivide_link_going_upstream & ( lastElem2 , thisElem2 , lastFace , thisFace , thisLink , & elem2I , faceI , linkI , elem2R , faceR , linkR , nodeR , zDownstream ) ! ! Subdivide thisLink from the linkI array into a number of smaller ! elements and store in the elemI array ! ! this assumes that the face data for thisFace has already been stored ! character ( 64 ) :: subroutine_name = 'subdivide_link_going_upstream' integer , intent ( in out ) :: lastElem2 , thisElem2 , lastFace , thisFace integer , intent ( in ) :: thisLink integer , intent ( in out ) :: elem2I (:,:), faceI (:,:) integer , intent ( in out ) :: linkI (:,:) real , intent ( in out ) :: elem2R (:,:), faceR (:,:) real , intent ( in ) :: linkR (:,:), nodeR (:,:) real , intent ( in ) :: zDownstream real :: zcenter , zface integer :: mm , pp !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !%  store the ID of the first (downstream) element in this link linkI ( thisLink , li_Melem_d ) = thisElem2 ! the new element is the 1st (downstream) linkI ( thisLink , li_Mface_d ) = lastFace ! the old face is the 1st !%  reference elevations at cell center and cell face zcenter = zDownstream - 0.5 * linkR ( thislink , lr_ElementLength ) * linkR ( thislink , lr_Slope ) zface = zDownstream do mm = 1 , linkI ( thisLink , li_N_element ) !%  store the elem info elem2I ( thisElem2 , e2i_idx ) = thisElem2 elem2I ( thisElem2 , e2i_elem_type ) = linkI ( thisLink , li_link_type ) elem2I ( thisElem2 , e2i_geometry ) = linkI ( thislink , li_geometry ) elem2I ( thisElem2 , e2i_roughness_type ) = linkI ( thisLink , li_roughness_type ) elem2I ( thisElem2 , e2i_link_ID ) = thisLink elem2I ( thisElem2 , e2i_link_Pos ) = mm elem2I ( thisElem2 , e2i_Mface_d ) = lastFace elem2I ( thisElem2 , e2i_Mface_u ) = thisFace elem2R ( thisElem2 , e2r_Length ) = linkR ( thislink , lr_ElementLength ) zcenter = zcenter + linkR ( thislink , lr_Slope ) * linkR ( thislink , lr_ElementLength ) zface = zface + linkR ( thislink , lr_Slope ) * linkR ( thislink , lr_ElementLength ) elem2R ( thisElem2 , e2r_Zbottom ) = zcenter select case ( linkI ( thisLink , li_geometry )) case ( lRectangular ) elem2R ( thisElem2 , e2r_Topwidth ) = linkR ( thisLink , lr_BreadthScale ) elem2R ( thisElem2 , e2r_BreadthScale ) = linkR ( thisLink , lr_BreadthScale ) !faceR(thisFace,fr_Topwidth)    = linkR(thisLink,lr_Breadth) case default print * , 'error: case statement is incomplete in ' , subroutine_name stop end select !%  store the face info on upstream face faceI ( thisFace , fi_idx ) = thisFace faceI ( thisFace , fi_Melem_u ) = thisElem2 + 1 faceI ( thisFace , fi_Melem_d ) = thisElem2 faceI ( thisFace , fi_etype_u ) = linkI ( thisLink , li_link_type ) faceI ( thisFace , fi_etype_d ) = linkI ( thisLink , li_link_type ) faceI ( thisFace , fi_jump_type ) = nullvalueI faceI ( thisFace , fi_node_ID ) = nullvalueI faceI ( thisFace , fi_link_ID ) = thisLink faceI ( thisFace , fi_link_Pos ) = mm faceR ( thisFace , fr_Zbottom ) = zface faceI ( thisFace , fi_type ) = setFaceType & ( faceI ( thisFace , fi_etype_u ), faceI ( thisFace , fi_etype_d )) lastElem2 = thisElem2 thisElem2 = thisElem2 + 1 ! ready to be assigned in next loop lastFace = thisFace thisFace = thisFace + 1 ! ready to be assigned in next loop enddo !%  store the ID of the last (upstream) element in this link linkI ( thisLink , li_Melem_u ) = lastElem2 ! the last link stored linkI ( thisLink , li_Mface_u ) = lastFace ! the last face stored !%  reset for the last face element mapping info - upstream is not yet known. faceI ( lastFace , fi_Melem_u ) = nullvalueI faceI ( lastFace , fi_etype_u ) = nullvalueI faceI ( lastFace , fi_node_ID ) = nullvalueI faceI ( lastFace , fi_link_ID ) = nullvalueI faceI ( lastFace , fi_link_Pos ) = nullvalueI if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine subdivide_link_going_upstream ! !========================================================================== !========================================================================== ! function setAssigned & ( thisX , assigned_idx , unassignedValue , assignedValue , arrayI ) & result ( f_result ) ! ! Change the assigned status or stop on error if the node or link is ! already assigned. ! character ( 64 ) :: subroutine_name = 'setAssigned' integer :: f_result integer , intent ( in ) :: thisX , assigned_idx , unassignedValue , assignedValue integer , intent ( in ) :: arrayI (:,:) ! !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if ( arrayI ( thisX , assigned_idx ) == unassignedValue ) then f_result = assignedValue else print * , thisX , assigned_idx , unassignedValue , assignedValue print * , arrayI ( thisX , assigned_idx ) print * , 'error: expected an unassigned node or link in ' , subroutine_name STOP endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end function setAssigned !========================================================================== !========================================================================== ! function setFaceType & ( up_elem_type , dn_elem_type ) & result ( f_result ) ! ! defines whether a face is a BC, channel, pipe or multiple connector ! character ( 64 ) :: subroutine_name = 'setFaceType' integer :: f_result integer , intent ( in ) :: up_elem_type , dn_elem_type !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if ( up_elem_type /= dn_elem_type ) then if ( up_elem_type == eBCup ) then f_result = fBCup elseif ( dn_elem_type == eBCdn ) then f_result = fBCdn else f_result = fMultiple endif else if ( up_elem_type == fChannel ) then f_result = fChannel elseif ( up_elem_type == fPipe ) then f_result = fPipe else print * , 'upstream element: ' , up_elem_type print * , 'dnstream element: ' , dn_elem_type print * , 'Unexpected if resolution ' STOP endif endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end function setFaceType ! !========================================================================== !========================================================================== ! subroutine link_shortening & ( linkLength , nodeR , nodeI , thisNode , niNlinkX , niMlinkX , & nrElementLengthX , element_nominal_length ) ! ! decrements the overall length of a link and adds a portion to ! a junction. ! ! niNlinkX = ni_N_link_u or ni_N_link_d  (index to number of up/down links) ! niMlinkX = ni_MlinkUp or ni_MlinkDn  (index to map to up/down links) ! nrElementLengthX = nr_ElementLengthUp or nr_ElementLengthDn character ( 64 ) :: subroutine_name = 'link_shortening' real , intent ( in out ) :: linkLength (:) real , target , intent ( in out ) :: nodeR (:,:) integer , target , intent ( in ) :: nodeI (:,:) integer , intent ( in ) :: thisNode , niNlinkX , nrElementLengthX (:), niMlinkX (:) real , intent ( in ) :: element_nominal_length (:) real :: delta ! local variable real , pointer :: elemLength integer , pointer :: tlink integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !%  iterate through the up/down (X) links at this node do mm = 1 , nodeI ( thisNode , niNlinkX ) !%  use pointers to simplify code elemLength => nodeR ( thisNode , nrElementLengthX ( mm )) ! elem length location tlink => nodeI ( thisNode , niMlinkX ( mm )) ! link index up or down if ( tlink > 0 ) then if ( linkLength ( tlink ) . LE . 1.5 * element_nominal_length ( tlink ) ) then !%  where there is only one element in a link delta = 0.25 * linkLength ( tlink ) else !%  where there are multiple elements in a link delta = 0.33 * element_nominal_length ( tlink ) endif !%  decrement link linkLength ( tlink ) = linkLength ( tlink ) - delta !%  store junction length in nodeR (target) elemLength = delta endif enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine link_shortening ! !========================================================================== ! END OF MODULE network_define !========================================================================== end module network_define","title":"network_define.f08 – SWMMengine","tags":"","loc":"sourcefile/network_define.f08.html"},{"text":"This file depends on sourcefile~~allocate_storage.f08~~EfferentGraph sourcefile~allocate_storage.f08 allocate_storage.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~allocate_storage.f08->sourcefile~array_index.f08 sourcefile~utility.f08 utility.f08 sourcefile~allocate_storage.f08->sourcefile~utility.f08 sourcefile~globals.f08 globals.f08 sourcefile~allocate_storage.f08->sourcefile~globals.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 var pansourcefileallocate_storagef08EfferentGraph = svgPanZoom('#sourcefileallocate_storagef08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~allocate_storage.f08~~AfferentGraph sourcefile~allocate_storage.f08 allocate_storage.f08 sourcefile~case_simple_channel.f08 case_simple_channel.f08 sourcefile~case_simple_channel.f08->sourcefile~allocate_storage.f08 sourcefile~case_y_channel.f08 case_y_channel.f08 sourcefile~case_y_channel.f08->sourcefile~allocate_storage.f08 sourcefile~network_define.f08 network_define.f08 sourcefile~network_define.f08->sourcefile~allocate_storage.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~allocate_storage.f08 sourcefile~main.f08->sourcefile~network_define.f08 sourcefile~test_cases.f08 test_cases.f08 sourcefile~main.f08->sourcefile~test_cases.f08 sourcefile~test_cases.f08->sourcefile~case_simple_channel.f08 sourcefile~test_cases.f08->sourcefile~case_y_channel.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules allocate_storage Source Code allocate_storage.f08 Source Code ! module allocate_storage ! ! This has all the large array allocation. ! The only other allocation should be in boundary conditions (module bc) ! !========================================================================== ! module allocate_storage ! ! all the top-level storage should be allocated in this module ! use array_index use globals use utility implicit none private public :: allocate_linknode_storage public :: allocate_data_storage integer , private :: allocation_status character ( len = 99 ), private :: emsg integer , private :: debuglevel = 0 contains ! !============================================================================ !============================================================================ ! subroutine allocate_linknode_storage & ( linkR , nodeR , linkI , nodeI , linkYN , nodeYN , linkName , nodeName ) ! ! allocates the link and node storage used for the coarse representation ! of the network connectivity ! character ( 64 ) :: subroutine_name = 'allocate_linknode_storage' integer , dimension (:,:), allocatable , target , intent ( out ) :: linkI integer , dimension (:,:), allocatable , target , intent ( out ) :: nodeI real , dimension (:,:), allocatable , target , intent ( out ) :: linkR real , dimension (:,:), allocatable , target , intent ( out ) :: nodeR logical , dimension (:,:), allocatable , target , intent ( out ) :: linkYN logical , dimension (:,:), allocatable , target , intent ( out ) :: nodeYN type ( string ), dimension (:), allocatable , target , intent ( out ) :: linkName type ( string ), dimension (:), allocatable , target , intent ( out ) :: nodeName !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name allocate ( nodeI ( N_node , ni_idx_max ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) nodeI (:,:) = nullvalueI allocate ( linkI ( N_link , li_idx_max ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) linkI (:,:) = nullvalueI allocate ( nodeR ( N_node , nr_idx_max ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) nodeR (:,:) = nullvalueR allocate ( linkR ( N_link , lr_idx_max ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) linkR (:,:) = nullvalueR allocate ( nodeYN ( N_node , nYN_idx_max ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) nodeYN (:,:) = nullvalueL allocate ( linkYN ( N_link , lYN_idx_max ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) linkYN (:,:) = nullvalueL allocate ( nodeName ( N_node ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) allocate ( linkName ( N_link ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine allocate_linknode_storage ! !========================================================================== !========================================================================== ! subroutine allocate_data_storage & ( elem2R , elemMR , faceR , elem2I , elemMI , faceI , elem2YN , elemMYN , faceYN , elem2Name , elemMname , faceName ) ! ! allocation of the element and face arrays for the high-resolution network ! All storage includes an extra dummy space (e.g. N_elem+1) to allow for ! where statements that remain in bounds during mapping. ! character ( 64 ) :: subroutine_name = 'allocate_data_storage' real , dimension (:,:), allocatable , target , intent ( out ) :: elem2R ! real data for elements integer , dimension (:,:), allocatable , target , intent ( out ) :: elem2I ! integer data for elements logical , dimension (:,:), allocatable , target , intent ( out ) :: elem2YN ! logical data for elements real , dimension (:,:), allocatable , target , intent ( out ) :: elemMR ! real data for elements integer , dimension (:,:), allocatable , target , intent ( out ) :: elemMI ! integer data for elements logical , dimension (:,:), allocatable , target , intent ( out ) :: elemMYN ! logical data for elements real , dimension (:,:), allocatable , target , intent ( out ) :: faceR ! real data for faces integer , dimension (:,:), allocatable , target , intent ( out ) :: faceI ! integer data for faces logical , dimension (:,:), allocatable , target , intent ( out ) :: faceYN ! logical data for faces type ( string ), dimension (:), allocatable , target , intent ( out ) :: elemMName , elem2Name , faceName !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name allocate ( elem2YN ( first_elem2_index : first_elem2_index + N_elem2 , e2YN_idx_max ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) elem2YN (:,:) = . false . allocate ( elemMYN ( first_elemM_index : first_elemM_index + N_elemM , eMYN_idx_max ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) elemMYN (:,:) = . false . allocate ( elem2R ( first_elem2_index : first_elem2_index + N_elem2 , e2r_idx_max ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) elem2R (:,:) = 0.0 allocate ( elemMR ( first_elemM_index : first_elemM_index + N_elemM , eMr_idx_max ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) elemMR (:,:) = 0.0 allocate ( elem2I ( first_elem2_index : first_elem2_index + N_elem2 , e2i_idx_max ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) elem2I (:,:) = 0 allocate ( elemMI ( first_elemM_index : first_elemM_index + N_elemM , eMi_idx_max ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) elemMI (:,:) = 0 allocate ( faceYN ( first_face_index : first_face_index + N_face , fYN_idx_max ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) faceYN (:,:) = . false . allocate ( faceR ( first_face_index : first_face_index + N_face , fr_idx_max ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) faceR (:,:) = 0.0 allocate ( faceI ( first_face_index : first_face_index + N_face , fi_idx_max ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) faceI (:,:) = 0 allocate ( elem2Name ( first_elem2_index : first_elem2_index + N_elem2 ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) allocate ( elemMName ( first_elemM_index : first_elemM_index + N_elemM ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) allocate ( faceName ( first_face_index : first_face_index + N_face ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine allocate_data_storage ! !========================================================================== ! END OF MODULE allocate_storage !========================================================================== end module allocate_storage","title":"allocate_storage.f08 – SWMMengine","tags":"","loc":"sourcefile/allocate_storage.f08.html"},{"text":"This file depends on sourcefile~~explicit_euler.f08~~EfferentGraph sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~globals.f08 globals.f08 sourcefile~explicit_euler.f08->sourcefile~globals.f08 sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~explicit_euler.f08->sourcefile~element_geometry.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~explicit_euler.f08->sourcefile~setting_definition.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~explicit_euler.f08->sourcefile~array_index.f08 sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~explicit_euler.f08->sourcefile~element_dynamics.f08 sourcefile~face_values.f08 face_values.f08 sourcefile~explicit_euler.f08->sourcefile~face_values.f08 sourcefile~adjustments.f08 adjustments.f08 sourcefile~explicit_euler.f08->sourcefile~adjustments.f08 sourcefile~bc.f08 bc.f08 sourcefile~explicit_euler.f08->sourcefile~bc.f08 sourcefile~utility.f08 utility.f08 sourcefile~explicit_euler.f08->sourcefile~utility.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~explicit_euler.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~element_geometry.f08->sourcefile~globals.f08 sourcefile~element_geometry.f08->sourcefile~setting_definition.f08 sourcefile~element_geometry.f08->sourcefile~array_index.f08 sourcefile~element_geometry.f08->sourcefile~adjustments.f08 sourcefile~element_geometry.f08->sourcefile~bc.f08 sourcefile~element_geometry.f08->sourcefile~utility.f08 sourcefile~element_geometry.f08->sourcefile~data_keys.f08 sourcefile~junction.f08 junction.f08 sourcefile~element_geometry.f08->sourcefile~junction.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~element_dynamics.f08->sourcefile~globals.f08 sourcefile~element_dynamics.f08->sourcefile~setting_definition.f08 sourcefile~element_dynamics.f08->sourcefile~array_index.f08 sourcefile~element_dynamics.f08->sourcefile~adjustments.f08 sourcefile~element_dynamics.f08->sourcefile~bc.f08 sourcefile~element_dynamics.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08->sourcefile~data_keys.f08 sourcefile~element_dynamics.f08->sourcefile~junction.f08 sourcefile~face_values.f08->sourcefile~globals.f08 sourcefile~face_values.f08->sourcefile~setting_definition.f08 sourcefile~face_values.f08->sourcefile~array_index.f08 sourcefile~face_values.f08->sourcefile~adjustments.f08 sourcefile~face_values.f08->sourcefile~bc.f08 sourcefile~face_values.f08->sourcefile~utility.f08 sourcefile~face_values.f08->sourcefile~data_keys.f08 sourcefile~adjustments.f08->sourcefile~globals.f08 sourcefile~adjustments.f08->sourcefile~setting_definition.f08 sourcefile~adjustments.f08->sourcefile~array_index.f08 sourcefile~adjustments.f08->sourcefile~utility.f08 sourcefile~adjustments.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~junction.f08->sourcefile~globals.f08 sourcefile~junction.f08->sourcefile~setting_definition.f08 sourcefile~junction.f08->sourcefile~array_index.f08 sourcefile~junction.f08->sourcefile~utility.f08 sourcefile~junction.f08->sourcefile~data_keys.f08 var pansourcefileexplicit_eulerf08EfferentGraph = svgPanZoom('#sourcefileexplicit_eulerf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~explicit_euler.f08~~AfferentGraph sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~time_loop.f08->sourcefile~explicit_euler.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~time_loop.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules explicit_euler Source Code explicit_euler.f08 Source Code !========================================================================== ! module explicit_euler ! use adjustments use array_index use bc use data_keys use element_dynamics use element_geometry use face_values use globals use setting_definition use utility implicit none private public :: explicit_euler_advance public :: explicit_test_advance integer , parameter :: idummy = 0 integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine explicit_test_advance & ( elem2R , elem2I , elem2YN , & elemMR , elemMI , elemMYN , & faceR , faceI , faceYN , & bcdataDn , bcdataUp , thistime , dt ) character ( 64 ) :: subroutine_name = 'explicit_euler_advance' real , target , intent ( in out ) :: elem2R (:,:), elemMR (:,:), faceR (:,:) integer , target , intent ( in out ) :: elem2I (:,:), elemMI (:,:), faceI (:,:) logical , target , intent ( in out ) :: elem2YN (:,:), elemMYN (:,:), faceYN (:,:) type ( bcType ), intent ( in out ) :: bcdataDn (:), bcdataUp (:) real , intent ( in ) :: thistime , dt integer :: e2r_Volume_new , e2r_Velocity_new , eMr_Volume_new , eMr_Velocity_new real , pointer :: newvolume (:), newvelocity (:) real , pointer :: volume (:), velocity (:), eta (:) real , pointer :: depth (:), zbottom (:), perimeter (:), mn (:), rh (:), area (:) real , pointer :: timesUp (:), timesDn (:), breadth (:), length (:), flowrate (:) real , pointer :: Qface (:), Vup (:), Vdn (:), Aup (:), Adn (:), Eup (:), Edn (:) ! TEST 20190102 ! real,  pointer :: newarea(:), newflowrate(:) integer , pointer :: fup (:), fdn (:), elemDn (:), elemUp (:), elemUp2 (:) integer :: fitmp !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name ! set indexes for temporary space e2r_Volume_new = e2r_Temp ( next_e2r_temparray ) next_e2r_temparray = utility_advance_temp_array ( next_e2r_temparray , e2r_n_temp ) e2r_Velocity_new = e2r_Temp ( next_e2r_temparray ) next_e2r_temparray = utility_advance_temp_array ( next_e2r_temparray , e2r_n_temp ) fitmp = fi_Temp ( next_fi_temparray ) next_fi_temparray = utility_advance_temp_array ( next_fi_temparray , fi_n_temp ) eMr_Volume_new = 0 eMr_Velocity_new = 0 !TEST 20190102 newvolume => elem2R (:, e2r_Volume_new ) newvelocity => elem2R (:, e2r_Velocity_new ) !  newarea    => elem2R(:,e2r_Volume_new) ! newflowrate => elem2R(:,e2r_Velocity_new) elemUp2 => faceI (:, fitmp ) volume => elem2R (:, e2r_Volume ) velocity => elem2R (:, e2r_Velocity ) flowrate => elem2R (:, e2r_Flowrate ) eta => elem2R (:, e2r_Eta ) mn => elem2R (:, e2r_Roughness ) rh => elem2R (:, e2r_HydRadius ) area => elem2R (:, e2r_Area ) depth => elem2R (:, e2r_HydDepth ) perimeter => elem2R (:, e2r_Perimeter ) zbottom => elem2R (:, e2r_Zbottom ) length => elem2R (:, e2r_Length ) breadth => elem2R (:, e2r_BreadthScale ) timesUp => elem2R (:, e2r_Timescale_u ) timesDn => elem2R (:, e2r_Timescale_d ) Qface => faceR (:, fr_Flowrate ) Vup => faceR (:, fr_Velocity_u ) Vdn => faceR (:, fr_Velocity_d ) Aup => faceR (:, fr_Area_u ) Adn => faceR (:, fr_Area_d ) Eup => faceR (:, fr_Eta_u ) Edn => faceR (:, fr_Eta_d ) fup => elem2I (:, e2i_Mface_u ) fdn => elem2I (:, e2i_Mface_d ) !% using free surface as gA deta/dx ! where (elem2I(:,e2I_elem_type) == eChannel) !    newvolume = volume + dt * (Qface(fup) - Qface(fdn)) !    newvelocity = (oneR / newvolume) & !                * ( & !                     velocity*volume & !                    + dt * ( Qface(fup) * Vdn(fup) - Qface(fdn) * Vup(fdn)              & !                            + grav * area * (Edn(fup) - Eup(fdn))                       & !                            - grav * volume * (mn**2) * (velocity**2) / (rh**(4.0/3.0)) & !                            ) & !                  ) ! endwhere ! !% using free surface as T00 where ( elem2I (:, e2I_elem_type ) == eChannel ) newvolume = volume + dt * ( Qface ( fup ) - Qface ( fdn )) !    newvelocity = (oneR / newvolume) & !                * ( & !                     velocity*volume & !                    + dt * ( Qface(fup) * Vdn(fup) - Qface(fdn) * Vup(fdn)              & !                            + grav * ( Adn(fup)*Edn(fup) - Aup(fdn)*Eup(fdn))           & !                            + grav * ( Aup(fdn) - Adn(fup) ) * eta                      & !                            - grav * volume * (mn**2) * (velocity**2) / (rh**(4.0/3.0)) & !                            ) & !                  ) newvelocity = ( oneR / ( newvolume * ( oneR + dt * grav * ( mn ** 2 ) * velocity / ( rh ** ( 4.0 / 3.0 )) ))) & * ( & velocity * volume & + dt * ( Qface ( fup ) * Vdn ( fup ) - Qface ( fdn ) * Vup ( fdn ) & + grav * ( Adn ( fup ) * Edn ( fup ) - Aup ( fdn ) * Eup ( fdn )) & + grav * ( Aup ( fdn ) - Adn ( fup ) ) * eta & ) & ) endwhere ! AREA/FLOWRATE TEST 20180102 ! print *, 'flow start :',flowrate(1:3) ! print *, 'qface start:',Qface(1:3) ! print *, 'Edn start:',Edn(1:3) ! print *, 'Eup start:',Eup(1:3) ! where (elem2I(:,e2I_elem_type) == eChannel) !    newarea = area + dt * (Qface(fup) - Qface(fdn)) / length   ! now area !    ! now flowrate !    newflowrate =  flowrate + & !                ( ( & !                    + dt * ( Qface(fup) * Vdn(fup) - Qface(fdn) * Vup(fdn)              & !                            + grav * ( Adn(fup)*Edn(fup) - Aup(fdn)*Eup(fdn))           & !                            + grav * ( Aup(fdn) - Adn(fup) ) * eta                      & !                            ) & !                  ) / length) - dt * grav * (mn**2) * (flowrate**2) / ( area * rh**(4.0/3.0)) ! endwhere ! ! where (elem2I(:,e2I_elem_type) == eChannel) !    newarea = area + dt * (Qface(fup) - Qface(fdn)) / length   ! now area !    ! now flowrate !    newflowrate =  (flowrate + & !                ( ( & !                    + dt * ( Qface(fup) * Vdn(fup) - Qface(fdn) * Vup(fdn)              & !                            + grav * ( Adn(fup)*Edn(fup) - Aup(fdn)*Eup(fdn))           & !                            + grav * ( Aup(fdn) - Adn(fup) ) * eta                      & !                            ) & !                  ) / length)) / (1 + dt * grav * (mn**2) * (flowrate) / ( area * rh**(4.0/3.0))  ) ! endwhere ! ! print *, 'new flow  ',newflowrate(1:3) ! !print *, 'qface:    ',Qface(size(Qface)-3:size(Qface)) ! !print *, 'flowrate: ',flowrate(size(flowrate)-3:size(flowrate)) ! where (elem2I(:,e2I_elem_type) == eChannel) !    newarea = dt * ( Qface(fup) * Vdn(fup) - Qface(fdn) * Vup(fdn) ) / length ! endwhere ! print *, '1 line    ',newarea(1:3) ! where (elem2I(:,e2I_elem_type) == eChannel) !   ! newarea = dt * grav * ( Adn(fup)*Edn(fup) - Aup(fdn)*Eup(fdn)) / length !   newarea = Aup(fdn)*Eup(fdn) ! endwhere !! print *, '2 line    ',newarea(1:3) ! print *, fup(1:3) ! print *, fdn(1:3) ! print *, 'Adn ',Adn(1:3) ! print *, 'Aup ',Aup(1:3) ! print *, 'Edn ',Edn(1:3) ! print *, 'Eup ',Eup(1:3) !! print *, Adn(fup(1:3)) !! print *, Edn(fup(1:3)) !! print *, Aup(fdn(1:3)) !! print *, Eup(fdn(1:3)) !! print *, fdn(1:3) !! print *, fup(1:3) !stop ! where (elem2I(:,e2I_elem_type) == eChannel) !    newarea = dt * grav * ( Aup(fdn) - Adn(fup) ) * eta  / length ! endwhere ! print *, '3 line    ',newarea(1:3) ! where (elem2I(:,e2I_elem_type) == eChannel) !    newarea = dt * grav * area * (mn**2) * (velocity**2) / (rh**(4.0/3.0)) ! endwhere ! print *, '4 line    ',newarea(1:3) ! print *, 'new flow  ',newflowrate(1:3) ! ! stop ! !! AREA/FLOWRATE TEST 20180102 ! !%  using free surface as T10 ! where (elem2I(:,e2I_elem_type) == eChannel) !    newvolume = volume + dt * (Qface(fup) - Qface(fdn)) !    newvelocity = (oneR / newvolume) & !                * ( & !                     velocity*volume & !                    + dt * ( Qface(fup) * Vdn(fup) - Qface(fdn) * Vup(fdn)              & !                            + onehalfR * grav * ( Adn(fup)*Edn(fup) - Aup(fdn)*Eup(fdn) )           & !                            + onehalfR * grav * ( Aup(fdn)*Edn(fup) - Adn(fup)*Eup(fdn) ) & !                            - grav * volume * (mn**2) * (velocity**2) / (rh**(4.0/3.0)) & !                            ) & !                  ) ! endwhere ! !% update geometry and dynamics on element where ( elem2I (:, e2I_elem_type ) == eChannel ) volume = newvolume velocity = newvelocity area = volume / length flowrate = velocity * area depth = area / breadth perimeter = twoR * depth + breadth eta = depth + zbottom rh = area / perimeter !timesUp   = -onehalfR * length / (velocity - sqrt(grav * depth)) !timesDn   = +onehalfR * length / (velocity + sqrt(grav * depth)) endwhere !! AREA/FLOWRATE TEST 20180102 ! where (elem2I(:,e2I_elem_type) == eChannel) !    volume    = newarea * length !test !    velocity  = newflowrate / newarea !    area      = newarea !renaming !    flowrate  = newflowrate !    depth     = area / breadth !    perimeter = twoR * depth + breadth !    eta       = depth + zbottom !    rh        = area / perimeter !    !timesUp   = -onehalfR * length / (velocity - sqrt(grav * depth)) !    !timesDn   = +onehalfR * length / (velocity + sqrt(grav * depth)) ! endwhere !!! AREA/FLOWRATE TEST 20180102 ! BC updates !call bc_applied_onelement (elem2R, bcdataDn, bcdataUp, thistime+dt, bc_category_elevation,idummy) call bc_applied_onelement ( elem2R , bcdataDn , bcdataUp , thistime + dt , bc_category_inflowrate , e2r_Velocity ) call bc_applied_onelement ( elem2R , bcdataDn , bcdataUp , thistime + dt , bc_category_elevation , idummy ) ! print *, 'after bc on element' ! print *, 'new flow  ',flowrate(size(flowrate)-3:size(flowrate)) ! print *, 'Qface     ',Qface(size(Qface)-3:size(Qface)) ! call test_face_update ( elem2R , elem2I , faceR , faceI , elemUp2 ) ! print *, 'after face update' ! print *, 'new flow  ',flowrate(size(flowrate)-3:size(flowrate)) ! print *, 'Qface     ',Qface(size(Qface)-3:size(Qface)) ! call quadratic_face_update (elem2R, elem2I, faceR, faceI, elemUp2) ! BC applied on face call bc_applied_onface ( faceR , faceI , elem2R , elem2I , bcdataDn , bcdataUp , e2r_Velocity_new , thistime + dt ) ! print *, 'after bc on face' ! print *, 'new flow  ',flowrate(size(flowrate)-3:size(flowrate)) ! print *, 'Qface     ',Qface(size(Qface)-3:size(Qface)) ! BC extrapolated - moved into bc_applied_onface ! call bc_face_othervalues (faceR, faceI, elem2R, bcdataDn) ! call bc_face_othervalues (faceR, faceI, elem2R, bcdataUp) if ( setting % Method % AdjustVshapedFlowrate % Apply ) then call adjust_Vshaped_flowrate ( elem2R , faceR , elem2I , elem2YN ) endif ! set velocities and upstream values on faces (without hydraulic jump) call adjust_face_dynamic_limits & ( faceR , faceI , newvolume , newvolume , & ( ( faceI (:, fi_etype_u ) == eChannel ) . and . ( faceI (:, fi_etype_d ) == eChannel ) ), . false . ) !call bc_applied (faceR, bcdataDn, bcdataUp, thistime+dt) !print *, elem2R(elemDn ,e2r_Flowrate) !print *, faceR(:,fr_Flowrate) !print *, faceR(:,fr_Area_u) !print *, faceR(:,fr_Eta_u) !print *, faceR(:,fr_Velocity_u) !print *, elem2R(elemUp ,e2r_Flowrate) !print *, elem2R(elemUp2,e2r_Flowrate) ! reset temporary data space elem2R (:, e2r_Volume_new ) = nullvalueR elem2R (:, e2r_Velocity_new ) = nullvalueR next_e2r_temparray = next_e2r_temparray - 2 next_fi_temparray = next_fi_temparray - 1 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine explicit_test_advance ! !========================================================================== !========================================================================== ! subroutine test_face_update & ( elem2R , elem2I , faceR , faceI , elemUp2 ) character ( 64 ) :: subroutine_name = 'test_face_update' real , target , intent ( in out ) :: elem2R (:,:), faceR (:,:) integer , target , intent ( in out ) :: elem2I (:,:), faceI (:,:) integer , intent ( in out ) :: elemUp2 (:) integer , pointer :: elemUp (:), elemDn (:) real , pointer :: tscaleUp (:), tscaleDn (:), wavespeed (:) integer :: e2r_wavespeed !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name e2r_wavespeed = e2r_Temp ( next_e2r_temparray ) next_e2r_temparray = utility_advance_temp_array ( next_e2r_temparray , e2r_n_temp ) !% compute wavespeed wavespeed => elem2R (:, e2r_wavespeed ) wavespeed = sqrt ( grav * elem2R (:, e2r_HydDepth )) tscaleUp => elem2R (:, e2r_Timescale_u ) tscaleDn => elem2R (:, e2r_Timescale_d ) tscaleUp = + ( onehalfR * elem2R (:, e2r_Length ) ) / ( wavespeed - elem2R (:, e2r_Velocity )) tscaleDn = + ( onehalfR * elem2R (:, e2r_Length ) ) / ( wavespeed + elem2R (:, e2r_Velocity )) where ( tscaleUp < zeroR ) tscaleUp = setting % Limiter % Timescale % Maximum endwhere where ( tscaleDn < zeroR ) tscaleDn = setting % Limiter % Timescale % Maximum endwhere where ( tscaleUp < setting % Limiter % Timescale % Minimum ) tscaleUp = setting % Limiter % Timescale % Minimum endwhere where ( tscaleDn < setting % Limiter % Timescale % Minimum ) tscaleDn = setting % Limiter % Timescale % Minimum endwhere where ( tscaleUp > setting % Limiter % Timescale % Maximum ) tscaleUp = setting % Limiter % Timescale % Maximum endwhere where ( tscaleDn > setting % Limiter % Timescale % Maximum ) tscaleDn = setting % Limiter % Timescale % Maximum endwhere !wavespeed = tscaleUp + tscaleDn !tscaleUp = tscaleUp/wavespeed !tscaleDn = tscaleDn/wavespeed !% get map to upstream for a quadratic interp elemUp => faceI (:, fi_Melem_u ) elemDn => faceI (:, fi_Melem_d ) where ( elemUp > size ( elemUp )) elemUp = size ( elemUp ) endwhere elemUp2 = elemUp where (( faceI (:, fi_etype_u ) == fChannel ) . and . ( faceI (:, fi_etype_d ) == fChannel )) elemUp2 = elem2I ( elemUp , e2i_Mface_u ) endwhere where ( elemUp2 > size ( elemUp2 )) elemUp2 = size ( elemUp2 ) endwhere where ( elemUp2 < 1 ) elemUp2 = 1 endwhere elemUp2 = faceI ( elemUp2 , fi_Melem_u ) where ( elemUp2 > size ( elemUp2 )) elemUp2 = size ( elemUp2 ) endwhere ! print *, elemDn ! print *, elemUp ! print *, elemUp2 ! print *, size(faceI,1), size(elemDn), size(elemUp), size(elemUp2) where ( ( faceI (:, fi_etype_u ) == fChannel ) . and . ( faceI (:, fi_etype_d ) == fChannel )) faceR (:, fr_Flowrate ) = 0.375 * elem2R ( elemDn , e2r_Flowrate ) & + 0.75 * elem2R ( elemUp , e2r_Flowrate ) & - 0.125 * elem2R ( elemUp2 , e2r_Flowrate ) !    faceR(:,fr_Flowrate)   = 0.5 * elem2R(elemDn  ,e2r_Flowrate) & !                           + 0.5  * elem2R(elemUp ,e2r_Flowrate) !    faceR(:,fr_Flowrate) = (    tscaleDn(elemUp) *  elem2R(elemDn ,e2r_Flowrate)  & !                             +  tscaleUp(elemDn) *  elem2R(elemUp ,e2r_Flowrate)) & !                             /( tscaleDn(elemUp) + tscaleUp(elemDn)) faceR (:, fr_Velocity_d ) = 0.375 * elem2R ( elemDn , e2r_Velocity ) & + 0.75 * elem2R ( elemUp , e2r_Velocity ) & - 0.125 * elem2R ( elemUp2 , e2r_Velocity ) !    faceR(:,fr_Velocity_d) = 0.5 * elem2R(elemDn ,e2r_Velocity) & !                           + 0.5  * elem2R(elemUp ,e2r_Velocity) !    faceR(:,fr_Velocity_d) = (  tscaleDn(elemDn) *  elem2R(elemDn ,e2r_Velocity)  & !                              + tscaleUp(elemUp) *  elem2R(elemUp ,e2r_Velocity)) & !                             /( tscaleDn(elemUp) + tscaleUp(elemDn)) faceR (:, fr_Area_d ) = 0.375 * elem2R ( elemDn , e2r_Area ) & + 0.75 * elem2R ( elemUp , e2r_Area ) & - 0.125 * elem2R ( elemUp2 , e2r_Area ) !    faceR(:,fr_Area_d)     = 0.5 * elem2R(elemDn ,e2r_Area) & !                           + 0.5  * elem2R(elemUp ,e2r_Area) !    faceR(:,fr_Area_d)   =  (   tscaleDn(elemUp) *  elem2R(elemDn ,e2r_Area)  & !                             +  tscaleUp(elemDn) *  elem2R(elemUp ,e2r_Area) ) & !                             /( tscaleDn(elemUp) + tscaleUp(elemDn)) !faceR(:,fr_Eta_d)      = 0.375 * elem2R(elemDn ,e2r_Eta) & !                       + 0.75  * elem2R(elemUp ,e2r_Eta) & !                       - 0.125 * elem2R(elemUp2,e2r_Eta) faceR (:, fr_Eta_d ) = 0.5 * elem2R ( elemDn , e2r_Eta ) & + 0.5 * elem2R ( elemUp , e2r_Eta ) faceR (:, fr_Topwidth ) = 0.375 * elem2R ( elemDn , e2r_Topwidth ) & + 0.75 * elem2R ( elemUp , e2r_Topwidth ) & - 0.125 * elem2R ( elemUp2 , e2r_Topwidth ) !     faceR(:,fr_Topwidth)   = 0.5 * elem2R(elemDn ,e2r_Topwidth) & !                           + 0.5  * elem2R(elemUp ,e2r_Topwidth) !    faceR(:,fr_Topwidth)  = (   tscaleDn(elemUp) *  elem2R(elemDn ,e2r_Topwidth)   & !                             +  tscaleUp(elemDn) *  elem2R(elemUp ,e2r_Topwidth) ) & !                             /( tscaleDn(elemUp) + tscaleUp(elemDn)) faceR (:, fr_Eta_u ) = faceR (:, fr_Eta_d ) faceR (:, fr_Area_u ) = faceR (:, fr_Area_d ) faceR (:, fr_Velocity_u ) = faceR (:, fr_Velocity_d ) endwhere !% reset temporary space elem2R (:, e2r_wavespeed ) = nullvalueR next_e2r_temparray = next_e2r_temparray - 1 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine test_face_update ! !========================================================================== !========================================================================== ! subroutine quadratic_face_update & ( elem2R , elem2I , faceR , faceI , elemUp2 ) character ( 64 ) :: subroutine_name = 'quadratic_face_update' real , target , intent ( in out ) :: elem2R (:,:), faceR (:,:) integer , target , intent ( in out ) :: elem2I (:,:), faceI (:,:) integer , intent ( in out ) :: elemUp2 (:) integer , pointer :: elemUp (:), elemDn (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name ! get map to upstream for a quadratic interp elemUp => faceI (:, fi_Melem_u ) elemDn => faceI (:, fi_Melem_d ) where ( elemUp > size ( elemUp )) elemUp = size ( elemUp ) endwhere elemUp2 = elemUp where (( faceI (:, fi_etype_u ) == fChannel ) . and . ( faceI (:, fi_etype_d ) == fChannel )) elemUp2 = elem2I ( elemUp , e2i_Mface_u ) endwhere where ( elemUp2 > size ( elemUp2 )) elemUp2 = size ( elemUp2 ) endwhere where ( elemUp2 < 1 ) elemUp2 = 1 endwhere elemUp2 = faceI ( elemUp2 , fi_Melem_u ) where ( elemUp2 > size ( elemUp2 )) elemUp2 = size ( elemUp2 ) endwhere ! print *, elemDn ! print *, elemUp ! print *, elemUp2 ! print *, size(faceI,1), size(elemDn), size(elemUp), size(elemUp2) where ( ( faceI (:, fi_etype_u ) == fChannel ) . and . ( faceI (:, fi_etype_d ) == fChannel )) faceR (:, fr_Flowrate ) = 0.375 * elem2R ( elemDn , e2r_Flowrate ) & + 0.75 * elem2R ( elemUp , e2r_Flowrate ) & - 0.125 * elem2R ( elemUp2 , e2r_Flowrate ) faceR (:, fr_Velocity_d ) = 0.375 * elem2R ( elemDn , e2r_Velocity ) & + 0.75 * elem2R ( elemUp , e2r_Velocity ) & - 0.125 * elem2R ( elemUp2 , e2r_Velocity ) faceR (:, fr_Area_d ) = 0.375 * elem2R ( elemDn , e2r_Area ) & + 0.75 * elem2R ( elemUp , e2r_Area ) & - 0.125 * elem2R ( elemUp2 , e2r_Area ) !faceR(:,fr_Eta_d)      = 0.375 * elem2R(elemDn ,e2r_Eta) & !                       + 0.75  * elem2R(elemUp ,e2r_Eta) & !                       - 0.125 * elem2R(elemUp2,e2r_Eta) faceR (:, fr_Eta_d ) = 0.5 * elem2R ( elemDn , e2r_Eta ) & + 0.5 * elem2R ( elemUp , e2r_Eta ) faceR (:, fr_Topwidth ) = 0.375 * elem2R ( elemDn , e2r_Topwidth ) & + 0.75 * elem2R ( elemUp , e2r_Topwidth ) & - 0.125 * elem2R ( elemUp2 , e2r_Topwidth ) faceR (:, fr_Eta_u ) = faceR (:, fr_Eta_d ) faceR (:, fr_Area_u ) = faceR (:, fr_Area_d ) faceR (:, fr_Velocity_u ) = faceR (:, fr_Velocity_d ) endwhere if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine quadratic_face_update ! !========================================================================== !========================================================================== ! subroutine explicit_euler_advance & ( elem2R , elem2I , elem2YN , & elemMR , elemMI , elemMYN , & faceR , faceI , faceYN , & bcdataDn , bcdataUp , thistime , dt ) character ( 64 ) :: subroutine_name = 'explicit_euler_advance' real , target , intent ( in out ) :: elem2R (:,:), elemMR (:,:), faceR (:,:) integer , target , intent ( in out ) :: elem2I (:,:), elemMI (:,:), faceI (:,:) logical , target , intent ( in out ) :: elem2YN (:,:), elemMYN (:,:), faceYN (:,:) type ( bcType ), intent ( in out ) :: bcdataDn (:), bcdataUp (:) real , intent ( in ) :: thistime , dt integer :: e2r_Volume_new , e2r_Velocity_new , eMr_Volume_new , eMr_Velocity_new real , pointer :: newvolume (:), newvelocity (:), volume (:), velocity (:), eta (:) real , pointer :: depth (:), zbottom (:), perimeter (:), mn (:), rh (:), area (:) real , pointer :: timesUp (:), timesDn (:), breadth (:), length (:), flowrate (:) real , pointer :: Qface (:), Vup (:), Vdn (:), Aup (:), Adn (:), Eup (:), Edn (:) integer , pointer :: fup (:), fdn (:), elemDn (:), elemUp (:), elemUp2 (:) integer :: fitmp !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name ! set indexes for temporary space e2r_Volume_new = e2r_Temp ( next_e2r_temparray ) next_e2r_temparray = utility_advance_temp_array ( next_e2r_temparray , e2r_n_temp ) e2r_Velocity_new = e2r_Temp ( next_e2r_temparray ) next_e2r_temparray = utility_advance_temp_array ( next_e2r_temparray , e2r_n_temp ) fitmp = fi_Temp ( next_fi_temparray ) next_fi_temparray = utility_advance_temp_array ( next_fi_temparray , fi_n_temp ) eMr_Volume_new = 0 eMr_Velocity_new = 0 newvolume => elem2R (:, e2r_Volume_new ) newvelocity => elem2R (:, e2r_Velocity_new ) elemUp2 => faceI (:, fitmp ) volume => elem2R (:, e2r_Volume ) velocity => elem2R (:, e2r_Velocity ) flowrate => elem2R (:, e2r_Flowrate ) eta => elem2R (:, e2r_Eta ) mn => elem2R (:, e2r_Roughness ) rh => elem2R (:, e2r_HydRadius ) area => elem2R (:, e2r_Area ) depth => elem2R (:, e2r_HydDepth ) perimeter => elem2R (:, e2r_Perimeter ) zbottom => elem2R (:, e2r_Zbottom ) length => elem2R (:, e2r_Length ) breadth => elem2R (:, e2r_BreadthScale ) timesUp => elem2R (:, e2r_Timescale_u ) timesDn => elem2R (:, e2r_Timescale_d ) Qface => faceR (:, fr_Flowrate ) Vup => faceR (:, fr_Velocity_u ) Vdn => faceR (:, fr_Velocity_d ) Aup => faceR (:, fr_Area_u ) Adn => faceR (:, fr_Area_d ) Eup => faceR (:, fr_Eta_u ) Edn => faceR (:, fr_Eta_d ) fup => elem2I (:, e2i_Mface_u ) fdn => elem2I (:, e2i_Mface_d ) where ( elem2I (:, e2I_elem_type ) == eChannel ) newvolume = volume + dt * ( Qface ( fup ) - Qface ( fdn )) newvelocity = ( oneR / newvolume ) & * ( & velocity * volume & + dt * ( Qface ( fup ) * Vdn ( fup ) - Qface ( fdn ) * Vup ( fdn ) & + grav * area * ( Edn ( fup ) - Eup ( fdn )) & - grav * volume * ( mn ** 2 ) * ( velocity ** 2 ) / ( rh ** ( 4.0 / 3.0 )) & ) & ) endwhere where ( elem2I (:, e2I_elem_type ) == eChannel ) volume = newvolume velocity = newvelocity area = volume / length flowrate = velocity * area depth = area / breadth perimeter = twoR * depth + breadth eta = depth + zbottom rh = area / perimeter timesUp = - onehalfR * length / ( velocity - sqrt ( grav * depth )) timesDn = + onehalfR * length / ( velocity + sqrt ( grav * depth )) endwhere call bc_applied_onelement ( elem2R , bcdataDn , bcdataUp , thistime + dt , bc_category_elevation , idummy ) call bc_applied_onelement ( elem2R , bcdataDn , bcdataUp , thistime + dt , bc_category_inflowrate , e2r_Velocity_new ) ! get map to upstream for a quadratic interp elemUp => faceI (:, fi_Melem_u ) elemDn => faceI (:, fi_Melem_d ) where ( elemUp > size ( elemUp )) elemUp = size ( elemUp ) endwhere elemUp2 = elemUp where (( faceI (:, fi_etype_u ) == fChannel ) . and . ( faceI (:, fi_etype_d ) == fChannel )) elemUp2 = elem2I ( elemUp , e2i_Mface_u ) endwhere where ( elemUp2 > size ( elemUp2 )) elemUp2 = size ( elemUp2 ) endwhere where ( elemUp2 < 1 ) elemUp2 = 1 endwhere elemUp2 = faceI ( elemUp2 , fi_Melem_u ) where ( elemUp2 > size ( elemUp2 )) elemUp2 = size ( elemUp2 ) endwhere where ( ( faceI (:, fi_etype_u ) == fChannel ) . and . ( faceI (:, fi_etype_d ) == fChannel )) faceR (:, fr_Flowrate ) = 0.375 * elem2R ( elemDn , e2r_Flowrate ) & + 0.75 * elem2R ( elemUp , e2r_Flowrate ) & - 0.125 * elem2R ( elemUp2 , e2r_Flowrate ) faceR (:, fr_Velocity_d ) = 0.375 * elem2R ( elemDn , e2r_Velocity ) & + 0.75 * elem2R ( elemUp , e2r_Velocity ) & - 0.125 * elem2R ( elemUp2 , e2r_Velocity ) faceR (:, fr_Area_d ) = 0.375 * elem2R ( elemDn , e2r_Area ) & + 0.75 * elem2R ( elemUp , e2r_Area ) & - 0.125 * elem2R ( elemUp2 , e2r_Area ) !faceR(:,fr_Eta_d)      = 0.375 * elem2R(elemDn ,e2r_Eta) & !                       + 0.75  * elem2R(elemUp ,e2r_Eta) & !                       - 0.125 * elem2R(elemUp2,e2r_Eta) faceR (:, fr_Eta_d ) = 0.5 * elem2R ( elemDn , e2r_Eta ) & + 0.5 * elem2R ( elemUp , e2r_Eta ) faceR (:, fr_Topwidth ) = 0.375 * elem2R ( elemDn , e2r_Topwidth ) & + 0.75 * elem2R ( elemUp , e2r_Topwidth ) & - 0.125 * elem2R ( elemUp2 , e2r_Topwidth ) faceR (:, fr_Eta_u ) = faceR (:, fr_Eta_d ) faceR (:, fr_Area_u ) = faceR (:, fr_Area_d ) faceR (:, fr_Velocity_u ) = faceR (:, fr_Velocity_d ) endwhere call bc_applied_onface ( faceR , faceI , elem2R , elem2I , bcdataDn , bcdataUp , e2r_Velocity_new , thistime + dt ) if ( setting % Method % AdjustVshapedFlowrate % Apply ) then call adjust_Vshaped_flowrate ( elem2R , faceR , elem2I , elem2YN ) endif !call bc_applied (faceR, bcdataDn, bcdataUp, thistime+dt) !call bc_face_othervalues (faceR, faceI, elem2R, bcdataDn) !call bc_face_othervalues (faceR, faceI, elem2R, bcdataUp) ! reset temporary data space elem2R (:, e2r_Volume_new ) = nullvalueR elem2R (:, e2r_Velocity_new ) = nullvalueR next_e2r_temparray = next_e2r_temparray - 2 next_fi_temparray = next_fi_temparray - 1 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine explicit_euler_advance ! !========================================================================== ! END OF MODULE explicit_euler !========================================================================== end module explicit_euler","title":"explicit_euler.f08 – SWMMengine","tags":"","loc":"sourcefile/explicit_euler.f08.html"},{"text":"This file depends on sourcefile~~junction.f08~~EfferentGraph sourcefile~junction.f08 junction.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~junction.f08->sourcefile~setting_definition.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~junction.f08->sourcefile~data_keys.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~junction.f08->sourcefile~array_index.f08 sourcefile~utility.f08 utility.f08 sourcefile~junction.f08->sourcefile~utility.f08 sourcefile~globals.f08 globals.f08 sourcefile~junction.f08->sourcefile~globals.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 var pansourcefilejunctionf08EfferentGraph = svgPanZoom('#sourcefilejunctionf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~junction.f08~~AfferentGraph sourcefile~junction.f08 junction.f08 sourcefile~initial_condition.f08 initial_condition.f08 sourcefile~initial_condition.f08->sourcefile~junction.f08 sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~initial_condition.f08->sourcefile~element_geometry.f08 sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~initial_condition.f08->sourcefile~element_dynamics.f08 sourcefile~element_geometry.f08->sourcefile~junction.f08 sourcefile~network_define.f08 network_define.f08 sourcefile~network_define.f08->sourcefile~junction.f08 sourcefile~element_dynamics.f08->sourcefile~junction.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~junction.f08 sourcefile~main.f08->sourcefile~initial_condition.f08 sourcefile~main.f08->sourcefile~network_define.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~main.f08->sourcefile~time_loop.f08 sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~runge_kutta.f08->sourcefile~element_geometry.f08 sourcefile~runge_kutta.f08->sourcefile~element_dynamics.f08 sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~explicit_euler.f08->sourcefile~element_geometry.f08 sourcefile~explicit_euler.f08->sourcefile~element_dynamics.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~time_loop.f08->sourcefile~explicit_euler.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules junction Source Code junction.f08 Source Code ! module junction ! ! Procedures associated with junctions that have more than 2 faces ! !========================================================================== ! module junction ! use array_index use data_keys use globals use setting_definition use utility implicit none private public :: junction_adjacent_element_average public :: junction_adjacent_element_values_to_branches public :: junction_branch_assigned_to_faces public :: junction_branch_average_of_inflows_and_outflows public :: junction_branch_velocity_and_flowrate_proportional_to_area public :: junction_branch_sum_areas_by_direction public :: junction_branch_velocities public :: junction_geometry_setup ! integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine junction_adjacent_element_average & ( elem2R , elemMR , elemMI , faceI , e2r_data , eMr_out ) ! ! this computes the average of values for all the elements upstream and ! downstream. Note that this should ONLY be use ! in setup routines (i.e. when initializing junctions). This violates ! the \"no-neighbor\" rule and is time-consuming because it requires double ! mapping ! character ( 64 ) :: subroutine_name = 'junction_adjacent_element_average' real , target , intent ( in out ) :: elemMR (:,:) real , intent ( in ) :: elem2R (:,:) integer , intent ( in ) :: elemMI (:,:), faceI (:,:) integer , intent ( in ) :: e2r_data , eMr_out real , pointer :: Uvalue (:), Dvalue (:) integer :: eMr_tUp , eMr_tDn !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name eMr_tUp = eMr_Temp ( next_eMr_temparray ) Uvalue => elemMR (:, eMr_tUp ) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) eMr_tDn = eMr_Temp ( next_eMr_temparray ) Dvalue => elemMR (:, eMr_tDn ) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) Uvalue = zeroR call junction_summation_from_adjacent_elements_one_direction & ( eMr_tUp , elem2R , elemMR , elemMI , faceI , & upstream_face_per_elemM , eMi_nfaces_u , eMi_MfaceUp , fi_Melem_u , e2r_data ) Dvalue = zeroR call junction_summation_from_adjacent_elements_one_direction & ( eMr_tDn , elem2R , elemMR , elemMI , faceI , & dnstream_face_per_elemM , eMi_nfaces_d , eMi_MfaceDn , fi_Melem_d , e2r_data ) where ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) elemMR (:, eMr_out ) = ( Uvalue + Dvalue ) / real ( elemMI (:, eMi_nfaces_u ) + elemMI (:, eMi_nfaces_d ) ) endwhere Dvalue = nullvalueR Uvalue = nullvalueR nullify ( Dvalue , Uvalue ) next_eMr_temparray = next_eMr_temparray - 2 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_adjacent_element_average ! !========================================================================== !========================================================================== ! subroutine junction_adjacent_element_values_to_branches & ( elem2R , elemMR , elemMI , faceI , e2r_data , eMr_outUp , eMr_outDn ) ! ! gets the values from the adjacent elements and stores in the branches ! ! THIS SHOULD ONLY BE CALLED DURING INITIAL CONDITIONS OR SETUP ROUTINES ! character ( 64 ) :: subroutine_name = 'junction_adjacent_element_values_to_branches' real , intent ( in out ) :: elemMR (:,:) real , intent ( in ) :: elem2R (:,:) integer , intent ( in ) :: elemMI (:,:), faceI (:,:), eMr_outUp (:), eMr_outDn (:), e2r_data !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name call junction_adjacent_element_values_one_direction & ( elem2R , elemMR , elemMI , faceI , & upstream_face_per_elemM , eMi_nfaces_u , eMi_MfaceUp , fi_Melem_u , & e2r_data , eMr_outUp ) call junction_adjacent_element_values_one_direction & ( elem2R , elemMR , elemMI , faceI , & dnstream_face_per_elemM , eMi_nfaces_d , eMi_MfaceDn , fi_Melem_d , & e2r_data , eMr_outDn ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_adjacent_element_values_to_branches ! !========================================================================== !========================================================================== ! subroutine junction_branch_assigned_to_faces & ( faceI , elemMI ) character ( 64 ) :: subroutine_name = 'junction_branch_assigned_to_faces' integer , intent ( in out ) :: faceI (:,:) integer , intent ( in ) :: elemMI (:,:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do mm = 1 , upstream_face_per_elemM where (( elemMI (:, eMi_nfaces_u ) >= mm ) . and . & ( elemMI (:, eMi_elem_type ) == eJunctionChannel )) faceI ( elemMI (: , eMi_MfaceUp ( mm )), fi_branch_d ) = mm endwhere end do do mm = 1 , dnstream_face_per_elemM where (( elemMI (:, eMi_nfaces_d ) >= mm ) . and . & ( elemMI (:, eMi_elem_type ) == eJunctionChannel )) faceI ( elemMI (: , eMi_MfaceDn ( mm )), fi_branch_u ) = mm endwhere end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_branch_assigned_to_faces ! !========================================================================== !========================================================================== ! subroutine junction_branch_average_of_inflows_and_outflows & ( elemMR , elemMI ) ! ! Computes an average flowrate based on the branch inflows and branch outflows ! Includes effects of flow reverals ! character ( 64 ) :: subroutine_name = 'junction_branch_average_of_inflows_and_outflows' real , target , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) integer :: eMr_inflow , eMr_outflow real , pointer :: inflow (:), outflow (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name eMr_inflow = eMr_Temp ( next_eMr_temparray ) inflow => elemMR (:, eMr_inflow ) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) eMr_outflow = eMr_Temp ( next_eMr_temparray ) outflow => elemMR (:, eMr_outflow ) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) call junction_net_inflow_and_outflow & ( eMr_inflow , eMr_outflow , elemMR , elemMI ) !% simple average of inflow and outflow where ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) elemMR (:, eMr_Flowrate ) = onehalfR * ( inflow + outflow ) endwhere inflow = nullvalueR outflow = nullvalueR nullify ( inflow , outflow ) next_eMr_temparray = next_eMr_temparray - 2 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_branch_average_of_inflows_and_outflows ! !========================================================================== !========================================================================== ! subroutine junction_branch_velocity_and_flowrate_proportional_to_area & ( eMR_totalarea , eMR_totalflowrate , & this_face_per_elem , eMr_AreaThis , eMi_MfaceThis , eMi_nfaces_This , & eMr_FlowrateThis , eMr_VelocityThis , & rdir_face_per_elem , eMr_AreaRdir , eMi_MfaceRdir , eMi_nfaces_Rdir , & eMr_FlowrateRdir , eMr_VelocityRdir , & elemMR , elemMI , faceR ) ! ! Flowrates in each branch of a junction ! Total flowrate is distributed proportionally over the areas ! ! HACK - this can be cleaned up with 2 calls to a function, but we have to be ! careful that we don't introduce pass-by-value in the call ! character ( 64 ) :: subroutine_name = 'junction_branch_velocity_and_flowrate_proportional_to_area' integer , intent ( in ) :: eMi_nfaces_This , eMi_nfaces_Rdir integer , intent ( in ) :: eMR_totalarea , eMR_totalflowrate integer , intent ( in ) :: this_face_per_elem , rdir_face_per_elem integer , intent ( in ) :: eMr_AreaThis (:), eMi_MfaceThis (:) integer , intent ( in ) :: eMr_AreaRdir (:), eMi_MfaceRdir (:) integer , intent ( in ) :: eMr_FlowrateThis (:), eMr_FlowrateRdir (:) integer , intent ( in ) :: eMr_VelocityThis (:), eMr_VelocityRdir (:) real , target , intent ( in out ) :: elemMR (:,:) real , intent ( in ) :: faceR (:,:) integer , target , intent ( in ) :: elemMI (:,:) real , pointer :: area (:), totalarea (:), totalflowrate (:) real , pointer :: flowrate (:), velocity (:) integer , pointer :: fThis (:), fRdir (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name totalarea => elemMR (:, eMR_totalarea ) totalflowrate => elemMR (:, eMR_totalflowrate ) !%  distribute flow proportionally over the downstream outflow branches !%  or opposite call for the upstream inflow branches do mm = 1 , this_face_per_elem area => elemMR (:, eMr_AreaThis ( mm )) flowrate => elemMR (:, eMr_FlowrateThis ( mm )) velocity => elemMR (:, eMr_VelocityThis ( mm )) fThis => elemMI (:, eMi_MfaceThis ( mm )) where ( ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMI (:, eMi_nfaces_This ) >= mm ) . and . & ( faceR ( fThis , fr_Flowrate ) >= 0.0 ) ) flowrate = totalflowrate * area / totalarea velocity = flowrate / area endwhere enddo !%  distribute flow proportionally over the upstream outflow branches !%  or opposite call for downstream inflow branches do mm = 1 , rdir_face_per_elem area => elemMR (:, eMr_AreaRdir ( mm )) flowrate => elemMR (:, eMr_FlowrateRdir ( mm )) velocity => elemMR (:, eMr_VelocityRdir ( mm )) fRdir => elemMI (:, eMi_MfaceRdir ( mm )) where ( ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMI (:, eMi_nfaces_Rdir ) >= mm ) . and . & ( faceR ( fRdir , fr_Flowrate ) < 0.0 ) ) flowrate = - totalflowrate * area / totalarea velocity = flowrate / area endwhere enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_branch_velocity_and_flowrate_proportional_to_area ! !========================================================================== !========================================================================== ! subroutine junction_branch_sum_areas_by_direction & ( eMR_totalarea , & this_face_per_element , eMr_AreaThis , eMi_MfaceThis , eMi_nfaces_This , & rdir_face_per_element , eMr_AreaRdir , eMi_MfaceRdir , eMi_nfaces_Rdir , & elemMR , elemMI , faceR ) ! ! Sum of the areas in each branch of a junction for outflows or inflows ! Called for outflow areas with this = downstream, and rdir = upstream ! Called for inflow  areas with this = upstream    and rdir = downstream ! ! HACK- This could be cleaned up with two calls to a separate function, ! but we have to be careful that we don'tend up introducing a pass-by-value ! into the function. ! character ( 64 ) :: subroutine_name = 'junction_branch_sum_areas_by_direction' integer , intent ( in ) :: eMR_totalarea integer , intent ( in ) :: this_face_per_element , rdir_face_per_element integer , intent ( in ) :: eMr_AreaThis (:), eMi_MfaceThis (:) integer , intent ( in ) :: eMr_AreaRdir (:), eMi_MfaceRdir (:) integer , intent ( in ) :: eMi_nfaces_This , eMi_nfaces_Rdir real , target , intent ( in out ) :: elemMR (:,:) real , intent ( in ) :: faceR (:,:) integer , target , intent ( in ) :: elemMI (:,:) real , pointer :: area (:), totalarea (:) integer , pointer :: fThis (:), fRdir (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name totalarea => elemMR (:, eMR_totalarea ) !print *, trim(subroutine_name) !print *, this_face_per_element !stop !%  get the outflow area for downstream branches (or inflow area for upstream) do mm = 1 , this_face_per_element area => elemMR (:, eMr_AreaThis ( mm )) fThis => elemMI (:, eMi_MfaceThis ( mm )) where ( ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMI (:, eMi_nfaces_This ) >= mm )) where ( faceR ( fThis , fr_Flowrate ) >= 0.0 ) totalarea = totalarea + area endwhere endwhere enddo !%  add the area for any reversing upstream branches (or reversing downstream) do mm = 1 , rdir_face_per_element area => elemMR (:, eMr_AreaRdir ( mm )) fRdir => elemMI (:, eMi_MfaceRdir ( mm )) where ( ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMI (:, eMi_nfaces_Rdir ) >= mm ) . and . & ( faceR ( fRdir , fr_Flowrate ) < 0.0 ) ) totalarea = totalarea + area endwhere enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_branch_sum_areas_by_direction ! !========================================================================== !========================================================================== ! subroutine junction_branch_velocities & ( elemMR , elemMI ) ! ! computes velocities from flowrates and areas in both upstream and downstream ! branches ! character ( 64 ) :: subroutine_name = 'junction_branch_velocities' real , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name call junction_branch_velocities_one_direction & ( elemMR , elemMI , upstream_face_per_elemM , eMi_nfaces_u , & eMr_FlowrateUp , eMr_AreaUp , eMr_VelocityUp ) call junction_branch_velocities_one_direction & ( elemMR , elemMI , dnstream_face_per_elemM , eMi_nfaces_d , & eMr_FlowrateDn , eMr_AreaDn , eMr_VelocityDn ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_branch_velocities ! !========================================================================== !========================================================================== ! subroutine junction_geometry_setup & ( elemMR , elemMI ) ! ! Get the setup for junction geometry ! This gets the breadthscale, topwidth, and length of the junction ! based on the branch values. ! character ( 64 ) :: subroutine_name = 'junction_geometry_setup' real , target , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) real , pointer :: Uvalue (:), Dvalue (:) integer :: ii , eMr_tUp , eMr_tDn !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !% For the breadthscale and topwidth !% take the sum of the upstream breadths and the sum of the downstream breadths !% then compute their average call junction_branch_summation_and_updown_average & ( elemMR , elemMI , eMr_BreadthScaleUp , eMr_BreadthScaleDn , eMr_BreadthScale ) call junction_branch_summation_and_updown_average & ( elemMR , elemMI , eMr_TopwidthUp , eMr_TopwidthDn , eMr_Topwidth ) !% For length !% take the average lengths of the upstream and of the downstream branches !% and then sum these. call junction_branch_average_for_directions_then_sum & ( elemMR , elemMI , eMr_LengthUp , eMr_LengthDn , eMr_Length ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_geometry_setup ! !========================================================================== ! ! PRIVATE BELOW HERE ! !========================================================================== ! subroutine junction_adjacent_element_values_one_direction & ( elem2R , elemMR , elemMI , faceI , & dir_face_per_elemM , eMi_nfaces_dir , eMi_MfaceDir , fi_Melem_dir , e2r_data , eMr_outDir ) character ( 64 ) :: subroutine_name = 'junction_adjacent_element_values_one_direction' real , intent ( in out ) :: elemMR (:,:) real , intent ( in ) :: elem2R (:,:) integer , target , intent ( in ) :: elemMI (:,:), faceI (:,:) integer , intent ( in ) :: dir_face_per_elemM , eMi_nfaces_dir integer , intent ( in ) :: eMi_MfaceDir (:), eMr_outDir (:) integer , intent ( in ) :: fi_Melem_dir , e2r_data integer , pointer :: tface , telem integer :: mm , ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do ii = 1 , N_elemM do mm = 1 , dir_face_per_elemM if (( elemMI ( ii , eMi_nfaces_dir ) >= mm ) . and . & ( elemMI ( ii , eMi_elem_type ) == eJunctionChannel )) then !% the face on a branch in the direction specified by dir tface => elemMI ( ii , eMi_MfaceDir ( mm )) !% the element upstream of the face telem => faceI ( tface , fi_Melem_dir ) !% the value at the element !print *, ii, mm !print *, tface !print *, telem !print *, elem2R(telem,e2r_data) elemMR ( ii , eMr_outDir ( mm )) = elem2R ( telem , e2r_data ) endif enddo enddo ! print *, eMr_outDir(1), eMr_Area_u1 ! print *, elemMR(:,eMr_outDir(1)), elemMR(:,eMr_outDir(2)) ! print *, trim(subroutine_name) ! stop ! if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_adjacent_element_values_one_direction ! !========================================================================== !========================================================================== ! subroutine junction_branch_average & ( eMr_avgvalue , elemMR , elemMI , eMr_column_up , eMr_column_dn ) ! ! compute the average of data type in column_up and column_dn over ! all the branches of the junciton ! character ( 64 ) :: subroutine_name = 'junction_branch_average' integer , intent ( in ) :: eMr_avgvalue real , target , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) integer , intent ( in ) :: eMr_column_up (:), eMr_column_dn (:) real , pointer :: avgvalue (:) !-------------------------------------------------------------------------- avgvalue => elemMR (:, eMr_avgvalue ) avgvalue = zeroR call junction_branch_summation & ( eMr_avgvalue , elemMR , elemMI , eMr_column_up , eMr_column_dn ) where ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) avgvalue = avgvalue / real ( elemMI (:, eMi_nfaces )) endwhere if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_branch_average ! !========================================================================== !========================================================================== ! subroutine junction_branch_average_for_directions_then_sum & ( elemMR , elemMI , eMr_columnUp , eMr_columnDn , eMr_out ) ! ! separately compute the average of the branches in up and down directions ! and then sum the result. Applies to data in eMr_columnUp and eMr_columnDn ! with result in eMr_out. e.g. eMr_LengthUp, eMr_LengthDn -> eMr_Length ! to get a length scale for a junction. ! character ( 64 ) :: subroutine_name = 'junction_branch_average_for_directions_then_sum' real , target , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) integer , intent ( in ) :: eMr_columnUp (:), eMr_columnDn (:) integer , intent ( in ) :: eMr_out real , pointer :: Uvalue (:), Dvalue (:) integer :: ii , eMr_tUp , eMr_tDn !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name eMr_tUp = eMr_Temp ( next_eMr_temparray ) Uvalue => elemMR (:, eMr_tUp ) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) eMr_tDn = eMr_Temp ( next_eMr_temparray ) Dvalue => elemMR (:, eMr_tDn ) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) Uvalue = zeroR call junction_branch_summation_one_direction & ( eMr_tUp , elemMR , elemMI , upstream_face_per_elemM , eMi_nfaces_u , eMr_columnUp ) Dvalue = zeroR call junction_branch_summation_one_direction & ( eMr_tDn , elemMR , elemMI , dnstream_face_per_elemM , eMi_nfaces_d , eMr_columnDn ) where ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) Uvalue = Uvalue / real ( elemMI (:, eMi_nfaces_u )) Dvalue = Dvalue / real ( elemMI (:, eMi_nfaces_D )) elemMR (:, eMr_out ) = Uvalue + Dvalue endwhere Dvalue = nullvalueR Uvalue = nullvalueR nullify ( Dvalue , Uvalue ) next_eMr_temparray = next_eMr_temparray - 2 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_branch_average_for_directions_then_sum ! !========================================================================== !========================================================================== ! subroutine junction_branch_summation & ( eMr_sumvalue , elemMR , elemMI , eMr_column_up , eMr_column_dn ) ! ! sum all the values in all the branches - both up and down ! character ( 64 ) :: subroutine_name = 'junction_branch_summation' integer , intent ( in ) :: eMr_sumvalue real , target , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) integer , intent ( in ) :: eMr_column_up (:), eMr_column_dn (:) real , pointer :: sumvalue (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name sumvalue => elemMR (:, eMr_sumvalue ) sumvalue = zeroR call junction_branch_summation_one_direction & ( eMr_sumvalue , elemMR , elemMI , upstream_face_per_elemM , eMi_nfaces_u , eMr_column_up ) call junction_branch_summation_one_direction & ( eMr_sumvalue , elemMR , elemMI , dnstream_face_per_elemM , eMi_nfaces_d , eMr_column_dn ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_branch_summation ! !========================================================================== !========================================================================== ! subroutine junction_branch_summation_and_updown_average & ( elemMR , elemMI , eMr_columnUp , eMr_columnDn , eMr_out ) ! ! separately compute the sum of the upstream and the downstream branches ! for data in eMr_columnUp and eMr_columnDn (e.g. eMr_TopwidthUp) ! and then computes the average between the two sums. Output is stored in ! elemMR(:,eMr_out) ! NOTE THIS DOES NOT ACCOUNT FOR FLOW REVERSALS ! character ( 64 ) :: subroutine_name = 'junction_branch_summation_and_updown_average' real , target , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) integer , intent ( in ) :: eMr_columnUp (:), eMr_columnDn (:) integer , intent ( in ) :: eMr_out real , pointer :: Uvalue (:), Dvalue (:) integer :: ii , eMr_tUp , eMr_tDn !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name eMr_tUp = eMr_Temp ( next_eMr_temparray ) Uvalue => elemMR (:, eMr_tUp ) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) eMr_tDn = eMr_Temp ( next_eMr_temparray ) Dvalue => elemMR (:, eMr_tDn ) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) Uvalue = zeroR call junction_branch_summation_one_direction & ( eMr_tUp , elemMR , elemMI , upstream_face_per_elemM , eMi_nfaces_u , eMr_BreadthScaleUp ) Dvalue = zeroR call junction_branch_summation_one_direction & ( eMr_tDn , elemMR , elemMI , dnstream_face_per_elemM , eMi_nfaces_d , eMr_BreadthScaleDn ) where ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) elemMR (:, eMr_out ) = onehalfR * ( Uvalue + Dvalue ) endwhere Dvalue = nullvalueR Uvalue = nullvalueR nullify ( Dvalue , Uvalue ) next_eMr_temparray = next_eMr_temparray - 2 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_branch_summation_and_updown_average ! !========================================================================== !========================================================================== ! subroutine junction_branch_summation_one_direction & ( eMr_sumvalue , elemMR , elemMI , face_per_elemM , eMi_nfaces_dir , eMr_columnDir ) ! ! cycle through the branches in one direction (up or dn) to sum all their values ! NOTE THAT THIS DOES NOT RESET THE SUM TO ZERO BEFORE EXECUTION ! This behavior is required for accumulators. ! character ( 64 ) :: subroutine_name = 'junction_branch_summation_one_direction' integer , intent ( in ) :: eMr_sumvalue real , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) integer , intent ( in ) :: face_per_elemM , eMi_nfaces_dir , eMr_columnDir (:) integer :: ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do ii = 1 , face_per_elemM where ( elemMI (:, eMi_nfaces_dir ) >= ii ) elemMR (:, eMr_sumvalue ) = elemMR (:, eMr_sumvalue ) + elemMR (:, eMr_columnDir ( ii )) endwhere enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_branch_summation_one_direction ! !========================================================================== !========================================================================== ! subroutine junction_branch_velocities_one_direction & ( elemMR , elemMI , dir_face_per_elemM , eMi_nfaces_dir , & eMr_FlowrateDir , eMr_AreaDir , eMr_VelocityDir ) ! ! computes the velocities in each branch (with dir = upstream or downstream) ! from flowrate and area ! character ( 64 ) :: subroutine_name = 'junction_branch_velocities_one_direction' real , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) integer , intent ( in ) :: eMr_FlowrateDir (:), eMr_AreaDir (:), eMr_VelocityDir (:) integer , intent ( in ) :: dir_face_per_elemM , eMi_nfaces_dir integer :: ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do ii = 1 , dir_face_per_elemM where (( elemMI (:, eMi_nfaces_dir ) >= ii ) . and . & ( elemMI (:, eMi_elem_type ) == eJunctionChannel )) elemMR (:, eMr_VelocityDir ( ii )) = elemMR (:, eMr_FlowrateDir ( ii )) / elemMR (:, eMr_AreaDir ( ii )) endwhere enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_branch_velocities_one_direction ! !========================================================================== !========================================================================== ! subroutine junction_net_flow_in_or_out & ( eMr_flow , elemMR , elemMI , dir_face_per_elemM , eMi_nfaces_dir , & eMr_FlowrateDir1 , eMr_FlowrateDir2 ) character ( 64 ) :: subroutine_name = 'junction_net_flow_in_or_out' integer , intent ( in ) :: eMr_flow real , target , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) integer , intent ( in ) :: dir_face_per_elemM , eMi_nfaces_dir integer , intent ( in ) :: eMr_FlowrateDir1 (:), eMr_flowrateDir2 (:) real , pointer :: flow (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name flow => elemMR (:, eMr_flow ) flow = zeroR do mm = 1 , dir_face_per_elemM where (( elemMI (:, eMi_nfaces_dir ) >= mm ) . and . & ( elemMI (:, eMi_elem_type ) == eJunctionChannel )) where ( elemMR (:, eMr_FlowrateDir1 ( mm )) > zeroR ) flow = flow + elemMR (:, eMr_FlowrateDir1 ( mm )) endwhere where ( elemMR (:, eMr_FlowrateDir2 ( mm )) < zeroR ) flow = flow - elemMR (:, eMr_FlowrateDir2 ( mm )) endwhere endwhere enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_net_flow_in_or_out ! !========================================================================== !========================================================================== ! subroutine junction_net_inflow_and_outflow & ( eMr_inflow , eMr_outflow , elemMR , elemMI ) ! ! Computes the net inflow and net outflow including effects of flow reversals ! Stores results in the columns eMr_inflow and eMr_outflow. ! character ( 64 ) :: subroutine_name = 'junction_net_inflow_and_outflow' integer , intent ( in ) :: eMr_inflow , eMr_outflow real , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name call junction_net_flow_in_or_out & ( eMr_inflow , elemMR , elemMI , upstream_face_per_elemM , eMi_nfaces_u , & eMr_FlowrateUp , eMr_flowrateDn ) call junction_net_flow_in_or_out & ( eMr_outflow , elemMR , elemMI , dnstream_face_per_elemM , eMi_nfaces_d , & eMr_FlowrateDn , eMr_FlowrateUp ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_net_inflow_and_outflow ! !========================================================================== !========================================================================== ! subroutine junction_summation_from_adjacent_elements_one_direction & ( eMr_sumvalue , elem2R , elemMR , elemMI , faceI , & dir_face_per_elemM , eMi_nfaces_dir , eMi_MfaceDir , fi_Melem_dir , e2r_data ) character ( 64 ) :: subroutine_name = 'junction_summation_from_adjacent_elements_one_direction' ! ! computes the sum of all the elements adjacent to a junction in either ! the upstream or downstream direction ! ! THIS SHOULD ONLY BE USED IN SETUP AND INITIAL CONDITION ROUTINES ! integer , intent ( in ) :: eMr_sumvalue real , target , intent ( in out ) :: elemMR (:,:) real , intent ( in ) :: elem2R (:,:) integer , target , intent ( in ) :: elemMI (:,:), faceI (:,:) integer , intent ( in ) :: dir_face_per_elemM , eMi_nfaces_dir , eMi_MfaceDir (:) integer , intent ( in ) :: fi_Melem_dir , e2r_data integer , pointer :: tface , telem real :: thisvalue ( dir_face_per_elemM ) integer :: mm , ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do ii = 1 , N_elemM thisvalue = zeroR do mm = 1 , dir_face_per_elemM if (( elemMI ( ii , eMi_nfaces_dir ) >= mm ) . and . & ( elemMI ( ii , eMi_elem_type ) == eJunctionChannel )) then !% the face on a branch in the direction specified by dir tface => elemMI ( ii , eMi_MfaceDir ( mm )) !% the element upstream of the face telem => faceI ( tface , fi_Melem_dir ) !% the value at the element thisvalue ( mm ) = elem2R ( telem , e2r_data ) endif enddo elemMR ( ii , eMr_sumvalue ) = sum ( thisvalue ) enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine junction_summation_from_adjacent_elements_one_direction ! !========================================================================== ! END OF MODULE junction !========================================================================== end module junction","title":"junction.f08 – SWMMengine","tags":"","loc":"sourcefile/junction.f08.html"},{"text":"This file depends on sourcefile~~initialization.f08~~EfferentGraph sourcefile~initialization.f08 initialization.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~initialization.f08->sourcefile~data_keys.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~initialization.f08->sourcefile~array_index.f08 sourcefile~globals.f08 globals.f08 sourcefile~initialization.f08->sourcefile~globals.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~initialization.f08~~AfferentGraph sourcefile~initialization.f08 initialization.f08 sourcefile~network_define.f08 network_define.f08 sourcefile~network_define.f08->sourcefile~initialization.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~initialization.f08 sourcefile~main.f08->sourcefile~network_define.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules initialization Source Code initialization.f08 Source Code ! module initialization ! ! This creates the arrays index structures that are used for accessing ! data. Arguably, this could be done more simply but we want the fundamental ! column indexes in array_index to be parameters rather than variables. By ! using parameters we reduce the possibility of accidentally changing a ! column definition. ! !========================================================================== ! module initialization ! ! general initialization of data structures (not including network) ! use array_index use data_keys use globals implicit none private public :: initialize_arrayindex ! handles indexes for multiple face per element public :: initialize_arrayindex_status ! status check at end of simulation public :: initialize_array_zerovalues ! sets some elemMR values to zero public :: initialize_dummy_values integer , private :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine initialize_arrayindex ! ! Initializes the array indexes for the parameter values. ! Note that the use of these indexes as variable arrays in the code is ! necessary for simplicity in coding, but leaves a potential bug if the ! variables are ever changed during the code. As such, we have an ! additional subroutine (initialization_arrayindex_status) that checks to ! see of the indexes have retained their values at the end of a ! simulation. character ( 64 ) :: subroutine_name = 'initialize_arrayindex' integer :: ii , kk !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name ! initialize the indexes for temp arrays e2r_Temp ( 1 ) = e2r_temp1 e2r_Temp ( 2 ) = e2r_temp2 e2r_Temp ( 3 ) = e2r_temp3 e2r_Temp ( 4 ) = e2r_temp4 e2r_Temp ( 5 ) = e2r_temp5 e2r_Temp ( 6 ) = e2r_temp6 if ( e2r_n_temp > 6 ) then print * , 'error need to update initialization of e2r_Temp in ' , subroutine_name stop endif eMr_Temp ( 1 ) = eMr_temp1 eMr_Temp ( 2 ) = eMr_temp2 eMr_Temp ( 3 ) = eMr_temp3 eMr_Temp ( 4 ) = eMr_temp4 eMr_Temp ( 5 ) = eMr_temp5 eMr_Temp ( 6 ) = eMr_temp6 if ( eMr_n_temp > 6 ) then print * , 'error need to update initialization of eMr_Temp in ' , subroutine_name stop endif e2i_Temp ( 1 ) = e2i_temp1 e2i_Temp ( 2 ) = e2i_temp2 if ( e2i_n_temp > 2 ) then print * , 'error need to update initialization of e2i_Temp in ' , subroutine_name stop endif eMi_Temp ( 1 ) = eMi_temp1 eMi_Temp ( 2 ) = eMi_temp2 if ( eMi_n_temp > 2 ) then print * , 'error need to update initialization of eMi_Temp in ' , subroutine_name stop endif fi_Temp ( 1 ) = fi_temp1 fi_Temp ( 2 ) = fi_temp2 if ( fi_n_temp > 2 ) then print * , 'error need to update initialization of fi_Temp in ' , subroutine_name stop endif fr_Temp ( 1 ) = fr_temp1 fr_Temp ( 2 ) = fr_temp2 fr_Temp ( 3 ) = fr_temp3 fr_Temp ( 4 ) = fr_temp4 if ( fr_n_temp > 4 ) then print * , 'error need to update initialization of fr_Temp in ' , subroutine_name stop endif e2YN_Temp ( 1 ) = e2YN_temp1 e2YN_Temp ( 2 ) = e2YN_temp2 e2YN_Temp ( 3 ) = e2YN_temp3 e2YN_Temp ( 4 ) = e2YN_temp4 if ( e2YN_n_temp > 4 ) then print * , 'error need to update initialization of e2YN_Temp in ' , subroutine_name stop endif eMYN_Temp ( 1 ) = eMYN_temp1 eMYN_Temp ( 2 ) = eMYN_temp2 eMYN_Temp ( 3 ) = eMYN_temp3 eMYN_Temp ( 4 ) = eMYN_temp4 if ( eMYN_n_temp > 4 ) then print * , 'error need to update initialization of eMYN_Temp in ' , subroutine_name stop endif fYN_Temp ( 1 ) = fYN_temp1 fYN_Temp ( 2 ) = fYN_temp2 if ( fYN_n_temp > 2 ) then print * , 'error need to update initialization of fYN_Temp in ' , subroutine_name stop endif ! the following are required index values ii = 1 ni_MlinkUp ( ii ) = ni_Mlink_u1 ni_MlinkDn ( ii ) = ni_Mlink_d1 eMi_MfaceUp ( ii ) = eMi_Mface_u1 eMi_MfaceDn ( ii ) = eMi_Mface_d1 eMr_EtaUp ( ii ) = eMr_Eta_u1 eMr_EtaDn ( ii ) = eMr_Eta_d1 eMr_FlowrateUp ( ii ) = eMr_Flowrate_u1 eMr_FlowrateDn ( ii ) = eMr_Flowrate_d1 eMr_VelocityUp ( ii ) = eMr_Velocity_u1 eMr_VelocityDn ( ii ) = eMr_Velocity_d1 eMr_TimescaleUp ( ii ) = eMr_Timescale_u1 eMr_TimescaleDn ( ii ) = eMr_Timescale_d1 eMr_AreaUp ( ii ) = eMr_Area_u1 eMr_AreaDn ( ii ) = eMr_Area_d1 eMr_TopwidthUp ( ii ) = eMr_Topwidth_u1 eMr_TopwidthDn ( ii ) = eMr_Topwidth_d1 eMr_HydDepthUp ( ii ) = eMr_HydDepth_u1 eMr_HydDepthDn ( ii ) = eMr_HydDepth_d1 eMr_LengthUp ( ii ) = eMr_Length_u1 eMr_LengthDn ( ii ) = eMr_Length_d1 eMr_ZbottomUp ( ii ) = eMr_Zbottom_u1 eMr_ZbottomDn ( ii ) = eMr_Zbottom_d1 eMr_BreadthScaleUp ( ii ) = eMr_BreadthScale_u1 eMr_BreadthScaleDn ( ii ) = eMr_BreadthScale_d1 nr_ElementLengthUp ( ii ) = nr_ElementLength_u1 nr_ElementLengthDn ( ii ) = nr_ElementLength_d1 ! the following depends on the number of upstream faces per element allowed ii = 2 if ( upstream_face_per_elemM > ii - 1 ) then ni_MlinkUp ( ii ) = ni_Mlink_u2 eMi_MfaceUp ( ii ) = eMi_Mface_u2 eMr_EtaUp ( ii ) = eMr_Eta_u2 eMr_FlowrateUp ( ii ) = eMr_Flowrate_u2 eMr_VelocityUp ( ii ) = eMr_Velocity_u2 eMr_TimescaleUp ( ii ) = eMr_Timescale_u2 eMr_AreaUp ( ii ) = eMr_Area_u2 eMr_TopwidthUp ( ii ) = eMr_Topwidth_u2 eMr_HydDepthUp ( ii ) = eMr_HydDepth_u2 eMr_LengthUp ( ii ) = eMr_Length_u2 eMr_ZbottomUp ( ii ) = eMr_Zbottom_u2 eMr_BreadthScaleUp ( ii ) = eMr_BreadthScale_u2 nr_ElementLengthUp ( ii ) = nr_ElementLength_u2 endif ii = 3 if ( upstream_face_per_elemM > ii - 1 ) then ni_MlinkUp ( ii ) = ni_Mlink_u3 eMi_MfaceUp ( ii ) = eMi_Mface_u3 eMr_EtaUp ( ii ) = eMr_Eta_u3 eMr_FlowrateUp ( ii ) = eMr_Flowrate_u3 eMr_VelocityUp ( ii ) = eMr_Velocity_u3 eMr_TimescaleUp ( ii ) = eMr_Timescale_u3 eMr_AreaUp ( ii ) = eMr_Area_u3 eMr_TopwidthUp ( ii ) = eMr_Topwidth_u3 eMr_HydDepthUp ( ii ) = eMr_HydDepth_u3 eMr_LengthUp ( ii ) = eMr_Length_u3 eMr_ZbottomUp ( ii ) = eMr_Zbottom_u3 eMr_BreadthScaleUp ( ii ) = eMr_BreadthScale_u3 nr_ElementLengthUp ( ii ) = nr_ElementLength_u3 endif if ( upstream_face_per_elemM > 3 ) then print * , 'error: code does not support upstream_face_per_elemM > 3 in ' , subroutine_name endif ! the following depends on the number of downstream faces per element allowed ii = 2 if ( dnstream_face_per_elemM > ii - 1 ) then ni_MlinkDn ( ii ) = ni_Mlink_d2 eMi_MfaceDn ( ii ) = eMi_Mface_d2 eMr_EtaDn ( ii ) = eMr_Eta_d2 eMr_FlowrateDn ( ii ) = eMr_Flowrate_d2 eMr_VelocityDn ( ii ) = eMr_Velocity_d2 eMr_TimescaleDn ( ii ) = eMr_Timescale_d2 eMr_AreaDn ( ii ) = eMr_Area_d2 eMr_TopwidthDn ( ii ) = eMr_Topwidth_d2 eMr_HydDepthDn ( ii ) = eMr_HydDepth_d2 eMr_LengthDn ( ii ) = eMr_Length_d2 eMr_ZbottomDn ( ii ) = eMr_Zbottom_d2 eMr_BreadthScaleDn ( ii ) = eMr_BreadthScale_d2 nr_ElementLengthDn ( ii ) = nr_ElementLength_d2 endif ii = 3 if ( dnstream_face_per_elemM > ii - 1 ) then ni_MlinkDn ( ii ) = ni_Mlink_d3 eMi_MfaceDn ( ii ) = eMi_Mface_d3 eMr_EtaDn ( ii ) = eMr_Eta_d3 eMr_FlowrateDn ( ii ) = eMr_Flowrate_d3 eMr_VelocityDn ( ii ) = eMr_Velocity_d3 eMr_TimescaleDn ( ii ) = eMr_Timescale_d3 eMr_AreaDn ( ii ) = eMr_Area_d3 eMr_TopwidthDn ( ii ) = eMr_Topwidth_d3 eMr_HydDepthDn ( ii ) = eMr_HydDepth_d3 eMr_LengthDn ( ii ) = eMr_Length_d3 eMr_ZbottomDn ( ii ) = eMr_Zbottom_d3 eMr_BreadthScaleDn ( ii ) = eMr_BreadthScale_d3 nr_ElementLengthDn ( ii ) = nr_ElementLength_d3 endif if ( dnstream_face_per_elemM > 3 ) then print * , 'error: code does not support dnstream_face_per_elemM > 3 in ' , subroutine_name endif do ii = 1 , upstream_face_per_elemM eMr_EtaAll ( ii ) = eMr_EtaUp ( ii ) eMr_FlowrateAll ( ii ) = eMr_FlowrateUp ( ii ) eMr_VelocityAll ( ii ) = eMr_VelocityUp ( ii ) eMr_TimescaleAll ( ii ) = eMr_TimescaleUp ( ii ) eMr_AreaAll ( ii ) = eMr_AreaUp ( ii ) eMr_TopwidthAll ( ii ) = eMr_TopwidthUp ( ii ) eMr_HydDepthAll ( ii ) = eMr_HydDepthUp ( ii ) eMr_LengthAll ( ii ) = eMr_LengthUp ( ii ) eMr_ZbottomAll ( ii ) = eMr_ZbottomUp ( ii ) eMr_BreadthScaleAll ( ii ) = eMr_BreadthScaleUp ( ii ) eMi_MfaceAll ( ii ) = eMi_MfaceUp ( ii ) end do do ii = 1 , dnstream_face_per_elemM kk = ii + upstream_face_per_elemM eMr_EtaAll ( kk ) = eMr_EtaDn ( ii ) eMr_FlowrateAll ( kk ) = eMr_FlowrateDn ( ii ) eMr_VelocityAll ( kk ) = eMr_VelocityDn ( ii ) eMr_TimescaleAll ( kk ) = eMr_TimescaleDn ( ii ) eMr_AreaAll ( kk ) = eMr_AreaDn ( ii ) eMr_TopwidthAll ( kk ) = eMr_TopwidthDn ( ii ) eMr_HydDepthAll ( kk ) = eMr_HydDepthDn ( ii ) eMr_LengthAll ( kk ) = eMr_LengthDn ( ii ) eMr_ZbottomAll ( kk ) = eMr_ZbottomDn ( ii ) eMr_BreadthScaleAll ( kk ) = eMr_BreadthScaleDn ( ii ) eMi_MfaceAll ( kk ) = eMi_MfaceDn ( ii ) end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine initialize_arrayindex ! !========================================================================== !========================================================================== ! subroutine initialize_arrayindex_status ! ! Companion to initialize_faceindex that checks to see if the face index ! arrays were accidentally changed during code execution. Such a change ! would invalidate the indexing and create a subtle bug in the results. ! character ( 64 ) :: subroutine_name = 'initialize_arrayindex_status' integer :: ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if ( eMr_Temp ( 1 ) /= eMr_temp1 ) then print * , 'error: eMr_Temp(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_Temp ( 2 ) /= eMr_temp2 ) then print * , 'error: eMr_Temp(2) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_Temp ( 3 ) /= eMr_temp3 ) then print * , 'error: eMr_Temp(3) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_Temp ( 4 ) /= eMr_temp4 ) then print * , 'error: eMr_Temp(4) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_Temp ( 5 ) /= eMr_temp5 ) then print * , 'error: eMr_Temp(5) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_Temp ( 6 ) /= eMr_temp6 ) then print * , 'error: eMr_Temp(6) unexpectedly changed in code in ' , subroutine_name stop endif if ( e2r_Temp ( 1 ) /= e2r_temp1 ) then print * , 'error: e2r_Temp(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( e2r_Temp ( 2 ) /= e2r_temp2 ) then print * , 'error: e2r_Temp(2) unexpectedly changed in code in ' , subroutine_name stop endif if ( e2r_Temp ( 3 ) /= e2r_temp3 ) then print * , 'error: e2r_Temp(3) unexpectedly changed in code in ' , subroutine_name stop endif if ( e2r_Temp ( 4 ) /= e2r_temp4 ) then print * , 'error: e2r_Temp(4) unexpectedly changed in code in ' , subroutine_name stop endif if ( e2r_Temp ( 5 ) /= e2r_temp5 ) then print * , 'error: e2r_Temp(5) unexpectedly changed in code in ' , subroutine_name stop endif if ( e2r_Temp ( 6 ) /= e2r_temp6 ) then print * , 'error: e2r_Temp(6) unexpectedly changed in code in ' , subroutine_name stop endif ii = 1 if ( ni_MlinkUp ( ii ) /= ni_Mlink_u1 ) then print * , 'error: ni_MlinkUp(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( ni_MlinkDn ( ii ) /= ni_Mlink_d1 ) then print * , 'error: ni_MlinkDn(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMi_MfaceUp ( ii ) /= eMi_Mface_u1 ) then print * , 'error: eMi_MfaceUp(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMi_MfaceDn ( ii ) /= eMi_Mface_d1 ) then print * , 'error: eMi_MfaceDn(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_EtaUp ( ii ) /= eMr_Eta_u1 ) then print * , 'error: eMr_EtaUp(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( emr_EtaDn ( ii ) /= eMr_Eta_d1 ) then print * , 'error: eMr_EtaDn(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_FlowrateUp ( ii ) /= eMr_Flowrate_u1 ) then print * , 'error: eMr_FlowrateUp(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( emr_FlowrateDn ( ii ) /= eMr_Flowrate_d1 ) then print * , 'error: eMr_FlowrateDn(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_VelocityUp ( ii ) /= eMr_Velocity_u1 ) then print * , 'error: eMr_VelocityUp(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_VelocityDn ( ii ) /= eMr_Velocity_d1 ) then print * , 'error: eMr_VelocityDn(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_TimescaleUp ( ii ) /= eMr_Timescale_u1 ) then print * , 'error: eMr_TimescaleUp(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_TimescaleDn ( ii ) /= eMr_Timescale_d1 ) then print * , 'error: eMr_TimescaleDn(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_AreaUp ( ii ) /= eMr_Area_u1 ) then print * , 'error: eMr_AreaUp(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_AreaDn ( ii ) /= eMr_Area_d1 ) then print * , 'error: eMr_AreaDn(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_TopwidthUp ( ii ) /= eMr_Topwidth_u1 ) then print * , 'error: eMr_TopwidthUp(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_TopwidthDn ( ii ) /= eMr_Topwidth_d1 ) then print * , 'error: eMr_TopwidthDn(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_HydDepthUp ( ii ) /= eMr_HydDepth_u1 ) then print * , 'error: eMr_HydDepthUp(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_HydDepthDn ( ii ) /= eMr_HydDepth_d1 ) then print * , 'error: eMr_HydDepthDn(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_LengthUp ( ii ) /= eMr_Length_u1 ) then print * , 'error: eMr_LengthUp(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_LengthDn ( ii ) /= eMr_Length_d1 ) then print * , 'error: eMr_LengthDn(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_ZbottomUp ( ii ) /= eMr_Zbottom_u1 ) then print * , 'error: eMr_ZbottomUp(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_ZbottomDn ( ii ) /= eMr_Zbottom_d1 ) then print * , 'error: eMr_ZbottomDn(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_BreadthScaleUp ( ii ) /= eMr_BreadthScale_u1 ) then print * , 'error: eMr_BreadthScaleUp(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_BreadthScaleDn ( ii ) /= eMr_BreadthScale_d1 ) then print * , 'error: eMr_BreadthScaleDn(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( nr_ElementLengthUp ( ii ) /= nr_ElementLength_u1 ) then print * , 'error: nr_ElementLengthUp(1) unexpectedly changed in code in ' , subroutine_name stop endif if ( nr_ElementLengthDn ( ii ) /= nr_ElementLength_d1 ) then print * , 'error: ni_ElementLengthDn(1) unexpectedly changed in code in ' , subroutine_name stop endif ! the following depends on the number of upstream faces per element allowed ii = 2 if ( upstream_face_per_elemM > ii - 1 ) then if ( ni_MlinkUp ( ii ) /= ni_Mlink_u2 ) then print * , 'ii = ' , ii print * , 'error: ni_MlinkUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMi_MfaceUp ( ii ) /= eMi_Mface_u2 ) then print * , 'ii = ' , ii print * , 'error: eMi_MfaceUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_EtaUp ( ii ) /= eMr_Eta_u2 ) then print * , 'ii = ' , ii print * , 'error: eMr_EtaUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_FlowrateUp ( ii ) /= eMr_Flowrate_u2 ) then print * , 'ii = ' , ii print * , 'error: eMr_FlowrateUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_VelocityUp ( ii ) /= eMr_Velocity_u2 ) then print * , 'ii = ' , ii print * , 'error: eMr_VelocityUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_TimescaleUp ( ii ) /= eMr_Timescale_u2 ) then print * , 'ii = ' , ii print * , 'error: eMr_TimescaleUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_AreaUp ( ii ) /= eMr_Area_u2 ) then print * , 'ii = ' , ii print * , 'error: eMr_AreaUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_TopwidthUp ( ii ) /= eMr_Topwidth_u2 ) then print * , 'ii = ' , ii print * , 'error: eMr_TopwidthUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_HydDepthUp ( ii ) /= eMr_HydDepth_u2 ) then print * , 'ii = ' , ii print * , 'error: eMr_HydDepthUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_LengthUp ( ii ) /= eMr_Length_u2 ) then print * , 'ii = ' , ii print * , 'error: eMr_LengthUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_ZbottomUp ( ii ) /= eMr_Zbottom_u2 ) then print * , 'ii = ' , ii print * , 'error: eMr_ZbottomUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_BreadthScaleUp ( ii ) /= eMr_BreadthScale_u2 ) then print * , 'ii = ' , ii print * , 'error: eMr_BreadthScaleUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( nr_ElementLengthUp ( ii ) /= nr_ElementLength_u2 ) then print * , 'ii = ' , ii print * , 'error: nr_ElementLengthUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif endif ii = 3 if ( upstream_face_per_elemM > ii - 1 ) then if ( ni_MlinkUp ( ii ) /= ni_Mlink_u3 ) then print * , 'ii = ' , ii print * , 'error: ni_MlinkUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMi_MfaceUp ( ii ) /= eMi_Mface_u3 ) then print * , 'ii = ' , ii print * , 'error: eMi_MfaceUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_EtaUp ( ii ) /= eMr_Eta_u3 ) then print * , 'ii = ' , ii print * , 'error: eMr_EtaUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_FlowrateUp ( ii ) /= eMr_Flowrate_u3 ) then print * , 'ii = ' , ii print * , 'error: eMr_FlowrateUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_VelocityUp ( ii ) /= eMr_Velocity_u3 ) then print * , 'ii = ' , ii print * , 'error: eMr_VelocityUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_TimescaleUp ( ii ) /= eMr_Timescale_u3 ) then print * , 'ii = ' , ii print * , 'error: eMr_TimescaleUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_AreaUp ( ii ) /= eMr_Area_u3 ) then print * , 'ii = ' , ii print * , 'error: eMr_AreaUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_TopwidthUp ( ii ) /= eMr_Topwidth_u3 ) then print * , 'ii = ' , ii print * , 'error: eMr_TopwidthUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_HydDepthUp ( ii ) /= eMr_HydDepth_u3 ) then print * , 'ii = ' , ii print * , 'error: eMr_HydDepthUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_LengthUp ( ii ) /= eMr_Length_u3 ) then print * , 'ii = ' , ii print * , 'error: eMr_LengthUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_ZbottomUp ( ii ) /= eMr_Zbottom_u3 ) then print * , 'ii = ' , ii print * , 'error: eMr_ZbottomUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_BreadthScaleUp ( ii ) /= eMr_BreadthScale_u3 ) then print * , 'ii = ' , ii print * , 'error: eMr_BreadthScaleUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( nr_ElementLengthUp ( ii ) /= nr_ElementLength_u3 ) then print * , 'ii = ' , ii print * , 'error: nr_ElementLengthUp(ii) unexpectedly changed in code in ' , subroutine_name stop endif endif if ( upstream_face_per_elemM > 3 ) then print * , 'error: code does not support upstream_face_per_elemM > 3 in ' , subroutine_name endif ! the following depends on the number of downstream faces per element allowed ii = 2 if ( dnstream_face_per_elemM > ii - 1 ) then if ( ni_MlinkDn ( ii ) /= ni_Mlink_d2 ) then print * , 'ii = ' , ii print * , 'error: ni_MlinkDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMi_MfaceDn ( ii ) /= eMi_Mface_d2 ) then print * , 'ii = ' , ii print * , 'error: eMi_MfaceDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_EtaDn ( ii ) /= eMr_Eta_d2 ) then print * , 'ii = ' , ii print * , 'error: eMr_EtaDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_FlowrateDn ( ii ) /= eMr_Flowrate_d2 ) then print * , 'ii = ' , ii print * , 'error: eMr_FlowrateDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_VelocityDn ( ii ) /= eMr_Velocity_d2 ) then print * , 'ii = ' , ii print * , 'error: eMr_VelocityDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_TimescaleDn ( ii ) /= eMr_Timescale_d2 ) then print * , 'ii = ' , ii print * , 'error: eMr_TimescaleDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_AreaDn ( ii ) /= eMr_Area_d2 ) then print * , 'ii = ' , ii print * , 'error: eMr_AreaDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_TopwidthDn ( ii ) /= eMr_Topwidth_d2 ) then print * , 'ii = ' , ii print * , 'error: eMr_TopwidthDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_HydDepthDn ( ii ) /= eMr_HydDepth_d2 ) then print * , 'ii = ' , ii print * , 'error: eMr_HydDepthDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_LengthDn ( ii ) /= eMr_Length_d2 ) then print * , 'ii = ' , ii print * , 'error: eMr_LengthDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_ZbottomDn ( ii ) /= eMr_Zbottom_d2 ) then print * , 'ii = ' , ii print * , 'error: eMr_ZbottomDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_BreadthScaleDn ( ii ) /= eMr_BreadthScale_d2 ) then print * , 'ii = ' , ii print * , 'error: eMr_BreadthScaleDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( nr_ElementLengthDn ( ii ) /= nr_ElementLength_d2 ) then print * , 'ii = ' , ii print * , 'error: nr_ElementLengthDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif endif ii = 3 if ( dnstream_face_per_elemM > ii - 1 ) then if ( ni_MlinkDn ( ii ) /= ni_Mlink_d3 ) then print * , 'ii = ' , ii print * , 'error: ni_MlinkDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMi_MfaceDn ( ii ) /= eMi_Mface_d3 ) then print * , 'ii = ' , ii print * , 'error: eMi_MfaceDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_EtaDn ( ii ) /= eMr_Eta_d3 ) then print * , 'ii = ' , ii print * , 'error: eMr_EtaDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_FlowrateDn ( ii ) /= eMr_Flowrate_d3 ) then print * , 'ii = ' , ii print * , 'error: eMr_FlowrateDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_VelocityDn ( ii ) /= eMr_Velocity_d3 ) then print * , 'ii = ' , ii print * , 'error: eMr_VelocityDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_TimescaleDn ( ii ) /= eMr_Timescale_d3 ) then print * , 'ii = ' , ii print * , 'error: eMr_Timescale_Dn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_AreaDn ( ii ) /= eMr_Area_d3 ) then print * , 'ii = ' , ii print * , 'error: eMr_AreaDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_TopwidthDn ( ii ) /= eMr_Topwidth_d3 ) then print * , 'ii = ' , ii print * , 'error: eMr_TopwidthDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_HydDepthDn ( ii ) /= eMr_HydDepth_d3 ) then print * , 'ii = ' , ii print * , 'error: eMr_HydDepthDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_LengthDn ( ii ) /= eMr_Length_d3 ) then print * , 'ii = ' , ii print * , 'error: eMr_LengthDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_ZbottomDn ( ii ) /= eMr_Zbottom_d3 ) then print * , 'ii = ' , ii print * , 'error: eMr_Zbottom_Dn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( eMr_BreadthScaleDn ( ii ) /= eMr_BreadthScale_d3 ) then print * , 'ii = ' , ii print * , 'error: eMr_BreadthScale_Dn(ii) unexpectedly changed in code in ' , subroutine_name stop endif if ( nr_ElementLengthDn ( ii ) /= nr_ElementLength_d3 ) then print * , 'ii = ' , ii print * , 'error: ElementLengthDn(ii) unexpectedly changed in code in ' , subroutine_name stop endif endif if ( dnstream_face_per_elemM > 3 ) then print * , 'error: code does not support dnstream_face_per_elemM > 3 in ' , subroutine_name endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine initialize_arrayindex_status ! !========================================================================== !========================================================================== ! subroutine initialize_array_zerovalues & ( elemMR ) ! ! array allocation stores a null value. For certain columns of ! some arrays we want to initialize with zero. ! character ( 64 ) :: subroutine_name = 'initialize_array_zerovalues' real , intent ( in out ) :: elemMR (:,:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name elemMR (:, eMr_Volume ) = zeroR do mm = 1 , upstream_face_per_elemM !elemMR(:,eMr_EtaUp(mm)          = zeroR elemMR (:, eMr_LengthUp ( mm )) = zeroR elemMR (:, eMr_AreaUp ( mm )) = zeroR elemMR (:, eMr_TopwidthUp ( mm )) = zeroR elemMR (:, eMr_HydDepthUp ( mm )) = zeroR enddo do mm = 1 , dnstream_face_per_elemM !elemMR(:,eMr_EtaDn(mm))         = zeroR elemMR (:, eMr_LengthDn ( mm )) = zeroR elemMR (:, eMr_AreaDn ( mm )) = zeroR elemMR (:, eMr_TopwidthDn ( mm )) = zeroR elemMR (:, eMr_HydDepthDn ( mm )) = zeroR enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine initialize_array_zerovalues ! !========================================================================== ! subroutine initialize_dummy_values & ( elem2R , elem2I , elem2YN , & elemMR , elemMI , elemMYN , & faceR , faceI , faceYN ) character ( 64 ) :: subroutine_name = 'initialize_dummy_values' integer , intent ( in out ) :: elem2I (:,:), elemMI (:,:), faceI (:,:) real , intent ( in out ) :: elem2R (:,:), elemMR (:,:), faceR (:,:) logical , intent ( in out ) :: elem2YN (:,:), elemMYN (:,:), faceYN (:,:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !% define the dummy location dummy_face_index = N_face + 1 dummy_elem2_index = N_elem2 + 1 dummy_elemM_index = N_elemM + 1 faceI ( dummy_face_index ,:) = nullvalueI faceR ( dummy_face_index ,:) = nullvalueR faceYN ( dummy_face_index ,:) = nullvalueL elem2I ( dummy_elem2_index ,:) = nullvalueI elem2R ( dummy_elem2_index ,:) = nullvalueR elem2YN ( dummy_elem2_index ,:) = nullvalueL elemMI ( dummy_elemM_index ,:) = nullvalueI elemMR ( dummy_elemM_index ,:) = nullvalueR elemMYN ( dummy_elemM_index ,:) = nullvalueL elemMI (:, eMi_MfaceUp ( 1 : upstream_face_per_elemM )) = dummy_face_index elemMI (:, eMi_MfaceDn ( 1 : dnstream_face_per_elemM )) = dummy_face_index faceI (:, fi_Melem_u ) = min ( dummy_elemM_index , dummy_elem2_index ) faceI (:, fi_Melem_d ) = min ( dummy_elemM_index , dummy_elem2_index ) elem2I (:, e2i_Mface_u ) = dummy_face_index elem2I (:, e2i_Mface_d ) = dummy_face_index if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine initialize_dummy_values ! !========================================================================== !========================================================================== ! END OF MODULE initialization !========================================================================== end module initialization","title":"initialization.f08 – SWMMengine","tags":"","loc":"sourcefile/initialization.f08.html"},{"text":"This file depends on sourcefile~~diagnostic.f08~~EfferentGraph sourcefile~diagnostic.f08 diagnostic.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~diagnostic.f08->sourcefile~type_definitions.f08 sourcefile~globals.f08 globals.f08 sourcefile~diagnostic.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~diagnostic.f08->sourcefile~setting_definition.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~diagnostic.f08->sourcefile~array_index.f08 sourcefile~bc.f08 bc.f08 sourcefile~diagnostic.f08->sourcefile~bc.f08 sourcefile~utility.f08 utility.f08 sourcefile~diagnostic.f08->sourcefile~utility.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~diagnostic.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 var pansourcefilediagnosticf08EfferentGraph = svgPanZoom('#sourcefilediagnosticf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~diagnostic.f08~~AfferentGraph sourcefile~diagnostic.f08 diagnostic.f08 sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~runge_kutta.f08->sourcefile~diagnostic.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~time_loop.f08->sourcefile~diagnostic.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~diagnostic.f08 sourcefile~main.f08->sourcefile~time_loop.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules diagnostic Source Code diagnostic.f08 Source Code ! module diagnostic ! ! Utilities that are useful for diagnosing simulation behavior ! !========================================================================== ! module diagnostic ! use array_index use bc use data_keys use globals use setting_definition use type_definitions use utility implicit none public :: diagnostic_CFL public :: diagnostic_initialize public :: diagnostic_element_volume_conservation public :: diagnostic_element_volume_conservation_fluxes public :: diagnostic_froude_number public :: diagnostic_volume_conservation private integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! pure function diagnostic_CFL & ( elemR , er_Timescale_u , er_Timescale_d ) result ( cflmax ) ! ! Computes thebarotropic + advection CFL from the timescales up and down ! real , intent ( in ) :: elemR (:,:) integer , intent ( in ) :: er_Timescale_u , er_Timescale_d real :: cflmax real :: cflu , cfld !-------------------------------------------------------------------------- !if ((debuglevel > 0) .or. (debuglevelall > 0)) print *, '*** enter ',subroutine_name cflu = maxval ( setting % Time % Dt / elemR (:, er_Timescale_u ), 1 , & ( elemR (:, er_Timescale_u ) > setting % Limiter % Timescale % Minimum ) ) cfld = maxval ( setting % Time % Dt / elemR (:, er_Timescale_d ), 1 , & ( elemR (:, er_Timescale_d ) > setting % Limiter % Timescale % Minimum ) ) cflmax = max ( cflu , cfld ) !if ((debuglevel > 0) .or. (debuglevelall > 0))  print *, '*** leave ',subroutine_name end function diagnostic_CFL ! !========================================================================== !========================================================================== ! subroutine diagnostic_element_volume_conservation_fluxes & ( elem2R , elem2I , elemMR , elemMI , faceR ) character ( 64 ) :: subroutine_name = 'diagnostic_element_volume_conservation_fluxes' real , intent ( in out ) :: elem2R (:,:), elemMR (:,:) real , intent ( in ) :: faceR (:,:) integer , target , intent ( in ) :: elem2I (:,:), elemMI (:,:) integer , pointer :: fup (:), fdn (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !% store the net volume flux through the face of continuity fup => elem2I (:, e2i_Mface_u ) fdn => elem2I (:, e2i_Mface_d ) where ( elem2I (:, e2i_elem_type ) == eChannel ) elem2R (:, e2r_VolumeConservation ) = - dt * ( faceR ( fup , fr_Flowrate ) - faceR ( fdn , fr_Flowrate ) ) endwhere where ( elemMR (:, eMi_elem_type ) == eJunctionChannel ) elemMR (:, eMr_VolumeConservation ) = zeroR endwhere do mm = 1 , upstream_face_per_elemM fup => elemMI (:, eMi_MfaceUp ( mm )) where ( ( elemMR (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMR (:, eMi_nfaces_u ) >= mm ) ) elemMR (:, eMr_VolumeConservation ) = elemMR (:, eMr_VolumeConservation ) - dt * faceR ( fup , fr_flowrate ) endwhere enddo do mm = 1 , dnstream_face_per_elemM fdn => elemMI (:, eMi_MfaceDn ( mm )) where ( ( elemMR (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMR (:, eMi_nfaces_d ) >= mm ) ) elemMR (:, eMr_VolumeConservation ) = elemMR (:, eMr_VolumeConservation ) + dt * faceR ( fdn , fr_flowrate ) endwhere enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine diagnostic_element_volume_conservation_fluxes ! !========================================================================== !========================================================================== ! subroutine diagnostic_element_volume_conservation & ( elem2R , elem2I , elemMR , elemMI , e2r_Volume_new , eMr_Volume_new ) ! ! compute local volume conservation (subtracting net change from flux volume) ! this assumes that fluxes have beens tored in VolumeConservation column ! in a prior call to diagnostic_element_volume_conservation_fluxes ! character ( 64 ) :: subroutine_name = 'diagnostic_element_volume_conservation' real , intent ( in out ) :: elem2R (:,:), elemMR (:,:) integer , intent ( in ) :: elem2I (:,:), elemMI (:,:) integer , intent ( in ) :: e2r_Volume_new , eMr_Volume_new !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name where ( elem2I (:, e2i_elem_type ) == eChannel ) elem2R (:, e2r_VolumeConservation ) = elem2R (:, e2r_VolumeConservation ) & + ( elem2R (:, e2r_Volume_new ) - elem2R (:, e2r_Volume )) endwhere where ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) elemMR (:, eMr_VolumeConservation ) = elemMR (:, eMr_VolumeConservation ) & + ( elemMR (:, eMr_Volume_new ) - elemMR (:, eMr_Volume )) endwhere ! print *, trim(subroutine_name) ! print *, elem2R(:,e2r_VolumeConservation) ! print *, elemMR(:,eMr_VolumeConservation) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine diagnostic_element_volume_conservation ! !========================================================================== !========================================================================== ! subroutine diagnostic_froude_number & ( elem2R , elem2I , elemMR , elemMI ) character ( 64 ) :: subroutine_name = 'diagnostic_froude_number' real , intent ( in out ) :: elem2R (:,:), elemMR (:,:) integer , intent ( in ) :: elem2I (:,:), elemMI (:,:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name call diagnostic_froude_number_one & ( elem2R , elem2I , e2r_FroudeNumber , e2r_Velocity , e2r_HydDepth , e2i_elem_type , eChannel ) call diagnostic_froude_number_one & ( elemMR , elemMI , eMr_FroudeNumber , eMr_Velocity , eMr_HydDepth , eMi_elem_type , eJunctionChannel ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine diagnostic_froude_number ! !========================================================================== !========================================================================== ! subroutine diagnostic_initialize & ( diagnostic , elem2R , elem2I , elemMR , elemMI , faceR , & bcdataUp , bcdataDn ) character ( 64 ) :: subroutine_name = 'diagnostic_initialize' type ( diagnosticType ), allocatable , dimension (:), intent ( out ) :: diagnostic real , intent ( in out ) :: elem2R (:,:), elemMR (:,:), faceR (:,:) integer , target , intent ( in ) :: elem2I (:,:), elemMI (:,:) type ( bcType ), intent ( in ) :: bcdataUp (:), bcdataDn (:) integer :: allocation_status , total_steps character ( len = 99 ) :: emsg !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name total_steps = setting % Step % Final - setting % Step % First + 2 !%  create the storage of data !%  note that position 1 is storage of initial conditions. allocate ( diagnostic ( total_steps ), stat = allocation_status , errmsg = emsg ) call utility_check_allocation ( allocation_status , emsg ) diagnostic % Volume % Step = 0 !% initialize all real values to zero diagnostic % Volume % Time = zeroR diagnostic % Volume % Volume = zeroR diagnostic % Volume % VolumeChange = zeroR diagnostic % Volume % NetInflowVolume = zeroR diagnostic % Volume % InflowRate = zeroR diagnostic % Volume % OutflowRate = zeroR diagnostic % Volume % ConservationThisStep = zeroR diagnostic % Volume % ConservationTotal = zeroR !% specific initializeation for volume conservation diagnostic (task = 0) call diagnostic_volume_conservation & ( diagnostic , elem2R , elem2I , elemMR , elemMI , faceR , & bcdataUp , bcdataDn , 1 , 0 ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine diagnostic_initialize ! !========================================================================== !========================================================================== ! subroutine diagnostic_volume_conservation & ( diagnostic , elem2R , elem2I , elemMR , elemMI , faceR , & bcdataUp , bcdataDn , thisStep , diagnosticTask ) ! ! handles volume conservation diagnostic !   diagnosticTask = 0 -> initialize !   diagnosticTask = 1 -> compute starting volume or transfer end volume to start !   diagnosticTask = 2 -> compute volume change and BC flows ! character ( 64 ) :: subroutine_name = 'diagnostic_volume_conservation' type ( diagnosticType ), intent ( in out ) :: diagnostic (:) real , intent ( in out ) :: elem2R (:,:), elemMR (:,:), faceR (:,:) integer , target , intent ( in ) :: elem2I (:,:), elemMI (:,:) type ( bcType ), intent ( in ) :: bcdataUp (:), bcdataDn (:) integer , intent ( in ) :: thisStep integer , intent ( in ) :: diagnosticTask integer , pointer :: etype2 (:), etypeM (:) real :: channelVolume , junctionVolume , totalVolume real :: inflowRate , outflowRate !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name etype2 => elem2I (:, e2i_elem_type ) etypeM => elemMI (:, eMi_elem_type ) channelVolume = sum ( elem2R (:, e2r_Volume ), 1 , etype2 == eChannel ) junctionVolume = sum ( elemMR (:, eMr_Volume ), 1 , etypeM == eJunctionChannel ) totalVolume = channelVolume + junctionVolume select case ( diagnosticTask ) case ( 0 ) !%  reset the accumulation storage diagnostic ( thisStep )% Volume % ConservationTotal = zeroR case ( 1 ) !%  store only the volume (required prior to first step) diagnostic ( thisStep )% Volume % Volume = totalVolume diagnostic ( thisStep )% Volume % Step = setting % Step % Current diagnostic ( thisStep )% Volume % Time = setting % Time % ThisTime case ( 2 ) !% store switch the previous \"this\" volume to \"last\" !% update this volume diagnostic ( thisStep )% Volume % Step = setting % Step % Current diagnostic ( thisStep )% Volume % Time = setting % Time % ThisTime diagnostic ( thisStep )% Volume % Volume = totalVolume diagnostic ( thisStep )% Volume % VolumeChange = totalVolume & - diagnostic ( thisStep - 1 )% Volume % Volume call total_inout_flowrate & ( inflowRate , outflowRate , faceR , bcdataUp , bcdataDn ) diagnostic ( thisStep )% Volume % InflowRate = inflowRate diagnostic ( thisStep )% Volume % OutflowRate = outflowRate diagnostic ( thisStep )% Volume % NetInflowVolume = & ( diagnostic ( thisStep )% Volume % InflowRate - diagnostic ( thisStep )% Volume % OutflowRate ) * dt diagnostic ( thisStep )% Volume % ConservationThisStep = & diagnostic ( thisStep )% Volume % VolumeChange & - diagnostic ( thisStep )% Volume % NetInflowVolume diagnostic ( thisStep )% Volume % ConservationTotal = & diagnostic ( thisStep - 1 )% Volume % ConservationTotal & + diagnostic ( thisStep )% Volume % ConservationThisStep case default print * , 'error: unknown value for diagnosticTask in ' , trim ( subroutine_name ) print * , diagnosticTask stop end select if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine diagnostic_volume_conservation ! !========================================================================== ! ! PRIVATE BELOW HERE ! !========================================================================== ! subroutine diagnostic_froude_number_one & ( elemR , elemI , er_FroudeNumber , er_Velocity , er_HydDepth , ei_elem_type , thisType ) character ( 64 ) :: subroutine_name = 'diagnostic_froude_number_one' real , intent ( in out ) :: elemR (:,:) integer , intent ( in ) :: elemI (:,:) integer , intent ( in ) :: er_FroudeNumber , er_Velocity , er_HydDepth integer , intent ( in ) :: ei_elem_type , thisType !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name where ( elemI (:, ei_elem_type ) == thisType ) elemR (:, er_FroudeNumber ) = elemR (:, er_Velocity ) / sqrt ( grav * elemR (:, er_HydDepth )) endwhere if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine diagnostic_froude_number_one ! !========================================================================== !========================================================================== ! subroutine total_inout_flowrate & ( inflowRate , outflowRate , faceR , bcdataUp , bcdataDn ) character ( 64 ) :: subroutine_name = 'total_inout_flowrate' real , target , intent ( in ) :: faceR (:,:) type ( bcType ), target , intent ( in ) :: bcdataUp (:), bcdataDn (:) real , intent ( out ) :: inflowRate , outflowRate !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name inflowRate = zeroR outflowRate = zeroR call inout_flowrate_from_bcdata & ( inflowRate , outflowRate , faceR , bcdataUp ) call inout_flowrate_from_bcdata & ( inflowRate , outflowRate , faceR , bcdataDn ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine total_inout_flowrate ! !========================================================================== !========================================================================== ! subroutine inout_flowrate_from_bcdata & ( inflowRate , outflowRate , faceR , bcdata ) ! ! adds the inflow rate and outflow rate from bcdata to the ! accumulators inflowRate and outflowRate character ( 64 ) :: subroutine_name = 'inout_flowrate_from_bcdata' real , target , intent ( in ) :: faceR (:,:) type ( bcType ), target , intent ( in ) :: bcdata (:) real , intent ( in out ) :: inflowRate , outflowRate integer :: mm integer , pointer :: fID , bupdn real , pointer :: flowrate !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do mm = 1 , size ( bcdata ) flowrate => bcdata ( mm )% ThisFlowrate bupdn => bcdata ( mm )% Updn if ( bupdn == bc_updn_downstream ) then !%  downstream boundaries are inflows if negative, outflows if positive if ( flowrate < zeroR ) then inflowRate = inflowRate - flowrate else outflowRate = outflowRate + flowrate endif elseif ( bupdn == bc_updn_upstream ) then !%  upstream boundaries are outflows if negative, inflows if positive if ( flowrate < zeroR ) then outflowRate = outflowRate - flowrate else inflowRate = inflowRate + flowrate endif else print * , 'error: unknown value for bcdata%Updn in ' , trim ( subroutine_name ) print * , mm , bcdata ( mm )% Updn stop endif enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine inout_flowrate_from_bcdata ! !========================================================================== ! END OF MODULE diagnostic !========================================================================== end module diagnostic","title":"diagnostic.f08 – SWMMengine","tags":"","loc":"sourcefile/diagnostic.f08.html"},{"text":"This file depends on sourcefile~~friction_model.f08~~EfferentGraph sourcefile~friction_model.f08 friction_model.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~friction_model.f08->sourcefile~setting_definition.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~friction_model.f08->sourcefile~data_keys.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~friction_model.f08->sourcefile~array_index.f08 sourcefile~globals.f08 globals.f08 sourcefile~friction_model.f08->sourcefile~globals.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules friction_model Source Code friction_model.f08 Source Code !========================================================================== ! module friction_model ! ! Compute the friction term used in the time advance ! Note that this is done separately so that it can be limited to prevent ! overestimation of explicit friction when flow is reversing. ! use array_index use data_keys use globals use setting_definition implicit none private public :: friction_on_element integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine friction_on_element & ( elemR , elemI , er_Friction , er_Velocity , er_Volume , & er_Roughness , er_HydRadius , ei_elem_type , ei_roughness_type , ThisElemType ) ! ! friction term in momentum on one type of element ! The general form is grav * volume * FrictionSlope ! This model uses Manning's n form for FrictionSlope ! character ( 64 ) :: subroutine_name = 'friction_on_element' real , target , intent ( in out ) :: elemR (:,:) integer , intent ( in ) :: elemI (:,:) integer , intent ( in ) :: er_Friction , er_Velocity , er_Volume integer , intent ( in ) :: er_Roughness , er_HydRadius integer , intent ( in ) :: ei_elem_type , ei_roughness_type integer , intent ( in ) :: ThisElemType real , pointer :: friction (:), velocity (:), volume (:), manningsn (:), rh (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name friction => elemR (:, er_Friction ) velocity => elemR (:, er_Velocity ) volume => elemR (:, er_Volume ) manningsn => elemR (:, er_Roughness ) rh => elemR (:, er_HydRadius ) where ( ( elemI (:, ei_elem_type ) == ThisElemType ) . and . & ( elemI (:, ei_roughness_type ) == eManningsN ) ) friction = sign ( grav * ( manningsn ** 2 ) * ( velocity ** 2 ) * volume / ( rh ** ( 4.0 / 3.0 )), velocity ) endwhere if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine friction_on_element ! !========================================================================== ! END OF MODULE friction_model !========================================================================== end module friction_model","title":"friction_model.f08 – SWMMengine","tags":"","loc":"sourcefile/friction_model.f08.html"},{"text":"This file depends on sourcefile~~test_cases.f08~~EfferentGraph sourcefile~test_cases.f08 test_cases.f08 sourcefile~globals.f08 globals.f08 sourcefile~test_cases.f08->sourcefile~globals.f08 sourcefile~case_y_channel.f08 case_y_channel.f08 sourcefile~test_cases.f08->sourcefile~case_y_channel.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~test_cases.f08->sourcefile~setting_definition.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~test_cases.f08->sourcefile~array_index.f08 sourcefile~case_simple_channel.f08 case_simple_channel.f08 sourcefile~test_cases.f08->sourcefile~case_simple_channel.f08 sourcefile~bc.f08 bc.f08 sourcefile~test_cases.f08->sourcefile~bc.f08 sourcefile~utility.f08 utility.f08 sourcefile~test_cases.f08->sourcefile~utility.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~test_cases.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~case_y_channel.f08->sourcefile~globals.f08 sourcefile~case_y_channel.f08->sourcefile~setting_definition.f08 sourcefile~case_y_channel.f08->sourcefile~array_index.f08 sourcefile~case_y_channel.f08->sourcefile~bc.f08 sourcefile~case_y_channel.f08->sourcefile~data_keys.f08 sourcefile~allocate_storage.f08 allocate_storage.f08 sourcefile~case_y_channel.f08->sourcefile~allocate_storage.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~case_simple_channel.f08->sourcefile~globals.f08 sourcefile~case_simple_channel.f08->sourcefile~setting_definition.f08 sourcefile~case_simple_channel.f08->sourcefile~array_index.f08 sourcefile~case_simple_channel.f08->sourcefile~bc.f08 sourcefile~case_simple_channel.f08->sourcefile~data_keys.f08 sourcefile~case_simple_channel.f08->sourcefile~allocate_storage.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~allocate_storage.f08->sourcefile~globals.f08 sourcefile~allocate_storage.f08->sourcefile~array_index.f08 sourcefile~allocate_storage.f08->sourcefile~utility.f08 var pansourcefiletest_casesf08EfferentGraph = svgPanZoom('#sourcefiletest_casesf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~test_cases.f08~~AfferentGraph sourcefile~test_cases.f08 test_cases.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~test_cases.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules test_cases Source Code test_cases.f08 Source Code ! module test_cases ! ! Calling routines for custom test cases, e.g. calls the case_simple_channel ! functions to setup a single channel reach. ! !========================================================================== ! module test_cases ! use array_index use bc use case_simple_channel use case_y_channel use data_keys use globals use setting_definition use utility implicit none private public :: test_case_initiation integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine test_case_initiation & ( linkR , nodeR , linkI , nodeI , linkYN , nodeYN , linkName , nodeName , & bcdataDn , bcdataUp ) character ( 64 ) :: subroutine_name = 'test_case_initiation' integer , dimension (:,:), allocatable , intent ( out ) :: linkI integer , dimension (:,:), allocatable , intent ( out ) :: nodeI real , dimension (:,:), allocatable , intent ( out ) :: linkR real , dimension (:,:), allocatable , intent ( out ) :: nodeR logical , dimension (:,:), allocatable , intent ( out ) :: linkYN logical , dimension (:,:), allocatable , intent ( out ) :: nodeYN type ( string ), dimension (:), allocatable , intent ( out ) :: linkName type ( string ), dimension (:), allocatable , intent ( out ) :: nodeName type ( bcType ), dimension (:), allocatable , intent ( out ) :: bcdataUp , bcdataDn real , dimension (:), allocatable :: depth_dnstream , depth_upstream real , dimension (:), allocatable :: subdivide_length , channel_length , channel_breadth real , dimension (:), allocatable :: lowerZ , upperZ , flowrate real , dimension (:), allocatable :: area , velocity , Froude , ManningsN integer , dimension (:), allocatable :: idepth_type real :: CFL integer :: first_step , last_step , display_interval , mm real :: climit , cvel , uz , lz !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name select case ( setting % TestCase % TestName ) !% Write a new case statement for each unique test case case ( 'simple_channel_001' ) N_link = 1 N_node = 1 N_BCupstream = 1 N_BCdnstream = 1 !% create the local variables that must be populated to set up the test case call control_variable_allocation & ( depth_dnstream , depth_upstream , lowerZ , upperZ , channel_length , & channel_breadth , subdivide_length , flowrate , area , & velocity , Froude , ManningsN , idepth_type ) ! step controls display_interval = 1000 first_step = 1 last_step = 10000 ! note 1000 is good enough to show blow up or not, 10000 is smooth ! set up flow and time step for differen subcases ! tests that ran:  Fr = 0.25, 0.5 Froude = 0.25 ! determines flowrate and slope to get Froude CFL = 0.25 ! determines dt from subdivide_length ! keep these physics fixed channel_breadth = 3.0 depth_upstream = 1.0 depth_dnstream = 1.0 idepth_type = 1 !1 = uniform, 2=linear, 3=exponential decay ManningsN = 0.03 channel_length = 1000 0.0 lowerZ = 1.0 subdivide_length = 500 0.0 call froude_driven_setup & ( upperZ ( 1 ), area ( 1 ), flowrate ( 1 ), velocity ( 1 ), & Froude ( 1 ), channel_breadth ( 1 ), ManningsN ( 1 ), channel_length ( 1 ), & lowerZ ( 1 ), depth_upstream ( 1 ) ) call this_setting_for_time_and_steps & ( CFL , velocity , depth_upstream , subdivide_length , & first_step , last_step , display_interval , 2 ) call case_simple_channel_initialize & ( channel_length ( 1 ), channel_breadth ( 1 ), subdivide_length ( 1 ), & lowerZ ( 1 ), upperZ ( 1 ), flowrate ( 1 ), depth_upstream ( 1 ), depth_dnstream ( 1 ), & ManningsN ( 1 ), lManningsN , idepth_type ( 1 ), & linkR , nodeR , linkI , nodeI , linkYN , nodeYN , linkName , nodeName , & bcdataDn , bcdataUp ) if (. not . setting % Debugout % SuppressAllFiles ) then call write_testcase_setup_file & ( Froude , CFL , flowrate , velocity , depth_upstream , & depth_dnstream , channel_breadth , area , & channel_length , subdivide_length , & lowerZ , upperZ , ManningsN ) endif !print *, flowrate, depth_dnstream !stop case ( 'y_channel_002' ) N_link = 3 N_node = 4 N_BCupstream = 2 N_BCdnstream = 1 call control_variable_allocation & ( depth_dnstream , depth_upstream , lowerZ , upperZ , channel_length , & channel_breadth , subdivide_length , flowrate , area , & velocity , Froude , ManningsN , idepth_type ) ! step controls display_interval = 1000 first_step = 1 last_step = 10000 ! note 1000 is good enough to show blow up or not, 10000 is smooth ! set up flow and time step for differen subcases ! tests that ran:  Fr = 0.25, 0.5 Froude ( 1 ) = 0.8 ! determines flowrate and slope to get Froude Froude ( 2 ) = 0.8 ! determines flowrate and slope to get Froude Froude ( 3 ) = 0.8 ! determines flowrate and slope to get Froude CFL = 0.6 ! determines dt from subdivide_length depth_dnstream ( 1 ) = 1.0 depth_upstream ( 1 ) = 1.0 ! junction depth_dnstream ( 2 : 3 ) = depth_upstream ( 1 ) ! junction should be consistent depth_upstream ( 2 ) = 1.0 ! upstream bc right depth_upstream ( 3 ) = 1.0 ! upstream bc left idepth_type = 1 !1 = uniform, 2=linear, 3=exponential decay ManningsN = 0.03 channel_breadth ( 1 ) = 3.0 channel_breadth ( 2 ) = 3.0 channel_breadth ( 3 ) = 3.0 channel_length ( 1 ) = 100 0.0 channel_length ( 2 ) = 100 0.0 channel_length ( 3 ) = 100 0.0 lowerZ ( 1 ) = 1.0 subdivide_length ( 1 ) = 10 0.0 subdivide_length ( 2 ) = 10 0.0 subdivide_length ( 3 ) = 10 0.0 ! get consistent bottom Z values for the desired Froude number in each link do mm = 1 , N_link if ( mm == 1 ) then ! start with the Z for the inflow link lz = lowerZ ( 1 ) end if call froude_driven_setup & ( uz , area ( mm ), flowrate ( mm ), velocity ( mm ), & Froude ( mm ), channel_breadth ( mm ), ManningsN ( mm ), channel_length ( mm ), & lz , depth_upstream ( mm ) ) select case ( mm ) case ( 1 ) ! the upstream z of the downstream link becomes the lower z of the upstream links lz = uz upperZ ( 1 ) = uz case ( 2 , 3 ) lowerZ ( mm ) = upperZ ( 1 ) upperZ ( mm ) = uz lz = upperZ ( 1 ) end select end do call this_setting_for_time_and_steps & ( CFL , velocity , depth_upstream , subdivide_length , first_step , last_step , & display_interval , 2 ) call case_y_channel_initialize & ( channel_length , channel_breadth , subdivide_length , lowerZ , upperZ , & flowrate , depth_upstream , depth_dnstream , & ManningsN , lManningsN , idepth_type , & linkR , nodeR , linkI , nodeI , linkYN , nodeYN , linkName , nodeName , & bcdataDn , bcdataUp ) if (. not . setting % Debugout % SuppressAllFiles ) then call write_testcase_setup_file & ( Froude , CFL , flowrate , velocity , depth_upstream , & depth_dnstream , channel_breadth , area , channel_length , subdivide_length , & lowerZ , upperZ , ManningsN ) endif !print *, flowrate !print *, linkR(:,lr_InitialFlowrate) !print *, trim(subroutine_name) !stop case default print * , setting % TestCase % TestName print * , 'error: no valid test case of ' ,& trim ( setting % TestCase % TestName ), ' in ' , subroutine_name stop end select if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine test_case_initiation ! !========================================================================== ! ! PRIVATE BELOW HERE ! !========================================================================== ! subroutine control_variable_allocation & ( depth_dnstream , depth_upstream , lowerZ , upperZ , channel_length , & channel_breadth , subdivide_length , flowrate , area , & velocity , Froude , ManningsN , idepth_type ) character ( 64 ) :: subroutine_name = 'control_variable_allocation' real , dimension (:), allocatable , intent ( out ) :: depth_dnstream , depth_upstream real , dimension (:), allocatable , intent ( out ) :: subdivide_length , channel_length , channel_breadth real , dimension (:), allocatable , intent ( out ) :: lowerZ , upperZ , flowrate real , dimension (:), allocatable , intent ( out ) :: area , velocity , Froude , ManningsN integer , dimension (:), allocatable , intent ( out ) :: idepth_type !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name allocate ( depth_dnstream ( N_link )) allocate ( depth_upstream ( N_link )) allocate ( lowerZ ( N_link )) allocate ( upperZ ( N_link )) allocate ( channel_length ( N_link )) allocate ( channel_breadth ( N_link )) allocate ( subdivide_length ( N_link )) !allocate(initial_flowrate(N_link)) allocate ( area ( N_link )) allocate ( velocity ( N_link )) allocate ( flowrate ( N_link )) allocate ( Froude ( N_link )) allocate ( ManningsN ( N_link )) allocate ( idepth_type ( N_link )) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine control_variable_allocation ! !========================================================================== !========================================================================== ! subroutine this_setting_for_time_and_steps & ( CFL , velocity , depth , subdivide_length , first_step , last_step , & display_interval , dt_significant_digits ) character ( 64 ) :: subroutine_name = 'this_setting_for_time_and_steps' real , intent ( in ) :: CFL , velocity (:), depth (:), subdivide_length (:) integer , intent ( in ) :: first_step , last_step , display_interval , dt_significant_digits real , dimension ( size ( velocity )) :: dtSet , CFLset real :: dtmin integer :: dtscale !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name ! use the same CFL in every link CFLset = CFL ! get the set of time step (dt) base on every branch dtSet = get_dt_from_CFL ( CFL , velocity , depth , subdivide_length ) ! get the minimum dt value dtmin = minval ( dtSet ) ! get the largest n for 10&#94;n relative to the dtmin dtscale = utility_scale_of_number ( dtmin ) setting % Time % dt = utility_round_to_significant_digits ( dtmin , dt_significant_digits ) setting % Step % Current = 1 setting % Step % First = first_step setting % Step % Final = last_step setting % Debugout % DisplayInterval = display_interval setting % OutputThreadedLink % DisplayInterval = display_interval setting % Time % StartTime = 0.0 setting % Time % EndTime = setting % Time % StartTime & + setting % Time % dt * ( setting % Step % Final - setting % Step % First + 1 ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine this_setting_for_time_and_steps ! !========================================================================== !========================================================================== ! subroutine froude_driven_setup & ( upperZ , area , flowrate , velocity , & Froude , breadth , ManningsN , total_length , & lowerZ , depth ) character ( 64 ) :: subroutine_name = 'froude_driven_setup' real , intent ( out ) :: area , flowrate , velocity , upperZ real , intent ( in ) :: Froude , breadth , ManningsN , lowerZ , total_length real , intent ( in ) :: depth real :: perimeter , rh , slope !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name area = depth * breadth perimeter = 2.0 * depth + breadth rh = area / perimeter velocity = Froude * sqrt ( grav * depth ) flowrate = area * velocity slope = ( velocity * ManningsN / ( rh ** ( 2.0 / 3.0 )) ) ** 2 upperZ = lowerZ + slope * total_length ! print *, area ! print *, perimeter ! print *, rh ! print *, velocity ! print *, flowrate ! print *, slope ! print *, upperZ, lowerZ ! print *, total_length ! print *, slope*total_length if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine froude_driven_setup ! !========================================================================== !========================================================================== ! subroutine write_testcase_setup_file & ( Froude , CFL , flowrate , velocity , depth_upstream , depth_dnstream , breadth , & area , total_length , subdivide_length , lowerZ , upperZ , ManningsN ) character ( 64 ) :: subroutine_name = ' write_testcase_setup_file' real , intent ( in ) :: CFL real , intent ( in ) :: Froude (:), flowrate (:), velocity (:), breadth (:) real , intent ( in ) :: area (:), total_length (:), subdivide_length (:), lowerZ (:), upperZ (:) real , intent ( in ) :: ManningsN (:), depth_upstream (:), depth_dnstream (:) integer :: UnitNumber character ( 64 ) :: thisFilePath , thisFileStatus , thisFileName character ( 256 ) :: thisFileWriteName logical :: thisFileisOpen = . false . integer :: open_status character ( len = 512 ) :: emsg !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name open_status = 0 UnitNumber = outputfile_next_unitnumber outputfile_next_unitnumber = outputfile_next_unitnumber + 1 thisFileName = trim ( setting % TestCase % TestName ) thisFilePath = trim ( setting % DebugOut % FolderPath ) & // trim ( setting % Debugout % FolderName ) // '/' thisFileStatus = 'new' thisFileIsOpen = . true . thisFileWriteName = trim ( thisFilePath ) // & trim ( thisFileName ) // & trim ( setting % Time % DateTimeStamp ) // & '.txt' ! print *, trim(setting%TestCase%TestName) ! print *, trim(setting%DebugOut%FolderPath) ! print *, trim(setting%Debugout%FolderName) ! ! print *, trim(thisFileName) ! print *, trim(thisFilePath) ! print *, trim(thisFileWriteName) ! stop ! open ( unit = UnitNumber , & file = trim ( thisFileWriteName ), & status = 'new' , & access = 'sequential' , & form = 'formatted' , & action = 'write' , & iostat = open_status ) emsg = 'file exists: file open failed in ' // trim ( subroutine_name ) & // '; filename = ' // trim ( thisFileWriteName ) call utility_check_fileopen ( open_status , emsg ) write ( UnitNumber , * ) trim ( setting % TestCase % TestName ) write ( UnitNumber , * ) trim ( setting % Time % DateTimeStamp ) write ( UnitNumber , * ) write ( UnitNumber , * ) Froude , '=Froude' write ( UnitNumber , * ) CFL , '=CFL combined' write ( UnitNumber , * ) velocity * setting % Time % Dt / subdivide_length , '=CFL advective' write ( UnitNumber , * ) sqrt ( grav * depth_upstream ) * setting % Time % DT / subdivide_length , '=CFL barotropic' write ( UnitNumber , * ) write ( UnitNumber , * ) flowrate , '=flowrate' write ( UnitNumber , * ) velocity , '=velocity' write ( UnitNumber , * ) setting % Time % Dt , ' = dt' write ( UnitNumber , * ) write ( UnitNumber , * ) depth_upstream , '=depth upstream' write ( UnitNumber , * ) depth_dnstream , '=depth downstream' write ( UnitNumber , * ) breadth , '=breadth' write ( UnitNumber , * ) area , '=area' write ( UnitNumber , * ) total_length , '=total_length' write ( UnitNumber , * ) subdivide_length , '=subdivide_length' write ( UnitNumber , * ) area * subdivide_length , '=element_volume' write ( UnitNumber , * ) lowerZ , '=lowerZ' write ( UnitNumber , * ) upperZ , '=upperZ' write ( UnitNumber , * ) ( upperZ - lowerZ ) / total_length , '=slope' write ( UnitNumber , * ) write ( UnitNumber , * ) ManningsN , '=ManningsN' write ( UnitNumber , * ) write ( UnitNumber , * ) setting % Step % First , '=first step' write ( UnitNumber , * ) setting % Step % Final , '=last step' write ( UnitNumber , * ) setting % Time % StartTime , '=start time' write ( UnitNumber , * ) setting % Time % EndTime , '=end time' write ( UnitNumber , * ) close ( UnitNumber ) outputfile_next_unitnumber = outputfile_next_unitnumber - 1 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine write_testcase_setup_file ! !========================================================================== !========================================================================== ! elemental function get_dt_from_CFL & ( CFL , velocity , depth , element_length ) & result ( dt ) ! character(64) :: subroutine_name = 'get_dt_from_CFL' real , intent ( in ) :: CFL , velocity , depth , element_length real :: dt !-------------------------------------------------------------------------- dt = CFL * onehalfR * element_length / ( velocity + sqrt ( grav * depth )) end function get_dt_from_CFL ! !========================================================================== ! END OF MODULE test_cases !========================================================================== end module test_cases","title":"test_cases.f08 – SWMMengine","tags":"","loc":"sourcefile/test_cases.f08.html"},{"text":"This file depends on sourcefile~~element_geometry.f08~~EfferentGraph sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~globals.f08 globals.f08 sourcefile~element_geometry.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~element_geometry.f08->sourcefile~setting_definition.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~element_geometry.f08->sourcefile~array_index.f08 sourcefile~adjustments.f08 adjustments.f08 sourcefile~element_geometry.f08->sourcefile~adjustments.f08 sourcefile~junction.f08 junction.f08 sourcefile~element_geometry.f08->sourcefile~junction.f08 sourcefile~bc.f08 bc.f08 sourcefile~element_geometry.f08->sourcefile~bc.f08 sourcefile~utility.f08 utility.f08 sourcefile~element_geometry.f08->sourcefile~utility.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~element_geometry.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~adjustments.f08->sourcefile~globals.f08 sourcefile~adjustments.f08->sourcefile~setting_definition.f08 sourcefile~adjustments.f08->sourcefile~array_index.f08 sourcefile~adjustments.f08->sourcefile~utility.f08 sourcefile~adjustments.f08->sourcefile~data_keys.f08 sourcefile~junction.f08->sourcefile~globals.f08 sourcefile~junction.f08->sourcefile~setting_definition.f08 sourcefile~junction.f08->sourcefile~array_index.f08 sourcefile~junction.f08->sourcefile~utility.f08 sourcefile~junction.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 var pansourcefileelement_geometryf08EfferentGraph = svgPanZoom('#sourcefileelement_geometryf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~element_geometry.f08~~AfferentGraph sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~initial_condition.f08 initial_condition.f08 sourcefile~initial_condition.f08->sourcefile~element_geometry.f08 sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~runge_kutta.f08->sourcefile~element_geometry.f08 sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~explicit_euler.f08->sourcefile~element_geometry.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~time_loop.f08->sourcefile~explicit_euler.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~initial_condition.f08 sourcefile~main.f08->sourcefile~time_loop.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules element_geometry Source Code element_geometry.f08 Source Code ! ! module element_geometry ! ! Updates the geometry of elements ! ! Later this may be broken into separate modules for channels, pipes ! junctions, etc. ! !========================================================================== ! module element_geometry ! use adjustments use array_index use bc use data_keys use junction use setting_definition use globals use utility implicit none private public :: element_geometry_update public :: element_geometry_branch_fix integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine element_geometry_update & ( elem2R , elem2I , elem2YN , e2r_VolumeColumn , & elemMR , elemMI , elemMYN , eMr_VolumeColumn , & faceR , faceI , bcdataDn , bcdataUp , thisTime , method_EtaM ) ! ! Note that volume is handled as a separate temporary index location ! (rather than from the elemR(:,er_Volume) array) because we use ! this for the geometry update associated with an RK step where intermediate ! storage is used ! character ( 64 ) :: subroutine_name = 'element_geometry_update' real , target , intent ( in out ) :: elem2R (:,:), elemMR (:,:) integer , target , intent ( in out ) :: elem2I (:,:), elemMI (:,:) logical , target , intent ( in out ) :: elem2YN (:,:), elemMYN (:,:) integer , intent ( in ) :: faceI (:,:) integer , intent ( in ) :: e2r_VolumeColumn , eMr_VolumeColumn real , intent ( in ) :: faceR (:,:), thisTime type ( bcType ), intent ( in out ) :: bcdataDn (:), bcdataUp (:) integer , intent ( in ) :: method_EtaM integer :: eMr_EtaOld real , pointer :: etaold (:) integer , parameter :: ilocaldummy = 0 !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !%  assign temporary storage for old free surfac elevation on junctions eMr_EtaOld = eMr_Temp ( next_eMr_temparray ) etaold => elemMR (:, eMr_EtaOld ) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) etaold = elemMR (:, eMr_Eta ) !% reset values for small volume ahndling if ( setting % SmallVolume % UseSmallVolumes ) then elem2YN (:, e2YN_IsSmallVolume ) = . false . elemMYN (:, eMYN_IsSmallVolume ) = . false . elem2R (:, e2r_SmallVolumeRatio ) = nullvalueR elemMR (:, eMr_SmallVolumeRatio ) = nullvalueR endif !% apply any elevation bc and fix the element volume call bc_applied_onelement & ( elem2R , bcdataDn , bcdataUp , thisTime , bc_category_elevation , ilocaldummy ) !% rectangular geometry call rectangular_geometry_update & ( elem2R , elem2I , e2r_VolumeColumn , & elemMR , elemMI , eMr_VolumeColumn , faceR , eMr_EtaOld , method_EtaM ) !% HACK -- NEED OTHER GEOMETRY TYPES !% reset the computed geometry values where volumes are small if ( setting % SmallVolume % UseSmallVolumes ) then call adjust_smallvolumes & ( elem2R , elem2I , elem2YN , e2r_VolumeColumn , & elemMR , elemMI , elemMYN , eMr_VolumeColumn ) endif !% reset the geometry (non-volume) where values are below minimums call adjust_for_zero_geometry ( elem2R , elem2YN , elemMR , elemMI , elemMYN ) !%  release the temp array etaold = nullvalueR nullify ( etaold ) next_eMr_temparray = next_eMr_temparray - 1 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine element_geometry_update ! !========================================================================== !========================================================================== ! subroutine element_geometry_branch_fix & ( elemMR , elemMI , faceR , faceI ) ! ! called after face update to provide update to junction branches ! character ( 64 ) :: subroutine_name = 'element_geometry_branch_fix' real , target , intent ( in out ) :: elemMR (:,:) real , intent ( in ) :: faceR (:,:) integer , intent ( in ) :: elemMI (:,:), faceI (:,:) integer :: eMr_totalarea real , pointer :: totalarea (:) integer , parameter :: ilocaldummy = 0 !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name eMr_totalarea = eMr_Temp ( next_eMr_temparray ) totalarea => elemMR (:, eMr_totalarea ) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) !% readjust branches geometry based on new face eta values ----------------- !%  upstream branches. Note the use of fr_Eta_d for upstream values is logically !%  correct as you want the downstream value on the upstream face. !%  Note that ilocaldummy=0 because the old eta is not required for the !%  second update. call rectangular_junction_leg & ( elemMR , elemMI , faceR , upstream_face_per_elemM , eMi_nfaces_u , eMi_MfaceUp , & eMr_AreaUp , eMr_ZbottomUp , eMr_BreadthScaleUp , & eMr_TopwidthUp , eMr_EtaUp , eMr_HydDepthUp , ilocaldummy , fr_Eta_d , 2 ) !%  downstream branches call rectangular_junction_leg & ( elemMR , elemMI , faceR , dnstream_face_per_elemM , eMi_nfaces_d , eMi_MfaceDn , & eMr_AreaDn , eMr_ZbottomDn , eMr_BreadthScaleDn , & eMr_TopwidthDn , eMr_EtaDn , eMr_HydDepthDn , ilocaldummy , fr_Eta_u , 2 ) !% readjust branch flows for updated areas ----------------------------- !%  get the total outflow branch areas totalarea = zeroR ! ensure temporary array is zero call junction_branch_sum_areas_by_direction & ( eMR_totalarea , & dnstream_face_per_elemM , eMr_AreaDn , eMi_MfaceDn , eMi_nfaces_d , & upstream_face_per_elemM , eMr_AreaUp , eMi_MfaceUp , eMi_nfaces_u , & elemMR , elemMI , faceR ) !%  distribute flow proportionally among outflows call junction_branch_velocity_and_flowrate_proportional_to_area & ( eMR_totalarea , eMR_Flowrate , & dnstream_face_per_elemM , eMr_AreaDn , eMi_MfaceDn , eMi_nfaces_d , & eMr_FlowrateDn , eMr_VelocityDn , & upstream_face_per_elemM , eMr_AreaUp , eMi_MfaceUp , eMi_nfaces_u , & eMr_FlowrateUp , eMr_VelocityUp , & elemMR , elemMI , faceR ) !%  enforce maximum velocities in junction branches call adjust_junction_branch_velocity_limit ( elemMR , elemMI ) totalarea = nullvalueR nullify ( totalarea ) next_eMr_temparray = next_eMr_temparray - 1 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine element_geometry_branch_fix ! !========================================================================== ! ! PRIVATE BELOW HERE ! !========================================================================== ! subroutine rectangular_geometry_update & ( elem2R , elem2I , e2r_Volume_new , & elemMR , elemMI , eMr_Volume_new , faceR , eMr_EtaOld , method_EtaM ) ! ! Note that volume used is in a eTr storage location so that the update ! can be used on a temporary volume ! character ( 64 ) :: subroutine_name = 'rectangular_geometry_update' real , intent ( in out ) :: elem2R (:,:), elemMR (:,:) real , intent ( in ) :: faceR (:,:) integer , intent ( in ) :: elem2I (:,:), elemMI (:,:) integer , intent ( in ) :: e2r_Volume_new , eMr_Volume_new , eMr_EtaOld integer , intent ( in ) :: method_EtaM !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !%  basic geometry update for rectangular channels and junctions !%  rectangular geometry for channels call rectangular_channel_or_junction & ( elem2R , elem2I , & e2i_geometry , e2i_elem_type , eChannel , & e2r_Length , e2r_Zbottom , e2r_BreadthScale , e2r_Topwidth , e2r_Area , e2r_Eta , & e2r_Perimeter , e2r_HydDepth , e2r_HydRadius , e2r_Volume_new ) !%  rectangular geomety for junctions call rectangular_channel_or_junction & ( elemMR , elemMI , & eMi_geometry , eMi_elem_type , eJunctionChannel , & eMr_Length , eMr_Zbottom , eMr_BreadthScale , eMr_Topwidth , eMr_Area , eMr_Eta , & eMr_Perimeter , eMr_HydDepth , eMr_HydRadius , eMr_Volume_new ) !% upstream branches !% note the fr_Eta_d is used for the upstream face, whose downstream eta is !% seen by the upstream junction branch -- so the d is correct while other !% values are Up! call rectangular_junction_leg & ( elemMR , elemMI , faceR , upstream_face_per_elemM , eMi_nfaces_u , eMi_MfaceUp , & eMr_AreaUp , eMr_ZbottomUp , eMr_BreadthScaleUp , & eMr_TopwidthUp , eMr_EtaUp , eMr_HydDepthUp , eMr_EtaOld , fr_Eta_d , method_EtaM ) !%  downstream branches call rectangular_junction_leg & ( elemMR , elemMI , faceR , dnstream_face_per_elemM , eMi_nfaces_d , eMi_MfaceDn , & eMr_AreaDn , eMr_ZbottomDn , eMr_BreadthScaleDn , & eMr_TopwidthDn , eMr_EtaDn , eMr_HydDepthDn , eMr_EtaOld , fr_Eta_u , method_EtaM ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine rectangular_geometry_update ! !========================================================================== !========================================================================== ! subroutine rectangular_channel_or_junction & ( elemR , elemI , & ei_geometry , ei_elem_type , elem_typ_value , & er_Length , er_Zbottom , er_BreadthScale , er_Topwidth , er_Area , er_Eta , & er_Perimeter , er_HydDepth , er_HydRadius , er_Volume ) ! ! computes element geometry for a rectangular channel or a channeljunction ! character ( 64 ) :: subroutine_name = 'rectangular_channel_or_junction' real , target , intent ( in out ) :: elemR (:,:) integer , intent ( in ) :: elemI (:,:) integer , intent ( in ) :: ei_geometry , ei_elem_type , elem_typ_value integer , intent ( in ) :: er_Length , er_Zbottom , er_BreadthScale integer , intent ( in ) :: er_Area , er_Eta , er_Perimeter , er_Topwidth integer , intent ( in ) :: er_HydDepth , er_HydRadius , er_Volume real , pointer :: volume (:), length (:), zbottom (:), breadth (:) real , pointer :: area (:), eta (:), perimeter (:), hyddepth (:), hydradius (:) real , pointer :: topwidth (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name ! inputs volume => elemR (:, er_Volume ) length => elemR (:, er_Length ) zbottom => elemR (:, er_Zbottom ) breadth => elemR (:, er_BreadthScale ) ! outputs area => elemR (:, er_Area ) eta => elemR (:, er_Eta ) perimeter => elemR (:, er_Perimeter ) hyddepth => elemR (:, er_HydDepth ) hydradius => elemR (:, er_HydRadius ) topwidth => elemR (:, er_Topwidth ) where ( ( elemI (:, ei_geometry ) == eRectangular ) . and . & ( elemI (:, ei_elem_type ) == elem_typ_value ) ) area = volume / length eta = zbottom + ( area / breadth ) topwidth = breadth perimeter = breadth + 2.0 * ( eta - zbottom ) hyddepth = area / topwidth hydradius = area / perimeter endwhere if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine rectangular_channel_or_junction ! !========================================================================== !========================================================================== ! subroutine rectangular_junction_leg & ( elemMR , elemMI , faceR , face_per_elemM , eMi_nfacesDir , eMi_MfaceDir , & eMr_AreaDir , eMr_ZbottomDir , eMr_BreadthScaleDir , & eMr_TopwidthDir , eMr_EtaDir , eMr_HydDepthDir , eMr_EtaOld , fr_Eta_dir , method_EtaM ) ! ! computes geometry in the individual junction branches for a channel ! element with multiple connections ! character ( 64 ) :: subroutine_name = 'rectangular_junction_leg' real , target , intent ( in out ) :: elemMR (:,:) real , target , intent ( in ) :: faceR (:,:) integer , target , intent ( in ) :: elemMI (:,:) integer , intent ( in ) :: face_per_elemM , eMi_nfacesDir integer , intent ( in ) :: eMr_AreaDir (:) integer , intent ( in ) :: eMr_ZbottomDir (:) integer , intent ( in ) :: eMr_BreadthScaleDir (:) integer , intent ( in ) :: eMr_TopwidthDir (:) integer , intent ( in ) :: eMr_EtaDir (:) integer , intent ( in ) :: eMr_HydDepthDir (:) integer , intent ( in ) :: eMi_MfaceDir (:) integer , intent ( in ) :: eMr_EtaOld , fr_Eta_dir integer , intent ( in ) :: method_EtaM integer :: mm integer , pointer :: fdir (:) real , pointer :: eta (:), etaM (:), etaMold (:), area (:), zbottom (:) real , pointer :: depth (:), topwidth (:), breadth (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name etaM => elemMR (:, eMr_Eta ) etaMold => elemMR (:, eMr_EtaOld ) !% cycle over branches. Dir is either {Up, Dn} do mm = 1 , face_per_elemM ! known zbottom => elemMR (:, eMr_ZbottomDir ( mm )) breadth => elemMR (:, eMr_BreadthScaleDir ( mm )) fdir => elemMI (:, eMi_MfaceDir ( mm )) ! computed eta => elemMR (:, eMr_EtaDir ( mm )) depth => elemMR (:, eMr_HydDepthDir ( mm )) area => elemMR (:, eMr_AreaDir ( mm )) topwidth => elemMR (:, eMr_TopwidthDir ( mm )) select case ( method_EtaM ) case ( 0 ) !%  used for initiation when there are no face values !%  simple injection of junction eta where ( ( elemMI (:, eMi_geometry ) == eRectangular ) . and . & ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMI (:, eMi_nfacesDir ) >= mm ) ) eta = etaM endwhere case ( 1 ) !%  used before face values are updated (ie. etaF is old) !%  inject etaM with estimated correction for old gradient where ( ( elemMI (:, eMi_geometry ) == eRectangular ) . and . & ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMI (:, eMi_nfacesDir ) >= mm ) ) eta = etaM + onehalfR * ( faceR ( fdir , fr_Eta_dir ) - etaMold ) endwhere case ( 2 ) !%  used after face values are updated (ie. etaF is new) !%  Average of face and junction value where ( ( elemMI (:, eMi_geometry ) == eRectangular ) . and . & ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMI (:, eMi_nfacesDir ) >= mm ) ) eta = onehalfR * ( faceR ( fdir , fr_Eta_dir ) + etaM ) endwhere case default print * , method_EtaM print * , 'error: unexpected value of ' , method_EtaM , ' for method_EtaM in ' , trim ( subroutine_name ) end select where ( ( elemMI (:, eMi_geometry ) == eRectangular ) . and . & ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMI (:, eMi_nfacesDir ) >= mm ) ) area = ( eta - zbottom ) * breadth topwidth = breadth depth = area / topwidth endwhere enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine rectangular_junction_leg ! !========================================================================== ! END OF MODULE element_geometry !========================================================================== end module element_geometry","title":"element_geometry.f08 – SWMMengine","tags":"","loc":"sourcefile/element_geometry.f08.html"},{"text":"This file depends on sourcefile~~setting_definition.f08~~EfferentGraph sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~setting_definition.f08~~AfferentGraph sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~debug.f08 debug.f08 sourcefile~debug.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08 bc.f08 sourcefile~debug.f08->sourcefile~bc.f08 sourcefile~globals.f08 globals.f08 sourcefile~debug.f08->sourcefile~globals.f08 sourcefile~utility.f08 utility.f08 sourcefile~debug.f08->sourcefile~utility.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~debug.f08->sourcefile~array_index.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~debug.f08->sourcefile~data_keys.f08 sourcefile~junction.f08 junction.f08 sourcefile~junction.f08->sourcefile~setting_definition.f08 sourcefile~junction.f08->sourcefile~globals.f08 sourcefile~junction.f08->sourcefile~utility.f08 sourcefile~junction.f08->sourcefile~array_index.f08 sourcefile~junction.f08->sourcefile~data_keys.f08 sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~runge_kutta.f08->sourcefile~setting_definition.f08 sourcefile~runge_kutta.f08->sourcefile~bc.f08 sourcefile~runge_kutta.f08->sourcefile~globals.f08 sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~runge_kutta.f08->sourcefile~element_geometry.f08 sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~runge_kutta.f08->sourcefile~element_dynamics.f08 sourcefile~face_values.f08 face_values.f08 sourcefile~runge_kutta.f08->sourcefile~face_values.f08 sourcefile~diagnostic.f08 diagnostic.f08 sourcefile~runge_kutta.f08->sourcefile~diagnostic.f08 sourcefile~adjustments.f08 adjustments.f08 sourcefile~runge_kutta.f08->sourcefile~adjustments.f08 sourcefile~runge_kutta.f08->sourcefile~utility.f08 sourcefile~runge_kutta.f08->sourcefile~array_index.f08 sourcefile~runge_kutta.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~element_geometry.f08->sourcefile~setting_definition.f08 sourcefile~element_geometry.f08->sourcefile~junction.f08 sourcefile~element_geometry.f08->sourcefile~bc.f08 sourcefile~element_geometry.f08->sourcefile~globals.f08 sourcefile~element_geometry.f08->sourcefile~adjustments.f08 sourcefile~element_geometry.f08->sourcefile~utility.f08 sourcefile~element_geometry.f08->sourcefile~array_index.f08 sourcefile~element_geometry.f08->sourcefile~data_keys.f08 sourcefile~case_y_channel.f08 case_y_channel.f08 sourcefile~case_y_channel.f08->sourcefile~setting_definition.f08 sourcefile~case_y_channel.f08->sourcefile~bc.f08 sourcefile~case_y_channel.f08->sourcefile~globals.f08 sourcefile~allocate_storage.f08 allocate_storage.f08 sourcefile~case_y_channel.f08->sourcefile~allocate_storage.f08 sourcefile~case_y_channel.f08->sourcefile~array_index.f08 sourcefile~case_y_channel.f08->sourcefile~data_keys.f08 sourcefile~case_simple_channel.f08 case_simple_channel.f08 sourcefile~case_simple_channel.f08->sourcefile~setting_definition.f08 sourcefile~case_simple_channel.f08->sourcefile~bc.f08 sourcefile~case_simple_channel.f08->sourcefile~globals.f08 sourcefile~case_simple_channel.f08->sourcefile~allocate_storage.f08 sourcefile~case_simple_channel.f08->sourcefile~array_index.f08 sourcefile~case_simple_channel.f08->sourcefile~data_keys.f08 sourcefile~friction_model.f08 friction_model.f08 sourcefile~friction_model.f08->sourcefile~setting_definition.f08 sourcefile~friction_model.f08->sourcefile~globals.f08 sourcefile~friction_model.f08->sourcefile~array_index.f08 sourcefile~friction_model.f08->sourcefile~data_keys.f08 sourcefile~element_dynamics.f08->sourcefile~setting_definition.f08 sourcefile~element_dynamics.f08->sourcefile~junction.f08 sourcefile~element_dynamics.f08->sourcefile~bc.f08 sourcefile~element_dynamics.f08->sourcefile~globals.f08 sourcefile~element_dynamics.f08->sourcefile~adjustments.f08 sourcefile~element_dynamics.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08->sourcefile~array_index.f08 sourcefile~element_dynamics.f08->sourcefile~data_keys.f08 sourcefile~face_values.f08->sourcefile~setting_definition.f08 sourcefile~face_values.f08->sourcefile~bc.f08 sourcefile~face_values.f08->sourcefile~globals.f08 sourcefile~face_values.f08->sourcefile~adjustments.f08 sourcefile~face_values.f08->sourcefile~utility.f08 sourcefile~face_values.f08->sourcefile~array_index.f08 sourcefile~face_values.f08->sourcefile~data_keys.f08 sourcefile~diagnostic.f08->sourcefile~setting_definition.f08 sourcefile~diagnostic.f08->sourcefile~bc.f08 sourcefile~diagnostic.f08->sourcefile~globals.f08 sourcefile~diagnostic.f08->sourcefile~utility.f08 sourcefile~diagnostic.f08->sourcefile~array_index.f08 sourcefile~diagnostic.f08->sourcefile~data_keys.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~time_loop.f08->sourcefile~setting_definition.f08 sourcefile~time_loop.f08->sourcefile~debug.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~time_loop.f08->sourcefile~bc.f08 sourcefile~time_loop.f08->sourcefile~globals.f08 sourcefile~time_loop.f08->sourcefile~face_values.f08 sourcefile~time_loop.f08->sourcefile~diagnostic.f08 sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~time_loop.f08->sourcefile~explicit_euler.f08 sourcefile~output.f08 output.f08 sourcefile~time_loop.f08->sourcefile~output.f08 sourcefile~time_loop.f08->sourcefile~array_index.f08 sourcefile~time_loop.f08->sourcefile~data_keys.f08 sourcefile~adjustments.f08->sourcefile~setting_definition.f08 sourcefile~adjustments.f08->sourcefile~globals.f08 sourcefile~adjustments.f08->sourcefile~utility.f08 sourcefile~adjustments.f08->sourcefile~array_index.f08 sourcefile~adjustments.f08->sourcefile~data_keys.f08 sourcefile~initial_condition.f08 initial_condition.f08 sourcefile~initial_condition.f08->sourcefile~setting_definition.f08 sourcefile~initial_condition.f08->sourcefile~junction.f08 sourcefile~initial_condition.f08->sourcefile~bc.f08 sourcefile~initial_condition.f08->sourcefile~globals.f08 sourcefile~initial_condition.f08->sourcefile~element_geometry.f08 sourcefile~initial_condition.f08->sourcefile~element_dynamics.f08 sourcefile~initial_condition.f08->sourcefile~face_values.f08 sourcefile~initial_condition.f08->sourcefile~utility.f08 sourcefile~initial_condition.f08->sourcefile~array_index.f08 sourcefile~initial_condition.f08->sourcefile~data_keys.f08 sourcefile~test_cases.f08 test_cases.f08 sourcefile~test_cases.f08->sourcefile~setting_definition.f08 sourcefile~test_cases.f08->sourcefile~bc.f08 sourcefile~test_cases.f08->sourcefile~globals.f08 sourcefile~test_cases.f08->sourcefile~case_y_channel.f08 sourcefile~test_cases.f08->sourcefile~case_simple_channel.f08 sourcefile~test_cases.f08->sourcefile~utility.f08 sourcefile~test_cases.f08->sourcefile~array_index.f08 sourcefile~test_cases.f08->sourcefile~data_keys.f08 sourcefile~stub.f08 stub.f08 sourcefile~stub.f08->sourcefile~setting_definition.f08 sourcefile~stub.f08->sourcefile~globals.f08 sourcefile~stub.f08->sourcefile~array_index.f08 sourcefile~stub.f08->sourcefile~data_keys.f08 sourcefile~explicit_euler.f08->sourcefile~setting_definition.f08 sourcefile~explicit_euler.f08->sourcefile~bc.f08 sourcefile~explicit_euler.f08->sourcefile~globals.f08 sourcefile~explicit_euler.f08->sourcefile~element_geometry.f08 sourcefile~explicit_euler.f08->sourcefile~element_dynamics.f08 sourcefile~explicit_euler.f08->sourcefile~face_values.f08 sourcefile~explicit_euler.f08->sourcefile~adjustments.f08 sourcefile~explicit_euler.f08->sourcefile~utility.f08 sourcefile~explicit_euler.f08->sourcefile~array_index.f08 sourcefile~explicit_euler.f08->sourcefile~data_keys.f08 sourcefile~output.f08->sourcefile~setting_definition.f08 sourcefile~output.f08->sourcefile~bc.f08 sourcefile~output.f08->sourcefile~globals.f08 sourcefile~output.f08->sourcefile~utility.f08 sourcefile~output.f08->sourcefile~array_index.f08 sourcefile~output.f08->sourcefile~data_keys.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~setting_definition.f08 sourcefile~main.f08->sourcefile~debug.f08 sourcefile~main.f08->sourcefile~junction.f08 sourcefile~main.f08->sourcefile~bc.f08 sourcefile~main.f08->sourcefile~globals.f08 sourcefile~main.f08->sourcefile~diagnostic.f08 sourcefile~main.f08->sourcefile~time_loop.f08 sourcefile~main.f08->sourcefile~initial_condition.f08 sourcefile~main.f08->sourcefile~test_cases.f08 sourcefile~main.f08->sourcefile~output.f08 sourcefile~main.f08->sourcefile~utility.f08 sourcefile~main.f08->sourcefile~allocate_storage.f08 sourcefile~main.f08->sourcefile~array_index.f08 sourcefile~network_define.f08 network_define.f08 sourcefile~main.f08->sourcefile~network_define.f08 sourcefile~checking.f08 checking.f08 sourcefile~main.f08->sourcefile~checking.f08 sourcefile~initialization.f08 initialization.f08 sourcefile~main.f08->sourcefile~initialization.f08 sourcefile~main.f08->sourcefile~data_keys.f08 sourcefile~allocate_storage.f08->sourcefile~globals.f08 sourcefile~allocate_storage.f08->sourcefile~utility.f08 sourcefile~allocate_storage.f08->sourcefile~array_index.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~custom_networkold.f08 custom_networkOLD.f08 sourcefile~custom_networkold.f08->sourcefile~globals.f08 sourcefile~custom_networkold.f08->sourcefile~array_index.f08 sourcefile~custom_networkold.f08->sourcefile~data_keys.f08 sourcefile~network_define.f08->sourcefile~junction.f08 sourcefile~network_define.f08->sourcefile~globals.f08 sourcefile~network_define.f08->sourcefile~allocate_storage.f08 sourcefile~network_define.f08->sourcefile~array_index.f08 sourcefile~network_define.f08->sourcefile~initialization.f08 sourcefile~network_define.f08->sourcefile~data_keys.f08 sourcefile~checking.f08->sourcefile~globals.f08 sourcefile~checking.f08->sourcefile~array_index.f08 sourcefile~checking.f08->sourcefile~data_keys.f08 sourcefile~initialization.f08->sourcefile~globals.f08 sourcefile~initialization.f08->sourcefile~array_index.f08 sourcefile~initialization.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 var pansourcefilesetting_definitionf08AfferentGraph = svgPanZoom('#sourcefilesetting_definitionf08AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules setting_definition Source Code setting_definition.f08 Source Code !========================================================================== module setting_definition ! ! defines the setting%.... structure that contains the controls for the ! simulation ! use type_definitions implicit none public !% THIRD LEVEL TYPES ---------------------------------------------- !% setting%Method%AdjustVshapedFlowrate type adjustVshapedFlowrateType logical :: Apply = . true . real :: Coef = 0.1 end type adjustVshapedFlowrateType !% setting%Limiter%BC type BClimiterType logical :: UseInflowFroudeNumberLimiter = . true . real :: FroudeInflowMaximum = 1.5 ! max value of Fr at inflow endtype BClimiterType !%  setting%Limiter%flowrate type flowrateType logical :: UseFaceVolumeTransport = . true . real :: FaceVolumeTransport = 0.5 ! Fraction of usptream volume that can be transported in on time step endtype flowrateType !%  setting%Limiter%Timescale type timescaleType real :: Maximum = 1e6 real :: Minimum = 1e-6 endtype timescaleType !%  setting%Limiter%Velocity type velocityType logical :: UseLimitMax = . true . real :: Maximum = 20 ! m/s endtype velocityType !% SECOND LEVEL TYPES ---------------------------------------------- !%  setting%Constant type constantType real :: gravity = 9.81 ! m&#94;2/s end type constantType !%  setting%DebugOut type debugoutType logical :: elem2R = . false . logical :: elem2I = . false . logical :: elem2YN = . false . logical :: elemMR = . false . logical :: elemMI = . false . logical :: elemMYN = . false . logical :: faceR = . false . logical :: faceI = . false . logical :: faceYN = . false . logical :: nodeR = . false . logical :: nodeI = . false . logical :: nodeYN = . false . logical :: linkR = . false . logical :: linkI = . false . logical :: linkYN = . false . integer :: DisplayInterval = 1 logical :: SuppressAllFiles = . false . logical :: SuppressTimeStep = . false . logical :: SuppressTimeValue = . false . logical :: SuppressNdat = . false . character ( len = 64 ) :: FolderName = 'debugoutputA' character ( len = 64 ) :: FileName = 'debug' character ( len = 256 ) :: FolderPath = './' end type !%  setting%Eps type epsilonType real :: FroudeJump = 0.1 ! +- small non-dimensional range for hyd jump discrimination real :: InflowDepthIncreaseFroudeLimit = 0.1 ! Fractional increase in depth under froude limitation end type epsilonType !%  setting%Limiter type limiterType type ( BClimiterType ) :: BC type ( flowrateType ) :: Flowrate type ( velocityType ) :: Velocity type ( timescaleType ) :: Timescale endtype limiterType !%  setting%Method type methodType type ( adjustVshapedFlowrateType ) :: AdjustVshapedFlowrate end type methodType !%  setting%OutputThreadedLink type outputThreadedLinkType integer :: DisplayInterval = 1 logical :: SuppressAllFiles = . false . logical :: UseThisOutput = . false . logical :: area = . false . logical :: flowrate = . false . logical :: velocity = . false . logical :: eta = . false . logical :: depth = . false . character ( len = 64 ) :: FolderName = 'OutputThreaded' character ( len = 64 ) :: FileName = 'out' character ( len = 256 ) :: FolderPath = './' end type outputThreadedLinkType !%  setting%SmallVolume type smallvolumeType logical :: UseSmallVolumes = . true . ! YN to determine if smallvolume adjustments used real :: DepthCutoff = 0.01 ! m Determines where small volumes begin real :: ManningsN = 0.01 real :: MinimumTopwidth = 0.5 ! m   Minimum value used for smallvolume reset real :: MinimumArea = 0.005 ! m&#94;2 real :: MinimumPerimeter = 0.52 ! m real :: MinimumHydRadius = 0.009 ! m end type smallvolumeType !%  setting%Step type stepType integer :: First integer :: Final integer :: Current integer :: FromRestart end type stepType !%  setting%TestCase type testcaseType logical :: UseTestCase character ( 64 ) :: TestName end type testcaseType !%  setting%Time type timeType character ( 14 ) :: DateTimeStamp real :: Dt ! s real :: StartTime = 0.0 real :: EndTime = 0.0 real :: ThisTime real :: NextTime end type timeType !%  setting%ZeroValue type zerovalueType logical :: UseZeroValues = . true . real :: Area = 1.0e-7 ! m&#94;2 real :: Depth = 1.0e-4 ! m real :: Flowrate = 0.0 ! m&#94;3/s real :: Topwidth = 1.0e-4 ! m real :: Velocity = 0.0 ! m/s real :: Volume = 1.0e-6 ! m&#94;3 end type zerovalueType !% FIRST LEVEL TYPE  ---------------------------------------------- type settingType integer :: dummy type ( constantType ) :: Constant ! constants type ( debugoutType ) :: DebugOut ! control of debougout files type ( epsilonType ) :: Eps ! epsilons used to provide bandwidth for comparisons type ( limiterType ) :: Limiter ! maximum and minimum limiters type ( methodType ) :: Method ! controls over simulation methods type ( outputThreadedLinkType ) :: OutputThreadedLink ! controls output for threaded link type ( smallvolumeType ) :: SmallVolume ! controls for small volumes type ( stepType ) :: Step ! controls over simulation time stepping type ( testcaseType ) :: TestCase ! custom setup for test cases type ( timeType ) :: Time ! controls of time step type ( zerovalueType ) :: ZeroValue ! finite values to represent small or negative values end type settingType type ( settingType ), target :: setting integer , private :: debuglevel = 0 contains !========================================================================== !========================================================================== subroutine setting_default ! !   This subroutine can be used in conjunction with the test_case to setup !   a simulation or set of simulations ! !-------------------------------------------------------------------------- setting % Debugout % DisplayInterval = 1000 setting % Time % dt = 5 0.0 setting % Step % First = 1 setting % Step % Final = 40000 setting % Step % Current = 1 setting % Step % FromRestart = 1 setting % Time % StartTime = 0.0 setting % Time % EndTime = setting % Time % StartTime & + setting % Time % dt * ( setting % Step % Final - setting % Step % First + 1 ) end subroutine setting_default ! !========================================================================== ! END OF MODULE !========================================================================== end module setting_definition","title":"setting_definition.f08 – SWMMengine","tags":"","loc":"sourcefile/setting_definition.f08.html"},{"text":"This file depends on sourcefile~~element_dynamics.f08~~EfferentGraph sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~globals.f08 globals.f08 sourcefile~element_dynamics.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~element_dynamics.f08->sourcefile~setting_definition.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~element_dynamics.f08->sourcefile~array_index.f08 sourcefile~adjustments.f08 adjustments.f08 sourcefile~element_dynamics.f08->sourcefile~adjustments.f08 sourcefile~junction.f08 junction.f08 sourcefile~element_dynamics.f08->sourcefile~junction.f08 sourcefile~bc.f08 bc.f08 sourcefile~element_dynamics.f08->sourcefile~bc.f08 sourcefile~utility.f08 utility.f08 sourcefile~element_dynamics.f08->sourcefile~utility.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~element_dynamics.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~adjustments.f08->sourcefile~globals.f08 sourcefile~adjustments.f08->sourcefile~setting_definition.f08 sourcefile~adjustments.f08->sourcefile~array_index.f08 sourcefile~adjustments.f08->sourcefile~utility.f08 sourcefile~adjustments.f08->sourcefile~data_keys.f08 sourcefile~junction.f08->sourcefile~globals.f08 sourcefile~junction.f08->sourcefile~setting_definition.f08 sourcefile~junction.f08->sourcefile~array_index.f08 sourcefile~junction.f08->sourcefile~utility.f08 sourcefile~junction.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 var pansourcefileelement_dynamicsf08EfferentGraph = svgPanZoom('#sourcefileelement_dynamicsf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~element_dynamics.f08~~AfferentGraph sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~initial_condition.f08 initial_condition.f08 sourcefile~initial_condition.f08->sourcefile~element_dynamics.f08 sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~runge_kutta.f08->sourcefile~element_dynamics.f08 sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~explicit_euler.f08->sourcefile~element_dynamics.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~time_loop.f08->sourcefile~explicit_euler.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~initial_condition.f08 sourcefile~main.f08->sourcefile~time_loop.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules element_dynamics Source Code element_dynamics.f08 Source Code ! module element_dynamics ! ! Updating values on elements during simulation time stepping ! !========================================================================== ! module element_dynamics ! use array_index use adjustments use bc use data_keys use globals use junction use setting_definition use utility implicit none private public :: element_dynamics_update integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine element_dynamics_update & ( elem2R , elemMR , faceR , elem2I , elemMI , elem2YN , elemMYN , & bcdataDn , bcdataUp , e2r_Velocity_new , eMr_Velocity_new , & e2r_Volume_new , eMr_Volume_new , thisTime ) ! ! update the flow dynamics on an element given new velocity values stored ! in the array given by the column index e#r_Velocity_new ! character ( 64 ) :: subroutine_name = 'element_dynamics_update' real , target , intent ( in out ) :: elem2R (:,:), elemMR (:,:) real , target , intent ( in ) :: faceR (:,:) integer , intent ( in ) :: elem2I (:,:), elemMI (:,:) logical , target , intent ( in out ) :: elem2YN (:,:), elemMYN (:,:) type ( bcType ), intent ( in out ) :: bcdataDn (:), bcdataUp (:) real , intent ( in ) :: thisTime integer , intent ( in ) :: e2r_Velocity_new , e2r_Volume_new integer , intent ( in ) :: eMr_Velocity_new , eMr_Volume_new logical , pointer :: isadhocflowrate (:) integer :: idx !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !% velocity limiter on channels call adjust_channel_velocity_limiter & ( elem2R , elem2YN , elem2I , & e2i_elem_type , eChannel , e2YN_IsAdhocFlowrate , e2r_Velocity_new ) !% velocity limiter on junction (handled on main element only) call adjust_channel_velocity_limiter & ( elemMR , elemMYN , elemMI , & eMi_elem_type , eJunctionChannel , eMYN_IsAdhocFlowrate , eMr_Velocity_new ) !%  For small volumes, compute a velocity that is blended from the update value !%  and a Chezy-Manning computed using the free surface slope of the element if ( setting % SmallVolume % UseSmallVolumes ) then call blended_smallvolume_velocity & ( elem2R , elem2I , elem2YN , elemMR , elemMI , elemMYN , faceR , & e2r_Velocity_new , eMr_Velocity_new ) endif !% for extremely small volumes - perform a separate reset if ( setting % ZeroValue % Volume > zeroR ) then call adjust_zero_velocity_at_zero_volume & ( elem2R , elem2YN , e2r_Velocity_new , e2r_Volume_new , & elemMR , elemMYN , eMr_Velocity_new , eMr_Volume_new ) endif !%  flowrate updated from velocity call element_flowrate_update & ( elem2R , elemMR , faceR , elem2I , elemMI , e2r_Velocity_new , eMr_Velocity_new ) !%  apply the boundary conditions on velocity and flowrate call bc_applied_onelement & ( elem2R , bcdataDn , bcdataUp , thisTime , bc_category_inflowrate , e2r_Velocity_new ) !% compute the timescales up and down call element_timescale & ( elem2R , elem2I , elem2YN , elemMR , elemMI , elemMYN , bcdataDn , bcdataUp , & e2r_Velocity_new ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine element_dynamics_update ! !========================================================================== ! ! PRIVATE BELOW HERE ! !========================================================================== ! subroutine element_flowrate_update & ( elem2R , elemMR , faceR , elem2I , elemMI , & e2r_Velocity_new , eMr_Velocity_new ) ! ! given a velocity and update areas in elemR, provide updates ! for flow rate of the element and junction branches ! character ( 64 ) :: subroutine_name = 'element_flowrate_update' real , target , intent ( in out ) :: elem2R (:,:), elemMR (:,:) real , target , intent ( in ) :: faceR (:,:) integer , target , intent ( in ) :: elem2I (:,:), elemMI (:,:) integer , intent ( in ) :: e2r_Velocity_new , eMr_Velocity_new real , pointer :: totalarea (:) integer :: mm , eMR_totalarea !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !%  assign total area from the temp space eMR_totalarea = eMr_Temp ( next_eMr_temparray ) totalarea => elemMR (:, eMR_totalarea ) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) !%  update the channel flow rates with the velocity (may be from an RK step) call flowrate_from_velocity & ( elem2R , elem2I , & e2r_Flowrate , e2r_Area , e2r_Velocity_new , e2i_elem_type , eChannel ) call flowrate_from_velocity & ( elemMR , elemMI , & eMr_Flowrate , eMr_Area , eMr_Velocity_new , eMi_elem_type , eJunctionChannel ) !%  FLOWS AND VELOCITIES IN JUNCTION BRANCHES ----------------- !%  The total flowrate is distributed among both outflow and inflow branches !%  Note that this does NOT mean that the inflows and outflows are exactly !%  equal - the branch values are what are used in the face interpolation !%  to get the inflow/outflows at the faces. !%  get the total outflow branch areas !%  handle the downstream branches totalarea = zeroR ! ensure temporary array is zero call junction_branch_sum_areas_by_direction & ( eMR_totalarea , & dnstream_face_per_elemM , eMr_AreaDn , eMi_MfaceDn , eMi_nfaces_d , & upstream_face_per_elemM , eMr_AreaUp , eMi_MfaceUp , eMi_nfaces_u , & elemMR , elemMI , faceR ) !%  distribute flow proportionally among outflows downstream call junction_branch_velocity_and_flowrate_proportional_to_area & ( eMR_totalarea , eMR_Flowrate , & dnstream_face_per_elemM , eMr_AreaDn , eMi_MfaceDn , eMi_nfaces_d , & eMr_FlowrateDn , eMr_VelocityDn , & upstream_face_per_elemM , eMr_AreaUp , eMi_MfaceUp , eMi_nfaces_u , & eMr_FlowrateUp , eMr_VelocityUp , & elemMR , elemMI , faceR ) !%  handle upstream branches totalarea = zeroR ! ensure temporary array is zero call junction_branch_sum_areas_by_direction & ( eMR_totalarea , & upstream_face_per_elemM , eMr_AreaUp , eMi_MfaceUp , eMi_nfaces_u , & dnstream_face_per_elemM , eMr_AreaDn , eMi_MfaceDn , eMi_nfaces_d , & elemMR , elemMI , faceR ) !%  distribute flow proportionally among outflows upstream call junction_branch_velocity_and_flowrate_proportional_to_area & ( eMR_totalarea , eMR_Flowrate , & upstream_face_per_elemM , eMr_AreaUp , eMi_MfaceUp , eMi_nfaces_u , & eMr_FlowrateUp , eMr_VelocityUp , & dnstream_face_per_elemM , eMr_AreaDn , eMi_MfaceDn , eMi_nfaces_d , & eMr_FlowrateDn , eMr_VelocityDn , & elemMR , elemMI , faceR ) !print *, trim(subroutine_name) !print *, elemMR(:,eMr_totalarea) !print *, elemMR(:,eMr_Flowrate_u1), elemMR(:,eMr_Velocity_u1 ) !print *, elemMR(:,eMr_Flowrate_u2), elemMR(:,eMr_Velocity_u2 ) !print *, elemMR(:,eMr_Flowrate),    elemMR(:,eMr_Velocity_new) !print *, elemMR(:,eMr_Flowrate_d1), elemMR(:,eMr_Velocity_d1 ) !%  enforce maximum velocities in junction branches call adjust_junction_branch_velocity_limit ( elemMR , elemMI ) !%  release the temp array totalarea = nullvalueR nullify ( totalarea ) next_eMr_temparray = next_eMr_temparray - 1 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine element_flowrate_update ! !========================================================================== !========================================================================== ! subroutine flowrate_from_velocity & ( elemR , elemI , & er_Flowrate , er_Area , er_Velocity , ei_elem_type , eThisElemType ) ! ! compute flowrate from velocity and area for eThisElemType ! character ( 64 ) :: subroutine_name = 'flowrate_from_velocity' real , target , intent ( in out ) :: elemR (:,:) integer , intent ( in ) :: elemI (:,:) integer , intent ( in ) :: er_Flowrate , er_Area , er_Velocity , ei_elem_type integer , intent ( in ) :: eThisElemType real , pointer :: flowrate (:), area (:), velocity (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name flowrate => elemR (:, er_Flowrate ) area => elemR (:, er_Area ) velocity => elemR (:, er_Velocity ) where ( elemI (:, ei_elem_type ) == eThisElemType ) flowrate = area * velocity endwhere if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine flowrate_from_velocity ! !========================================================================== !========================================================================== ! subroutine blended_smallvolume_velocity & ( elem2R , elem2I , elem2YN , elemMR , elemMI , elemMYN , faceR , & e2r_Velocity_new , eMr_Velocity_new ) ! ! any volume IsSmallVolume will be have its velocity blended with ! a Chezy velocity so that the small volumes reduce to a small finite value ! as the volume decreases. ! ! Note that the direction of the blended velocity will follow the ! decrease in the free surface slope. ! character ( 64 ) :: subroutine_name = 'blended_smallvolume_velocity' real , target , intent ( in out ) :: elem2R (:,:), elemMR (:,:) real , target , intent ( in ) :: faceR (:,:) integer , target , intent ( in ) :: elem2I (:,:), elemMI (:,:) logical , intent ( in ) :: elem2YN (:,:), elemMYN (:,:) integer , intent ( in ) :: e2r_Velocity_new , eMr_Velocity_new integer :: e2r_tSlope , e2r_tManningsN , e2r_tSmallVelocity integer :: eMr_tSlope , eMr_tManningsN , eMr_tSmallVelocity integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !%  velocity blend for channel elements call velocity_blend_with_mask & ( elem2R , elem2I , elem2YN , faceR , & next_e2r_temparray , e2r_n_temp , e2r_Temp , & e2r_Velocity_new , e2r_Flowrate , e2r_Length , & e2r_Area , e2r_HydRadius , e2r_SmallVolumeRatio , & e2YN_IsSmallVolume , e2i_roughness_type , e2r_Roughness , & e2i_elem_type , eChannel , e2i_Mface_u , e2i_Mface_d ) !%  velocity blend for junction elements !%  HACK - this arbitrarily uses the u1 and d1 for the slope call velocity_blend_with_mask & ( elemMR , elemMI , elemMYN , faceR , & next_eMr_temparray , eMr_n_temp , eMr_Temp , & eMr_Velocity_new , eMr_Flowrate , eMr_Length , & eMr_Area , eMr_HydRadius , eMr_SmallVolumeRatio , & eMYN_IsSmallVolume , eMi_roughness_type , eMr_Roughness , & eMi_elem_type , eJunctionChannel , eMi_Mface_u1 , eMi_Mface_d1 ) !%  perform small volume velocity bend for junction branches do mm = 1 , upstream_face_per_elemM !%  HACK this arbitrarily uses d1 for the slope !%  Not sure how to revise if d2 and d3 are non-zero call velocity_blend_with_mask & ( elemMR , elemMI , elemMYN , faceR , & next_eMr_temparray , eMr_n_temp , eMr_Temp , & eMr_VelocityUp ( mm ), eMr_FlowrateUp ( mm ), eMr_LengthUp ( mm ), & eMr_AreaUp ( mm ), eMr_HydRadius , eMr_SmallVolumeRatio , & eMYN_IsSmallVolume , eMi_roughness_type , eMr_Roughness , & eMi_elem_type , eJunctionChannel , eMi_MfaceUp ( mm ), eMi_Mface_d1 ) end do do mm = 1 , dnstream_face_per_elemM !%  HACK this arbitrarily uses u1 for the slope !%  PERHAPS REVISE TO USED Z at CENTER OF CHANNEL call velocity_blend_with_mask & ( elemMR , elemMI , elemMYN , faceR , & next_eMr_temparray , eMr_n_temp , eMr_Temp , & eMr_VelocityDn ( mm ), eMr_FlowrateDn ( mm ), eMr_LengthDn ( mm ), & eMr_AreaDn ( mm ), eMr_HydRadius , eMr_SmallVolumeRatio , & eMYN_IsSmallVolume , eMi_roughness_type , eMr_Roughness , & eMi_elem_type , eJunctionChannel , eMi_Mface_u1 , eMi_MfaceDn ( mm )) end do ! HACK - the above applies a ManningsN approach to elements that might have ! other drag approaches. if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine blended_smallvolume_velocity ! !========================================================================== !========================================================================== ! subroutine velocity_blend_with_mask & ( elemR , elemI , elemYN , faceR , & next_er_temparray , er_n_temp , er_Temp , & er_Velocity_new , er_Flowrate , er_Length , & er_Area , er_HydRadius , er_SmallVolumeRatio , & eYN_IsSmallVolume , ei_roughness_type , er_Roughness , & ei_elem_type , elemType , ei_Mface_u , ei_Mface_d ) ! ! Performs the velocity blending between a Chezy-Manning solution and ! the simulated solution for small volumes ! character ( 64 ) :: subroutine_name = 'velocity_blend_with_mask' real , target , intent ( in out ) :: elemR (:,:) real , intent ( in ) :: faceR (:,:) integer , target , intent ( in ) :: elemI (:,:) logical , intent ( in ) :: elemYN (:,:) integer , intent ( in out ) :: next_er_temparray integer , intent ( in ) :: er_n_temp , er_Temp (:) integer , intent ( in ) :: er_Velocity_new , er_Flowrate , er_Length integer , intent ( in ) :: er_HydRadius , er_SmallVolumeRatio , er_Area integer , intent ( in ) :: eYN_IsSmallVolume , ei_roughness_type , er_Roughness integer , intent ( in ) :: ei_elem_type , elemType , ei_Mface_u , ei_Mface_d integer :: er_tSlope , er_tSmallVelocity , er_tManningsN integer , pointer :: fUp (:), fDn (:) real , pointer :: Length (:), Velocity (:), Flowrate (:), HydRadius (:) real , pointer :: SmallVolumeRatio (:), Area (:) real , pointer :: Slope (:), smallVelocity (:), ManningsN (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name er_tSlope = er_Temp ( next_er_temparray ) next_er_temparray = utility_advance_temp_array ( next_er_temparray , er_n_temp ) er_tManningsN = er_Temp ( next_er_temparray ) next_er_temparray = utility_advance_temp_array ( next_er_temparray , er_n_temp ) er_tSmallVelocity = er_Temp ( next_er_temparray ) next_er_temparray = utility_advance_temp_array ( next_er_temparray , er_n_temp ) fUp => elemI (:, ei_Mface_u ) fDn => elemI (:, ei_Mface_d ) Length => elemR (:, er_Length ) Velocity => elemR (:, er_Velocity_new ) Flowrate => elemR (:, er_Flowrate ) HydRadius => elemR (:, er_HydRadius ) SmallVolumeRatio => elemR (:, er_SmallVolumeRatio ) Area => elemR (:, er_Area ) Slope => elemR (:, er_tSlope ) smallVelocity => elemR (:, er_tSmallVelocity ) ManningsN => elemR (:, er_tManningsN ) call smallvolume_ManningsN & ( elemR , elemI , elemYN , er_tManningsN , er_tSmallVelocity , & eYN_IsSmallVolume , ei_roughness_type , er_Roughness ) where ( ( elemYN (:, eYN_IsSmallVolume )) . and . & ( elemI (:, ei_elem_type ) == elemType ) . and . & ( SmallVolumeRatio < oneR )) Slope = ( faceR ( fUp , fr_Eta_d ) - faceR ( fDn , fr_Eta_u ) ) / Length !%  a small velocity based on Chezy-Manning and the free-surface slope smallVelocity = small_chezy_velocity ( ManningsN , HydRadius , Slope ) !%  blend with the actual velocity, depending on the small volume ratio smallVelocity = velocity_blend ( SmallVolumeRatio , Velocity , smallVelocity ) !%  take the smaller value, with the sign of the C-M velocity Velocity = sign ( min ( abs ( smallVelocity ), abs ( Velocity )), smallVelocity ) Flowrate = Velocity * Area endwhere Slope = nullvalueR ManningsN = nullvalueR smallVelocity = nullvalueR nullify ( Slope , smallVelocity , ManningsN ) next_er_temparray = next_er_temparray - 3 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine velocity_blend_with_mask ! !========================================================================== !========================================================================== ! subroutine smallvolume_ManningsN & ( elemR , elemI , elemYN , er_tManningsN , er_tSmallVelocity , & eYN_IsSmallVolume , ei_roughness_type , er_Roughness ) character ( 64 ) :: subroutine_name = 'smallvolume_ManningsN' ! ! Stores a temporary ManningsN and zero velocity for small volumes. ! We use a temporary storage so that we can set Manning's N to the larger value ! of the actual Manning's N for the channel and a setting value (typically ! larger)for small depths. ! real , target , intent ( in out ) :: elemR (:,:) integer , intent ( in ) :: elemI (:,:) logical , intent ( in ) :: elemYN (:,:) integer , intent ( in ) :: er_tManningsN , er_tSmallVelocity integer , intent ( in ) :: eYN_IsSmallVolume , ei_roughness_type , er_Roughness real , pointer :: ManningsN (:), smallVelocity (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name ManningsN => elemR (:, er_tManningsN ) smallVelocity => elemR (:, er_tSmallVelocity ) !%  set the temporary ManningsN and zero velocity for small volumes where ( elemYN (:, eYN_IsSmallVolume ) ) ManningsN = setting % SmallVolume % ManningsN smallVelocity = zeroR endwhere !%  reset the temporary ManningsN whereever the actual value is larger where ( ( elemYN (:, eYN_IsSmallVolume )) . and . & ( elemI (:, ei_roughness_type ) == eManningsN ) . and . & ( elemR (:, er_Roughness ) > ManningsN ) ) ManningsN = elemR (:, er_Roughness ) endwhere if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine smallvolume_ManningsN ! !========================================================================== !========================================================================== ! subroutine element_timescale & ( elem2R , elem2I , elem2YN , elemMR , elemMI , elemMYN , bcdataDn , bcdataUp , & e2r_Velocity_new ) ! ! timescale of channel and junction elements ! Computed using new velocity for channel elements ! Assumes that new velocity has been stored in channel branches for junctions ! character ( 64 ) :: subroutine_name = 'element_timescale' real , intent ( in out ) :: elem2R (:,:), elemMR (:,:) integer , intent ( in ) :: elem2I (:,:), elemMI (:,:) logical , intent ( in out ) :: elem2YN (:,:), elemMYN (:,:) type ( bcType ), intent ( in ) :: bcdataDn (:), bcdataUp (:) integer , intent ( in ) :: e2r_Velocity_new !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name call timescale_value_channel ( elem2R , elem2I , elem2YN , e2r_Velocity_new ) ! note that timescales are stored on branches only for a junction and the data ! in branch flowrate and velocities have already been updated in place, so ! no need to use a eMr..new index call timescale_value_junction ( elemMR , elemMI , elemMYN ) call bc_timescale_value ( elem2R , bcdataDn ) call bc_timescale_value ( elem2R , bcdataUp ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine element_timescale ! !========================================================================== !========================================================================== ! subroutine timescale_value_channel & ( elem2R , elem2I , elem2YN , e2r_Velocity_new ) character ( 64 ) :: subroutine_name = 'timescale_value_channel' integer , intent ( in ) :: e2r_Velocity_new real , target , intent ( in out ) :: elem2R (:,:) integer , intent ( in ) :: elem2I (:,:) logical , target , intent ( in out ) :: elem2YN (:,:) integer :: indx ( 2 ), maskindx1 , maskindx2 real , pointer :: wavespeed (:), tscale_up (:), tscale_dn (:), velocity (:) real , pointer :: length (:) logical , pointer :: maskarray1 (:), maskarray2 (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name maskindx1 = e2YN_Temp ( next_e2YN_temparray ) maskarray1 => elem2YN (:, maskindx1 ) next_e2YN_temparray = utility_advance_temp_array ( next_e2YN_temparray , e2YN_n_temp ) maskindx2 = e2YN_Temp ( next_e2YN_temparray ) maskarray2 => elem2YN (:, maskindx2 ) next_e2YN_temparray = utility_advance_temp_array ( next_e2YN_temparray , e2YN_n_temp ) wavespeed => elem2R (:, e2r_Temp ( next_e2r_temparray )) next_e2r_temparray = utility_advance_temp_array ( next_e2r_temparray , e2r_n_temp ) wavespeed = zeroR tscale_up => elem2R (:, e2r_Timescale_u ) tscale_dn => elem2R (:, e2r_Timescale_d ) velocity => elem2R (:, e2r_Velocity_new ) length => elem2R (:, e2r_Length ) maskarray1 = ( elem2I (:, e2i_elem_type ) == eChannel ) !%  compute timescale where ( maskarray1 ) wavespeed = sqrt ( grav * elem2R (:, e2r_HydDepth )) tscale_up = - onehalfR * length / ( velocity - wavespeed ) tscale_dn = + onehalfR * length / ( velocity + wavespeed ) endwhere !%  limiter for large, negative, and small values indx ( 1 ) = e2r_Timescale_u indx ( 2 ) = e2r_Timescale_d call timescale_limiter & ( elem2R , elem2I , elem2YN , indx , maskindx1 , maskindx2 ) wavespeed = nullvalueR maskarray1 = nullvalueL maskarray2 = nullvalueL nullify ( wavespeed , maskarray1 , maskarray2 ) next_e2r_temparray = next_e2r_temparray - 1 next_e2YN_temparray = next_e2YN_temparray - 2 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine timescale_value_channel ! !========================================================================== !========================================================================== ! subroutine timescale_value_junction & ( elemMR , elemMI , elemMYN ) character ( 64 ) :: subroutine_name = 'timescale_value_junction' real , target , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) logical , intent ( in out ) :: elemMYN (:,:) real , pointer :: wavespeed (:), length (:), velocity (:), tscale (:) integer :: eMr_waveindx !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name eMr_waveindx = eMr_Temp ( next_eMr_temparray ) wavespeed => elemMR (:, eMr_waveindx ) next_eMr_temparray = utility_advance_temp_array ( next_eMr_temparray , eMr_n_temp ) wavespeed = zeroR !%  compute wave speed where ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) wavespeed = sqrt ( grav * elemMR (:, eMr_HydDepth )) endwhere !% compute timescale for junction in each direction. call timescale_junction_one_direction & ( elemMR , elemMI , upstream_face_per_elemM , eMi_nfaces_u , & eMr_LengthUp , eMr_VelocityUp , eMr_TimescaleUp , eMr_waveindx , . true .) call timescale_junction_one_direction & ( elemMR , elemMI , dnstream_face_per_elemM , eMi_nfaces_d , & eMr_LengthDn , eMr_VelocityDn , eMr_TimescaleDn , eMr_waveindx , . false .) !%  apply limiters for negative, large, and small values call timescale_limit_junction_one_direction & ( elemMR , elemMI , elemMYN , upstream_face_per_elemM , eMI_nfaces_u , eMr_TimescaleUp ) call timescale_limit_junction_one_direction & ( elemMR , elemMI , elemMYN , dnstream_face_per_elemM , eMI_nfaces_d , eMr_TimescaleDn ) wavespeed = nullvalueR nullify ( wavespeed ) next_eMr_temparray = next_eMr_temparray - 1 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine timescale_value_junction ! !========================================================================== !========================================================================== ! subroutine timescale_junction_one_direction & ( elemMR , elemMI , dir_face_per_elemM , eMi_nfaces_dir , & eMr_LengthDir , eMr_VelocityDir , eMr_TimescaleDir , eMr_waveindx , isUp ) character ( 64 ) :: subroutine_name = 'timescale_junction_one_direction' real , target , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) integer , intent ( in ) :: eMr_LengthDir (:), eMr_VelocityDir (:), eMr_TimescaleDir (:) integer , intent ( in ) :: dir_face_per_elemM , eMi_nfaces_dir , eMr_waveindx logical , intent ( in ) :: isUp real , pointer :: length (:), velocity (:), tscale (:), wavespeed (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name wavespeed => elemMR (:, eMr_waveindx ) do mm = 1 , dir_face_per_elemM length => elemMR (:, eMr_LengthDir ( mm )) velocity => elemMR (:, eMr_VelocityDir ( mm )) tscale => elemMR (:, eMr_TimescaleDir ( mm )) if ( isUp ) then where ( ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMI (:, eMi_nfaces_dir ) >= mm ) ) tscale = - length / ( velocity - wavespeed ) endwhere else where ( ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMI (:, eMi_nfaces_dir ) >= mm ) ) tscale = + length / ( velocity + wavespeed ) endwhere endif end do if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine timescale_junction_one_direction ! !========================================================================== !========================================================================== ! subroutine timescale_limit_junction_one_direction & ( elemMR , elemMI , elemMYN , dir_face_per_elemM , eMi_nfaces_dir , eMr_TimescaleDir ) character ( 64 ) :: subroutine_name = 'timescale_limit_junction_one_direction' real , intent ( in out ) :: elemMR (:,:) integer , intent ( in ) :: elemMI (:,:) logical , target , intent ( in out ) :: elemMYN (:,:) integer , intent ( in ) :: dir_face_per_elemM , eMi_nfaces_dir integer , intent ( in ) :: eMr_TimescaleDir (:) logical , pointer :: maskarray1 (:), maskarray2 (:) integer :: mm , maskindx1 , maskindx2 integer , dimension ( 1 ) :: indx !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name maskindx1 = eMYN_Temp ( next_eMYN_temparray ) maskarray1 => elemMYN (:, maskindx1 ) next_eMYN_temparray = utility_advance_temp_array ( next_eMYN_temparray , eMYN_n_temp ) maskindx2 = eMYN_Temp ( next_eMYN_temparray ) maskarray2 => elemMYN (:, maskindx2 ) next_eMYN_temparray = utility_advance_temp_array ( next_eMYN_temparray , eMYN_n_temp ) maskarray1 = nullvalueL maskarray2 = nullvalueL do mm = 1 , dir_face_per_elemM indx ( 1 ) = eMr_TimescaleDir ( mm ) maskarray1 = (( elemMI (:, eMi_nfaces_dir ) >= mm ) . and . & ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) ) call timescale_limiter & ( elemMR , elemMI , elemMYN , indx , maskindx1 , maskindx2 ) end do maskarray1 = nullvalueL maskarray2 = nullvalueL nullify ( maskarray1 , maskarray2 ) next_eMYN_temparray = next_eMYN_temparray - 2 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine timescale_limit_junction_one_direction ! !========================================================================== !========================================================================== ! subroutine timescale_limiter & ( elemR , elemI , elemYN , indx , maskindx1 , maskindx2 ) ! ! limits the timescales to prevent negatives, small values, or large values ! character ( 64 ) :: subroutine_name = 'timescale_limiter' real , target , intent ( in out ) :: elemR (:,:) integer , intent ( in ) :: elemI (:,:) logical , target , intent ( in out ) :: elemYN (:,:) integer , intent ( in ) :: indx (:) integer , intent ( in ) :: maskindx1 , maskindx2 real , pointer :: tscale (:) logical , pointer :: maskarray1 (:), maskarray2 (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name maskarray1 => elemYN (:, maskindx1 ) maskarray2 => elemYN (:, maskindx2 ) do mm = 1 , size ( indx ) tscale => elemR (:, indx ( mm )) !%  ensure negative time scales are stored as large values maskarray2 = ( maskarray1 . and . ( tscale < 0.0 )) call apply_limiter_with_mask & ( tscale , maskarray2 , setting % Limiter % Timescale % Maximum ) !%  ensure small time scales are not below the minimum maskarray2 = ( maskarray1 . and . ( tscale < setting % Limiter % Timescale % Minimum )) call apply_limiter_with_mask & ( tscale , maskarray2 , setting % Limiter % Timescale % Minimum ) !%  ensure large time scales are not above the maximum maskarray2 = ( maskarray1 . and . ( tscale > setting % Limiter % Timescale % Maximum )) call apply_limiter_with_mask & ( tscale , maskarray2 , setting % Limiter % Timescale % Maximum ) enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine timescale_limiter ! !========================================================================== !========================================================================== ! pure subroutine apply_limiter_with_mask ( inoutarray , maskarray , limitvalue ) ! ! limits the inoutarray to the limitvalue where maskarray is true ! real , intent ( in out ) :: inoutarray (:) logical , intent ( in ) :: maskarray (:) real , intent ( in ) :: limitvalue !-------------------------------------------------------------------------- where ( maskarray ) inoutarray = limitvalue endwhere end subroutine apply_limiter_with_mask ! !========================================================================== !========================================================================== ! pure elemental function small_chezy_velocity ( ManningsN , HydRadius , Slope ) ! ! provides a chezy-manning velocity used for small volumes ! real :: small_chezy_velocity real , intent ( in ) :: ManningsN , HydRadius , Slope small_chezy_velocity = sign ( ( oneR / ManningsN ) & * ( HydRadius ** ( twothirdR )) & * sqrt ( abs ( Slope )), Slope ) end function small_chezy_velocity ! !========================================================================== !========================================================================== ! pure elemental function velocity_blend ( SmallVolumeRatio , velocity , smallVelocity ) ! ! Blends two velocity solutions based on small volume ratio ! real :: velocity_blend real , intent ( in ) :: SmallVolumeRatio , velocity , smallVelocity ! HACK - need to ensure that 0 < SmallVolumeRatio < 1 ! Cannot do it here without removing the pure elemental nature. velocity_blend = SmallVolumeRatio * velocity & + ( oneR - SmallVolumeRatio ) * smallVelocity end function velocity_blend ! !========================================================================== ! END OF MODULE element_dynamics !========================================================================== end module element_dynamics","title":"element_dynamics.f08 – SWMMengine","tags":"","loc":"sourcefile/element_dynamics.f08.html"},{"text":"This file depends on sourcefile~~array_index.f08~~EfferentGraph sourcefile~array_index.f08 array_index.f08 sourcefile~globals.f08 globals.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~array_index.f08~~AfferentGraph sourcefile~array_index.f08 array_index.f08 sourcefile~friction_model.f08 friction_model.f08 sourcefile~friction_model.f08->sourcefile~array_index.f08 sourcefile~custom_networkold.f08 custom_networkOLD.f08 sourcefile~custom_networkold.f08->sourcefile~array_index.f08 sourcefile~face_values.f08 face_values.f08 sourcefile~face_values.f08->sourcefile~array_index.f08 sourcefile~bc.f08 bc.f08 sourcefile~face_values.f08->sourcefile~bc.f08 sourcefile~utility.f08 utility.f08 sourcefile~face_values.f08->sourcefile~utility.f08 sourcefile~adjustments.f08 adjustments.f08 sourcefile~face_values.f08->sourcefile~adjustments.f08 sourcefile~stub.f08 stub.f08 sourcefile~stub.f08->sourcefile~array_index.f08 sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~runge_kutta.f08->sourcefile~array_index.f08 sourcefile~runge_kutta.f08->sourcefile~face_values.f08 sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~runge_kutta.f08->sourcefile~element_geometry.f08 sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~runge_kutta.f08->sourcefile~element_dynamics.f08 sourcefile~diagnostic.f08 diagnostic.f08 sourcefile~runge_kutta.f08->sourcefile~diagnostic.f08 sourcefile~runge_kutta.f08->sourcefile~bc.f08 sourcefile~runge_kutta.f08->sourcefile~utility.f08 sourcefile~runge_kutta.f08->sourcefile~adjustments.f08 sourcefile~element_geometry.f08->sourcefile~array_index.f08 sourcefile~element_geometry.f08->sourcefile~bc.f08 sourcefile~element_geometry.f08->sourcefile~utility.f08 sourcefile~junction.f08 junction.f08 sourcefile~element_geometry.f08->sourcefile~junction.f08 sourcefile~element_geometry.f08->sourcefile~adjustments.f08 sourcefile~initial_condition.f08 initial_condition.f08 sourcefile~initial_condition.f08->sourcefile~array_index.f08 sourcefile~initial_condition.f08->sourcefile~face_values.f08 sourcefile~initial_condition.f08->sourcefile~element_geometry.f08 sourcefile~initial_condition.f08->sourcefile~element_dynamics.f08 sourcefile~initial_condition.f08->sourcefile~bc.f08 sourcefile~initial_condition.f08->sourcefile~utility.f08 sourcefile~initial_condition.f08->sourcefile~junction.f08 sourcefile~checking.f08 checking.f08 sourcefile~checking.f08->sourcefile~array_index.f08 sourcefile~test_cases.f08 test_cases.f08 sourcefile~test_cases.f08->sourcefile~array_index.f08 sourcefile~case_y_channel.f08 case_y_channel.f08 sourcefile~test_cases.f08->sourcefile~case_y_channel.f08 sourcefile~case_simple_channel.f08 case_simple_channel.f08 sourcefile~test_cases.f08->sourcefile~case_simple_channel.f08 sourcefile~test_cases.f08->sourcefile~bc.f08 sourcefile~test_cases.f08->sourcefile~utility.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~array_index.f08 sourcefile~main.f08->sourcefile~initial_condition.f08 sourcefile~main.f08->sourcefile~checking.f08 sourcefile~main.f08->sourcefile~test_cases.f08 sourcefile~debug.f08 debug.f08 sourcefile~main.f08->sourcefile~debug.f08 sourcefile~allocate_storage.f08 allocate_storage.f08 sourcefile~main.f08->sourcefile~allocate_storage.f08 sourcefile~main.f08->sourcefile~diagnostic.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~main.f08->sourcefile~time_loop.f08 sourcefile~main.f08->sourcefile~bc.f08 sourcefile~initialization.f08 initialization.f08 sourcefile~main.f08->sourcefile~initialization.f08 sourcefile~main.f08->sourcefile~utility.f08 sourcefile~network_define.f08 network_define.f08 sourcefile~main.f08->sourcefile~network_define.f08 sourcefile~main.f08->sourcefile~junction.f08 sourcefile~output.f08 output.f08 sourcefile~main.f08->sourcefile~output.f08 sourcefile~debug.f08->sourcefile~array_index.f08 sourcefile~debug.f08->sourcefile~bc.f08 sourcefile~debug.f08->sourcefile~utility.f08 sourcefile~case_y_channel.f08->sourcefile~array_index.f08 sourcefile~case_y_channel.f08->sourcefile~allocate_storage.f08 sourcefile~case_y_channel.f08->sourcefile~bc.f08 sourcefile~allocate_storage.f08->sourcefile~array_index.f08 sourcefile~allocate_storage.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08->sourcefile~array_index.f08 sourcefile~element_dynamics.f08->sourcefile~bc.f08 sourcefile~element_dynamics.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08->sourcefile~junction.f08 sourcefile~element_dynamics.f08->sourcefile~adjustments.f08 sourcefile~diagnostic.f08->sourcefile~array_index.f08 sourcefile~diagnostic.f08->sourcefile~bc.f08 sourcefile~diagnostic.f08->sourcefile~utility.f08 sourcefile~time_loop.f08->sourcefile~array_index.f08 sourcefile~time_loop.f08->sourcefile~face_values.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~time_loop.f08->sourcefile~debug.f08 sourcefile~time_loop.f08->sourcefile~diagnostic.f08 sourcefile~time_loop.f08->sourcefile~bc.f08 sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~time_loop.f08->sourcefile~explicit_euler.f08 sourcefile~time_loop.f08->sourcefile~output.f08 sourcefile~case_simple_channel.f08->sourcefile~array_index.f08 sourcefile~case_simple_channel.f08->sourcefile~allocate_storage.f08 sourcefile~case_simple_channel.f08->sourcefile~bc.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~initialization.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~network_define.f08->sourcefile~array_index.f08 sourcefile~network_define.f08->sourcefile~allocate_storage.f08 sourcefile~network_define.f08->sourcefile~initialization.f08 sourcefile~network_define.f08->sourcefile~junction.f08 sourcefile~junction.f08->sourcefile~array_index.f08 sourcefile~junction.f08->sourcefile~utility.f08 sourcefile~explicit_euler.f08->sourcefile~array_index.f08 sourcefile~explicit_euler.f08->sourcefile~face_values.f08 sourcefile~explicit_euler.f08->sourcefile~element_geometry.f08 sourcefile~explicit_euler.f08->sourcefile~element_dynamics.f08 sourcefile~explicit_euler.f08->sourcefile~bc.f08 sourcefile~explicit_euler.f08->sourcefile~utility.f08 sourcefile~explicit_euler.f08->sourcefile~adjustments.f08 sourcefile~output.f08->sourcefile~array_index.f08 sourcefile~output.f08->sourcefile~bc.f08 sourcefile~output.f08->sourcefile~utility.f08 sourcefile~adjustments.f08->sourcefile~array_index.f08 sourcefile~adjustments.f08->sourcefile~utility.f08 var pansourcefilearray_indexf08AfferentGraph = svgPanZoom('#sourcefilearray_indexf08AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules array_index Source Code array_index.f08 Source Code ! module array_index ! ! This stores the parameters used as aliases for the column numbers in ! the elem2I, elemMI, elem2R, elemMR, elem2YN,, elemMYN, faceI, and faceR arrays. ! ! for example: elem2R(:,er_Volume) is the column with volume data for an element ! that only has 2 faces ! ! Note that this fixes the number of faces per element in elemM at 6. ! If more are needed then the code will have to be rewritten for more maps. ! ! Ben R. Hodges ! 20181105 ! !========================================================================== module array_index use globals implicit none !%  FIRST INDEXES (DO NOT CHANGE) -------------------------------------------- ! In theory, we can use different first index values for the arrays. ! This was initially used in debugging, but it seemed the gfortran compiler ! had some behaviors with non-unity starting points that I couldn't figure out. integer , parameter :: first_face_index = 1 integer , parameter :: first_elemM_index = 1 integer , parameter :: first_elem2_index = 1 !%  SIZES FOR MULTI_FACE ELEMENTS -------------------------------------------- ! design of array depends on faces per element and elements per face ! CODE NOTE: face_per_elemM must equal sum of upstream and downstream integer , parameter :: face_per_elemM = 6 !maximum number of faces per elemM 6,3 and 3 integer , parameter :: upstream_face_per_elemM = 3 !maximum number of upstream faces integer , parameter :: dnstream_face_per_elemM = 3 integer , parameter :: links_per_node = face_per_elemM !%  SIZE FOR elem2 (DO NOT CHANGE) ------------------------------------------- !CODE NOTE: require elem_per_face = 2 unless code is restructured! integer , parameter :: elem_per_face = 2 !maximum number of elements connected to face !%  elem2I ARRAY COLUMN INDEXES FOR INTEGER DATA ----------------------------- integer , parameter :: e2i_idx = 1 ! unique index of each element integer , parameter :: e2i_elem_type = 2 ! type of element integer , parameter :: e2i_geometry = 3 ! type of geometry integer , parameter :: e2i_roughness_type = 4 ! roughness type integer , parameter :: e2i_link_ID = 5 ! ID of link in the link/node space integer , parameter :: e2i_link_Pos = 6 ! position (elem from downstream = 1 to upstream = n) in link integer , parameter :: e2i_Mface_u = 7 ! map to upstream face integer , parameter :: e2i_Mface_d = 8 ! map to downstream face integer , parameter :: e2i_idx_base1 = 8 ! number of base data stored integer , parameter :: e2i_temp1 = e2i_idx_base1 + 1 integer , parameter :: e2i_temp2 = e2i_idx_base1 + 2 integer , parameter :: e2i_n_temp = 2 ! matching the number of e2i_tempX arrays integer , parameter :: e2i_idx_max = e2i_idx_base1 + e2i_n_temp ! storage for temp array index positions integer , dimension ( e2i_n_temp ) :: e2i_Temp = nullvalueI !%  elemMI ARRAY COLUMN INDEXES FOR INTEGER DATA ----------------------------- ! column index for integer central data on a multi-branch junction integer , parameter :: eMi_idx = 1 ! unique index of each element integer , parameter :: eMi_elem_type = 2 ! type of element integer , parameter :: eMi_geometry = 3 ! type of geometry integer , parameter :: eMi_nfaces = 4 ! number of faces for each element integer , parameter :: eMi_nfaces_u = 5 ! number of upstream faces for each element integer , parameter :: eMi_nfaces_d = 6 ! number of downstream faces for each element integer , parameter :: eMi_roughness_type = 7 ! roughness type integer , parameter :: eMi_node_ID = 8 ! ID of node in the link/node space integer , parameter :: eMi_temp1 = 9 integer , parameter :: eMi_temp2 = 10 integer , parameter :: eMi_idx_base1 = 10 ! number of base data stored integer , parameter :: eMi_n_temp = 2 ! matching the the number of eMi_tempX arrays ! storage for temp array index positions integer , dimension ( eMi_n_temp ) :: eMi_Temp = nullvalueI ! column index for indiviual branches of multi-branch junction integer , parameter :: eMi_Mface_u1 = eMi_idx_base1 + 1 ! map to upstream face integer , parameter :: eMi_Mface_u2 = eMi_idx_base1 + 2 integer , parameter :: eMi_Mface_u3 = eMi_idx_base1 + 3 integer , parameter :: eMi_idx_base2 = eMi_idx_base1 + upstream_face_per_elemM integer , parameter :: eMi_Mface_d1 = eMi_idx_base2 + 1 ! map to downstream face integer , parameter :: eMi_Mface_d2 = eMi_idx_base2 + 2 integer , parameter :: eMi_Mface_d3 = eMi_idx_base2 + 3 integer , parameter :: eMi_idx_max = eMi_idx_base2 + dnstream_face_per_elemM integer , dimension ( upstream_face_per_elemM ) :: eMi_MfaceUp = nullvalueI integer , dimension ( dnstream_face_per_elemM ) :: eMi_MfaceDn = nullvalueI integer , dimension ( upstream_face_per_elemM + dnstream_face_per_elemM ) :: eMi_MfaceAll = nullvalueI !%  faceI ARRAY COLUMN INDEXES FOR INTEGER DATA ----------------------------- ! column index for integer data in the faceI array integer , parameter :: fi_idx = 1 ! unique index of each face integer , parameter :: fi_type = 2 ! unique type for this face integer , parameter :: fi_Melem_u = 3 ! unique map index of upstream element integer , parameter :: fi_Melem_d = 4 ! unique map index of downstream element integer , parameter :: fi_etype_u = 5 ! type of element in nominal upstream direction integer , parameter :: fi_etype_d = 6 ! type of element in nominal downstream direction integer , parameter :: fi_branch_u = 7 ! branch # if upstream is a junction integer , parameter :: fi_branch_d = 8 ! branch # if downstream is a junciton integer , parameter :: fi_jump_type = 9 ! type of hydraulic jump integer , parameter :: fi_node_ID = 10 ! ID of node if face corresponds to a node in link/node space integer , parameter :: fi_link_ID = 11 ! ID of link if face is interior of link integer , parameter :: fi_link_Pos = 12 ! position of interior face by elem count (up to down) in link integer , parameter :: fi_BC_ID = 13 ! ID of the BC if a BC face integer , parameter :: fi_temp1 = 14 integer , parameter :: fi_temp2 = 15 integer , parameter :: fi_idx_max = 15 ! integer , parameter :: fi_n_temp = 2 ! storage for temp array index positions integer , dimension ( fi_n_temp ) :: fi_Temp = nullvalueI !%  elem2R ARRAY COLUMN INDEXES FOR REAL DATA ---------------------------------- ! column index for real data in the elem2R array integer , parameter :: e2r_Volume = 1 integer , parameter :: e2r_SmallVolume = 2 integer , parameter :: e2r_SmallVolumeRatio = 3 integer , parameter :: e2r_Flowrate = 4 integer , parameter :: e2r_Velocity = 5 integer , parameter :: e2r_Timescale_u = 6 integer , parameter :: e2r_Timescale_d = 7 integer , parameter :: e2r_Friction = 8 integer , parameter :: e2r_Eta = 9 integer , parameter :: e2r_Head = 10 integer , parameter :: e2r_Area = 11 integer , parameter :: e2r_Topwidth = 12 integer , parameter :: e2r_Perimeter = 13 integer , parameter :: e2r_HydDepth = 14 integer , parameter :: e2r_HydRadius = 15 integer , parameter :: e2r_X = 16 integer , parameter :: e2r_Length = 17 integer , parameter :: e2r_Zbottom = 18 integer , parameter :: e2r_BreadthScale = 19 integer , parameter :: e2r_Roughness = 20 integer , parameter :: e2r_VolumeConservation = 21 integer , parameter :: e2r_FroudeNumber = 22 integer , parameter :: e2r_idx_base1 = 22 integer , parameter :: e2r_temp1 = e2r_idx_base1 + 1 integer , parameter :: e2r_temp2 = e2r_idx_base1 + 2 integer , parameter :: e2r_temp3 = e2r_idx_base1 + 3 integer , parameter :: e2r_temp4 = e2r_idx_base1 + 4 integer , parameter :: e2r_temp5 = e2r_idx_base1 + 5 integer , parameter :: e2r_temp6 = e2r_idx_base1 + 6 integer , parameter :: e2r_n_temp = 6 integer , parameter :: e2r_idx_max = e2r_idx_base1 + e2r_n_temp ! storage for temp array index positions integer , dimension ( e2r_n_temp ) :: e2r_Temp = nullvalueI !%  elemMR ARRAY COLUMN INDEXES FOR REAL DATA -------------------------------- ! column index for real central data on a multi-branch junction integer , parameter :: eMr_Volume = 1 integer , parameter :: eMr_SmallVolume = 2 integer , parameter :: eMr_SmallVolumeRatio = 3 integer , parameter :: eMr_Flowrate = 4 integer , parameter :: eMr_Velocity = 5 integer , parameter :: eMr_Friction = 6 integer , parameter :: eMr_Eta = 7 integer , parameter :: eMr_Head = 8 integer , parameter :: eMr_Area = 9 integer , parameter :: eMr_Topwidth = 10 integer , parameter :: eMr_Perimeter = 11 integer , parameter :: eMr_HydDepth = 12 integer , parameter :: eMr_HydRadius = 13 integer , parameter :: eMr_X = 14 integer , parameter :: eMr_Length = 15 integer , parameter :: eMr_Zbottom = 16 integer , parameter :: eMr_BreadthScale = 17 integer , parameter :: eMr_Roughness = 18 integer , parameter :: eMr_VolumeConservation = 19 integer , parameter :: eMr_FroudeNumber = 20 integer , parameter :: eMr_idx_base1 = 20 ! column indexes for real branch data on a multi-branch junction ! note that these indexes must be consecutive by type ! always the upstream u1,u2,u3 then the downstream d1, d2, d3 integer , parameter :: eMr_Eta_u1 = eMr_idx_base1 + 1 ! Q in the u1 branch integer , parameter :: eMr_Eta_u2 = eMr_idx_base1 + 2 integer , parameter :: eMr_Eta_u3 = eMr_idx_base1 + 3 integer , parameter :: eMr_idx_base2 = eMr_idx_base1 + upstream_face_per_elemM integer , parameter :: eMr_Eta_d1 = eMr_idx_base2 + 1 integer , parameter :: eMr_Eta_d2 = eMr_idx_base2 + 2 integer , parameter :: eMr_Eta_d3 = eMr_idx_base2 + 3 integer , parameter :: eMr_idx_base3 = eMr_idx_base2 + dnstream_face_per_elemM integer , parameter :: eMr_Flowrate_u1 = eMr_idx_base3 + 1 ! Q in the u1 branch integer , parameter :: eMr_Flowrate_u2 = eMr_idx_base3 + 2 integer , parameter :: eMr_Flowrate_u3 = eMr_idx_base3 + 3 integer , parameter :: eMr_idx_base4 = eMr_idx_base3 + upstream_face_per_elemM integer , parameter :: eMr_Flowrate_d1 = eMr_idx_base4 + 1 integer , parameter :: eMr_Flowrate_d2 = eMr_idx_base4 + 2 integer , parameter :: eMr_Flowrate_d3 = eMr_idx_base4 + 3 integer , parameter :: eMr_idx_base5 = eMr_idx_base4 + dnstream_face_per_elemM integer , parameter :: eMr_Velocity_u1 = eMr_idx_base5 + 1 ! Q in the u1 branch integer , parameter :: eMr_Velocity_u2 = eMr_idx_base5 + 2 integer , parameter :: eMr_Velocity_u3 = eMr_idx_base5 + 3 integer , parameter :: eMr_idx_base6 = eMr_idx_base5 + upstream_face_per_elemM integer , parameter :: eMr_Velocity_d1 = eMr_idx_base6 + 1 integer , parameter :: eMr_Velocity_d2 = eMr_idx_base6 + 2 integer , parameter :: eMr_Velocity_d3 = eMr_idx_base6 + 3 integer , parameter :: eMr_idx_base7 = eMr_idx_base6 + dnstream_face_per_elemM integer , parameter :: eMr_Timescale_u1 = eMr_idx_base7 + 1 integer , parameter :: eMr_Timescale_u2 = eMr_idx_base7 + 2 integer , parameter :: eMr_Timescale_u3 = eMr_idx_base7 + 3 integer , parameter :: eMr_idx_base8 = eMr_idx_base7 + upstream_face_per_elemM integer , parameter :: eMr_Timescale_d1 = eMr_idx_base8 + 1 integer , parameter :: eMr_Timescale_d2 = eMr_idx_base8 + 2 integer , parameter :: eMr_Timescale_d3 = eMr_idx_base8 + 3 integer , parameter :: eMr_idx_base9 = eMr_idx_base8 + dnstream_face_per_elemM integer , parameter :: eMr_Area_u1 = eMr_idx_base9 + 1 integer , parameter :: eMr_Area_u2 = eMr_idx_base9 + 2 integer , parameter :: eMr_Area_u3 = eMr_idx_base9 + 3 integer , parameter :: eMr_idx_base10 = eMr_idx_base9 + upstream_face_per_elemM integer , parameter :: eMr_Area_d1 = eMr_idx_base10 + 1 integer , parameter :: eMr_Area_d2 = eMr_idx_base10 + 2 integer , parameter :: eMr_Area_d3 = eMr_idx_base10 + 3 integer , parameter :: eMr_idx_base11 = eMr_idx_base10 + dnstream_face_per_elemM integer , parameter :: eMr_Topwidth_u1 = eMr_idx_base11 + 1 integer , parameter :: eMr_Topwidth_u2 = eMr_idx_base11 + 2 integer , parameter :: eMr_Topwidth_u3 = eMr_idx_base11 + 3 integer , parameter :: eMr_idx_base12 = eMr_idx_base11 + upstream_face_per_elemM integer , parameter :: eMr_Topwidth_d1 = eMr_idx_base12 + 1 integer , parameter :: eMr_Topwidth_d2 = eMr_idx_base12 + 2 integer , parameter :: eMr_Topwidth_d3 = eMr_idx_base12 + 3 integer , parameter :: eMr_idx_base13 = eMr_idx_base12 + dnstream_face_per_elemM integer , parameter :: eMr_HydDepth_u1 = eMr_idx_base13 + 1 integer , parameter :: eMr_HydDepth_u2 = eMr_idx_base13 + 2 integer , parameter :: eMr_HydDepth_u3 = eMr_idx_base13 + 3 integer , parameter :: eMr_idx_base14 = eMr_idx_base13 + upstream_face_per_elemM integer , parameter :: eMr_HydDepth_d1 = eMr_idx_base14 + 1 integer , parameter :: eMr_HydDepth_d2 = eMr_idx_base14 + 2 integer , parameter :: eMr_HydDepth_d3 = eMr_idx_base14 + 3 integer , parameter :: eMr_idx_base15 = eMr_idx_base14 + dnstream_face_per_elemM integer , parameter :: eMr_Length_u1 = eMr_idx_base15 + 1 integer , parameter :: eMr_Length_u2 = eMr_idx_base15 + 2 integer , parameter :: eMr_Length_u3 = eMr_idx_base15 + 3 integer , parameter :: eMr_idx_base16 = eMr_idx_base15 + upstream_face_per_elemM integer , parameter :: eMr_Length_d1 = eMr_idx_base16 + 1 integer , parameter :: eMr_Length_d2 = eMr_idx_base16 + 2 integer , parameter :: eMr_Length_d3 = eMr_idx_base16 + 3 integer , parameter :: eMr_idx_base17 = eMr_idx_base16 + dnstream_face_per_elemM integer , parameter :: eMr_Zbottom_u1 = eMr_idx_base17 + 1 integer , parameter :: eMr_Zbottom_u2 = eMr_idx_base17 + 2 integer , parameter :: eMr_Zbottom_u3 = eMr_idx_base17 + 3 integer , parameter :: eMr_idx_base18 = eMr_idx_base17 + upstream_face_per_elemM integer , parameter :: eMr_Zbottom_d1 = eMr_idx_base18 + 1 integer , parameter :: eMr_Zbottom_d2 = eMr_idx_base18 + 2 integer , parameter :: eMr_Zbottom_d3 = eMr_idx_base18 + 3 integer , parameter :: eMr_idx_base19 = eMr_idx_base18 + dnstream_face_per_elemM integer , parameter :: eMr_BreadthScale_u1 = eMr_idx_base19 + 1 integer , parameter :: eMr_BreadthScale_u2 = eMr_idx_base19 + 2 integer , parameter :: eMr_BreadthScale_u3 = eMr_idx_base19 + 3 integer , parameter :: eMr_idx_base20 = eMr_idx_base19 + upstream_face_per_elemM integer , parameter :: eMr_BreadthScale_d1 = eMr_idx_base20 + 1 integer , parameter :: eMr_BreadthScale_d2 = eMr_idx_base20 + 2 integer , parameter :: eMr_BreadthScale_d3 = eMr_idx_base20 + 3 integer , parameter :: eMr_idx_base21 = eMr_idx_base20 + dnstream_face_per_elemM integer , parameter :: eMr_temp1 = eMr_idx_base21 + 1 integer , parameter :: eMr_temp2 = eMr_idx_base21 + 2 integer , parameter :: eMr_temp3 = eMr_idx_base21 + 3 integer , parameter :: eMr_temp4 = eMr_idx_base21 + 4 integer , parameter :: eMr_temp5 = eMr_idx_base21 + 5 integer , parameter :: eMr_temp6 = eMr_idx_base21 + 6 integer , parameter :: eMr_n_temp = 6 integer , parameter :: eMr_idx_base22 = eMr_idx_base21 + eMr_n_temp integer , parameter :: eMr_idx_max = eMr_idx_base22 ! storage for temp array index positions integer , dimension ( eMr_n_temp ) :: eMr_Temp = nullvalueI ! storage arrays for all the column indexes on upstream branches integer , dimension ( upstream_face_per_elemM ) :: eMr_EtaUp = nullvalueI integer , dimension ( upstream_face_per_elemM ) :: eMr_FlowrateUp = nullvalueI integer , dimension ( upstream_face_per_elemM ) :: eMr_VelocityUp = nullvalueI integer , dimension ( upstream_face_per_elemM ) :: eMr_TimescaleUp = nullvalueI integer , dimension ( upstream_face_per_elemM ) :: eMr_AreaUp = nullvalueI integer , dimension ( upstream_face_per_elemM ) :: eMr_TopwidthUp = nullvalueI integer , dimension ( upstream_face_per_elemM ) :: eMr_HydDepthUp = nullvalueI integer , dimension ( upstream_face_per_elemM ) :: eMr_LengthUp = nullvalueI integer , dimension ( upstream_face_per_elemM ) :: eMr_ZbottomUp = nullvalueI integer , dimension ( upstream_face_per_elemM ) :: eMr_BreadthScaleUp = nullvalueI ! storage arrays for all the column indexes on downstream branches integer , dimension ( dnstream_face_per_elemM ) :: eMr_EtaDn = nullvalueI integer , dimension ( dnstream_face_per_elemM ) :: eMr_FlowrateDn = nullvalueI integer , dimension ( dnstream_face_per_elemM ) :: eMr_VelocityDn = nullvalueI integer , dimension ( dnstream_face_per_elemM ) :: eMr_TimescaleDn = nullvalueI integer , dimension ( dnstream_face_per_elemM ) :: eMr_AreaDn = nullvalueI integer , dimension ( dnstream_face_per_elemM ) :: eMr_TopwidthDn = nullvalueI integer , dimension ( dnstream_face_per_elemM ) :: eMr_HydDepthDn = nullvalueI integer , dimension ( dnstream_face_per_elemM ) :: eMr_LengthDn = nullvalueI integer , dimension ( dnstream_face_per_elemM ) :: eMr_ZbottomDn = nullvalueI integer , dimension ( upstream_face_per_elemM ) :: eMr_BreadthScaleDn = nullvalueI ! storage arrays for all the column indexes of all branches integer , dimension ( face_per_elemM ) :: eMr_EtaAll = nullvalueI integer , dimension ( face_per_elemM ) :: eMr_FlowrateAll = nullvalueI integer , dimension ( face_per_elemM ) :: eMr_VelocityAll = nullvalueI integer , dimension ( face_per_elemM ) :: eMr_TimescaleAll = nullvalueI integer , dimension ( face_per_elemM ) :: eMr_AreaAll = nullvalueI integer , dimension ( face_per_elemM ) :: eMr_TopwidthAll = nullvalueI integer , dimension ( face_per_elemM ) :: eMr_HydDepthAll = nullvalueI integer , dimension ( face_per_elemM ) :: eMr_LengthAll = nullvalueI integer , dimension ( face_per_elemM ) :: eMr_ZbottomAll = nullvalueI integer , dimension ( face_per_elemM ) :: eMr_BreadthScaleAll = nullvalueI !%  faceR COLUMN INDEXES FOR REAL DATA ON FACE ------------------------------- ! column index for real faceR array integer , parameter :: fr_Area_d = 1 ! area on downstream side of face (AreaP in SvePy) integer , parameter :: fr_Area_u = 2 ! area on upstream side of face (AreaM in SvePy) integer , parameter :: fr_Eta_d = 3 ! free surface on upstream side of face integer , parameter :: fr_Eta_u = 4 ! free surface on downstream side of face integer , parameter :: fr_Flowrate = 5 integer , parameter :: fr_HydDepth_d = 6 integer , parameter :: fr_HydDepth_u = 7 integer , parameter :: fr_Topwidth = 8 integer , parameter :: fr_Velocity_d = 9 ! velocity on downstream side of face (velocityP in SvePy) integer , parameter :: fr_Velocity_u = 10 ! velocity on upstream side of face (velocityM in SvePy) integer , parameter :: fr_Zbottom = 11 integer , parameter :: fr_X = 12 integer , parameter :: fr_temp1 = 13 integer , parameter :: fr_temp2 = 14 integer , parameter :: fr_temp3 = 15 integer , parameter :: fr_temp4 = 16 integer , parameter :: fr_idx_max = 16 integer , parameter :: fr_n_temp = 4 ! storage for temp array index positions integer , dimension ( fr_n_temp ) :: fr_Temp = nullvalueI !%  elem2YN COLUMN INDEXES FOR LOGICAL DATA ON CHANNEL ELEMENT --------------- ! column index for logical data in elem2YN array integer , parameter :: e2YN_IsSmallVolume = 1 integer , parameter :: e2YN_IsAdhocFlowrate = 2 integer , parameter :: e2YN_temp1 = 3 integer , parameter :: e2YN_temp2 = 4 integer , parameter :: e2YN_temp3 = 5 integer , parameter :: e2YN_temp4 = 6 integer , parameter :: e2YN_idx_max = 6 integer , parameter :: e2YN_n_temp = 4 ! storage for temp array index positions integer , dimension ( e2YN_n_temp ) :: e2YN_Temp = nullvalueI !%  elemMYN COLUMN INDEXES FOR LOGICAL DATA ON MULTI-BRANCH JUNCTION --------- ! column index for logical data in elemMYN array integer , parameter :: eMYN_IsSmallVolume = 1 integer , parameter :: eMYN_IsAdhocFlowrate = 2 integer , parameter :: eMYN_temp1 = 3 integer , parameter :: eMYN_temp2 = 4 integer , parameter :: eMYN_temp3 = 5 integer , parameter :: eMYN_temp4 = 6 integer , parameter :: eMYN_idx_max = 6 integer , parameter :: eMYN_n_temp = 4 ! storage for temp array index positions integer , dimension ( eMYN_n_temp ) :: eMYN_Temp = nullvalueI !%  faceYN COLUMN INDEXES FOR LOGICAL DATA ON FACE ! column index for logical data in elemYN array integer , parameter :: fYN_temp1 = 1 integer , parameter :: fYN_temp2 = 2 integer , parameter :: fYN_idx_max = 2 integer , parameter :: fYN_n_temp = 2 ! storage for temp array index positions integer , dimension ( fYN_n_temp ) :: fYN_Temp = nullvalueI !%  linkI COLUMN INDEXES FOR INTEGER DATA OF LINKS IN LINK/NODE SYSTEM ------- ! column index for integer data in linkI array integer , parameter :: li_idx = 1 integer , parameter :: li_link_type = 2 integer , parameter :: li_geometry = 3 integer , parameter :: li_roughness_type = 4 integer , parameter :: li_N_element = 5 ! Number of elements in this link integer , parameter :: li_Mnode_u = 6 ! map to upstream node connecting to link integer , parameter :: li_Mnode_d = 7 ! map to downstram node connecting to link integer , parameter :: li_Melem_u = 8 ! element ID of upstream element of link integer , parameter :: li_Melem_d = 9 ! element ID of downstream element of link integer , parameter :: li_Mface_u = 10 ! face ID of upstream face of link integer , parameter :: li_Mface_d = 11 ! face ID of downstream face of link integer , parameter :: li_assigned = 12 ! given 1 when link is assigned integer , parameter :: li_InitialDepthType = 13 ! 1=uniform, 2= lineary change, 3=exponential decay integer , parameter :: li_temp1 = 14 integer , parameter :: li_idx_max = 14 !%  nodeI COLUMN INDEXES FOR INTEGER DATA OF NODES IN LINK/NODE SYSTEM ------- ! column index for integer data in nodeI array integer , parameter :: ni_idx = 1 integer , parameter :: ni_node_type = 2 integer , parameter :: ni_N_link_u = 3 ! number of upstream links at this node integer , parameter :: ni_N_link_d = 4 ! number of downstram links at this node integer , parameter :: ni_assigned = 5 ! given 1 when node has been assigned to face/elem, integer , parameter :: ni_temp1 = 6 integer , parameter :: ni_idx_base1 = 6 ! column indexes for multi-branch nodes integer , parameter :: ni_Mlink_u1 = ni_idx_base1 + 1 ! map to link of upstream branch 1 integer , parameter :: ni_Mlink_u2 = ni_idx_base1 + 2 ! map to link up dowstream branch 1 integer , parameter :: ni_Mlink_u3 = ni_idx_base1 + 3 integer , parameter :: ni_idx_base2 = ni_idx_base1 + upstream_face_per_elemM integer , parameter :: ni_Mlink_d1 = ni_idx_base2 + 1 integer , parameter :: ni_Mlink_d2 = ni_idx_base2 + 2 integer , parameter :: ni_Mlink_d3 = ni_idx_base2 + 3 integer , parameter :: ni_idx_max = ni_idx_base2 + dnstream_face_per_elemM ! storage for link index for upstream and downstream links integer , dimension ( upstream_face_per_elemM ) :: ni_MlinkUp = nullvalueI integer , dimension ( dnstream_face_per_elemM ) :: ni_MlinkDn = nullvalueI !%  linkR COLUMN INDEXES FOR REAL DATA OF LINKS IN LINK/NODE SYSTEM  -------- ! column index for real data in the linkR array integer , parameter :: lr_Length = 1 integer , parameter :: lr_BreadthScale = 2 integer , parameter :: lr_ElementLength = 3 integer , parameter :: lr_Slope = 4 integer , parameter :: lr_Roughness = 5 integer , parameter :: lr_InitialFlowrate = 6 integer , parameter :: lr_InitialDepth = 7 integer , parameter :: lr_InitialUpstreamDepth = 8 integer , parameter :: lr_InitialDnstreamDepth = 9 integer , parameter :: lr_temp1 = 10 integer , parameter :: lr_idx_max = 10 !%  nodeR COLUMN INDEXES FOR REAL DATA OF NODES IN LINK/NODE SYSTEM ---------- ! column index for real data in the nodeR array integer , parameter :: nr_Zbottom = 1 integer , parameter :: nr_temp1 = 2 integer , parameter :: nr_idx_base1 = 2 ! column index for real data on multiple branches of a node integer , parameter :: nr_ElementLength_u1 = nr_idx_base1 + 1 ! used for subdividing junctions integer , parameter :: nr_ElementLength_u2 = nr_idx_base1 + 2 ! used for subdividing junctions integer , parameter :: nr_ElementLength_u3 = nr_idx_base1 + 3 ! used for subdividing junctions integer , parameter :: nr_idx_base2 = nr_idx_base1 + upstream_face_per_elemM integer , parameter :: nr_ElementLength_d1 = nr_idx_base2 + 1 ! used for subdividing junctions integer , parameter :: nr_ElementLength_d2 = nr_idx_base2 + 2 ! used for subdividing junctions integer , parameter :: nr_ElementLength_d3 = nr_idx_base2 + 3 ! used for subdividing junctions integer , parameter :: nr_idx_max = nr_idx_base2 + dnstream_face_per_elemM ! storage of node indexes for multi-branch data integer , dimension ( upstream_face_per_elemM ) :: nr_ElementLengthUp = nullvalueI integer , dimension ( dnstream_face_per_elemM ) :: nr_ElementLengthDn = nullvalueI !%  nodeYN COLUMN INDEXES FOR LOGICAL DATA ON NODES -------------------------- ! column index for logical data in nodeYN array integer , parameter :: nYN_temp1 = 1 integer , parameter :: nYN_idx_max = 1 !%  linkYN COLUMN INDEXES FOR LOGICAL DATA ON LINKS --------------------------- ! column index for logical data in linkYN array integer , parameter :: lYN_temp1 = 1 integer , parameter :: lYN_idx_max = 1 !========================================================================== ! END OF MODULE array_index !========================================================================== end module array_index","title":"array_index.f08 – SWMMengine","tags":"","loc":"sourcefile/array_index.f08.html"},{"text":"This file depends on sourcefile~~custom_networkold.f08~~EfferentGraph sourcefile~custom_networkold.f08 custom_networkOLD.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~custom_networkold.f08->sourcefile~data_keys.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~custom_networkold.f08->sourcefile~array_index.f08 sourcefile~globals.f08 globals.f08 sourcefile~custom_networkold.f08->sourcefile~globals.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 var pansourcefilecustom_networkoldf08EfferentGraph = svgPanZoom('#sourcefilecustom_networkoldf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules custom_network Source Code custom_networkOLD.f08 Source Code !========================================================================== ! module custom_network use array_index use data_keys use globals implicit none private public :: custom_1link_network public :: custom_6link_1_line_network public :: custom_3link_Y_network public :: custom_6link_Y_network integer , private :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine custom_1link_network & ( linkR , nodeR , linkI , nodeI , linkName , nodeName ) ! ! one link that is a simple rectangular open channel ! Basic setup ! Overall length = 10,000 m ! Upstream Zbottom = 11 m ! Downstream Zbottom = 1 m ! effective slope is 0.001 ! Channel breadth is 3 m ! Mannings n = 0.03 ! Target depth = 0.5 m ! flow rate = (1/0.03) * 1.5 * (1.5 / 4)&#94;(2/3) * (0.001)&#94;(1/2) = 0.822225 m&#94;3/s ! character ( 64 ) :: subroutine_name = 'custom_1link_network' integer , intent ( in out ) :: linkI (:,:) integer , intent ( in out ) :: nodeI (:,:) real , intent ( in out ) :: linkR (:,:) real , intent ( in out ) :: nodeR (:,:) type ( string ), dimension (:), intent ( in out ) :: nodeName , linkName integer :: ii integer :: thisnode !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name ! ERROR CHECK -------------------------- if ( N_link /= 1 ) then print * , 'error this network requires 1 links in ' , subroutine_name STOP endif if ( N_node /= 2 ) then print * , 'error this network requires 2 nodes in ' , subroutine_name STOP endif ! SET UP CONNECTIVITY AND PHYSICS ------------------ ! assign the indexes linkI (:, li_idx ) = ( / ( ii , ii = 1 , N_link ) / ) nodeI (:, ni_idx ) = ( / ( ii , ii = 1 , N_node ) / ) ! assign no names for links do ii = 1 , N_link linkName ( ii )% str = \"\" end do ! assign zeros for accumulators nodeI (:, ni_N_link_d ) = 0 nodeI (:, ni_N_link_u ) = 0 ! assign uniform physical data linkI (:, li_roughness_type ) = lManningsN ! designate the upstream nodes nodeI ( 1 , ni_node_type ) = nBCup nodeR ( 1 , nr_Zbottom ) = 1 0.0 nodeName ( 1 )% str = 'UpstreamBC' ! designate the downstream node nodeI ( 2 , ni_node_type ) = nBCdn nodeR ( 2 , nr_Zbottom ) = 1.0 nodeName ( 2 )% str = 'DownstreamBC' ! assign the link types linkI (:, li_link_type ) = lChannel ! assign all as rectangular channels linkI (:, li_geometry ) = lRectangular ! assign the link position and mappings ! link 1 linkI ( 1 , li_Mnode_u ) = 1 ! map to upstream node linkI ( 1 , li_Mnode_d ) = 2 ! map to downstream node linkR ( 1 , lr_Length ) = 1000 0.0 linkR ( 1 , lr_Breadth ) = 3.0 ! cycle through links to assign nodes do ii = 1 , N_link ! get the upstream node of the link (if it exists) thisnode = linkI ( ii , li_Mnode_u ) ! look for next available downstream link position if ( thisnode > 0 ) then if ( nodeI ( thisnode , ni_Mlink_d1 ) == nullvalueI ) then nodeI ( thisnode , ni_Mlink_d1 ) = ii else print * , 'node ' , thisnode print * , 'error: attempt to assign 2 downstream links to 1 node in ' , subroutine_name stop endif ! increment the downstream link counter nodeI ( thisnode , ni_N_link_d ) = nodeI ( thisnode , ni_N_link_d ) + 1 endif ! get the downstream node of the link (if it exists) thisnode = linkI ( ii , li_Mnode_d ) ! look for the next available upstream link position if ( thisnode > 0 ) then if ( nodeI ( thisnode , ni_Mlink_u1 ) == nullvalueI ) then nodeI ( thisnode , ni_Mlink_u1 ) = ii elseif ( nodeI ( thisnode , ni_Mlink_u2 ) == nullvalueI ) then nodeI ( thisnode , ni_Mlink_u2 ) = ii else print * , 'node ' , thisnode print * , 'error: attempt to assign 3 upstream links to 1 node in ' , subroutine_name stop endif ! increment the upstream link counter nodeI ( thisnode , ni_N_link_u ) = nodeI ( thisnode , ni_N_link_u ) + 1 endif enddo print * print * , 'link info' print * , linkI (:, li_idx ), ' idx' print * , linkI (:, li_link_type ), ' type' print * , linkI (:, li_Mnode_u ) , ' upstream node' print * , linkI (:, li_Mnode_d ) , ' downstream node' print * , print * , 'node info' print * , nodeI (:, ni_idx ), ' idx' print * , nodeI (:, ni_node_type ), ' type' print * , nodeI (:, ni_N_link_d ), 'number of downstream links' print * , nodeI (:, ni_Mlink_d1 ), 'downstream1 link' print * , nodeI (:, ni_N_link_u ), 'number of upstream links' print * , nodeI (:, ni_Mlink_u1 ), 'upstream1 link' !stop if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine custom_1link_network ! !========================================================================== !========================================================================== ! subroutine custom_6link_1_line_network & ( linkR , nodeR , linkI , nodeI , linkName , nodeName ) character ( 64 ) :: subroutine_name = 'custom_6link_1_line_network' integer , intent ( in out ) :: linkI (:,:) integer , intent ( in out ) :: nodeI (:,:) real , intent ( in out ) :: linkR (:,:) real , intent ( in out ) :: nodeR (:,:) type ( string ), dimension (:), intent ( in out ) :: linkName , nodeName integer :: ii integer :: thisnode !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name ! ERROR CHECK -------------------------- if ( N_link /= 6 ) then print * , 'error this network requires 6 links in ' , subroutine_name STOP endif if ( N_node /= 7 ) then print * , 'error this network requires 7 nodes in ' , subroutine_name STOP endif ! SET UP CONNECTIVITY AND PHYSICS ------------------ ! assign the indexes linkI (:, li_idx ) = ( / ( ii , ii = 1 , N_link ) / ) nodeI (:, ni_idx ) = ( / ( ii , ii = 1 , N_node ) / ) ! assign zeros for accumulators nodeI (:, ni_N_link_d ) = 0 nodeI (:, ni_N_link_u ) = 0 ! assign uniform physical data linkI (:, li_roughness_type ) = lManningsN ! assign no names for links do ii = 1 , N_link linkName ( ii )% str = \"\" end do !print *, linkI(:,li_idx) !print *, nodeI(:,ni_idx) ! designate the upstream nodes nodeI ( 1 , ni_node_type ) = nBCup nodeR ( 1 , nr_Zbottom ) = 1 0.0 nodeName ( 1 )% str = 'UpstreamBC' ! designate intermediate nodes nodeI ( 2 : 6 , ni_node_type ) = nJ2 nodeR ( 2 , nr_Zbottom ) = 1 0.0 nodeR ( 3 , nr_Zbottom ) = 9.0 nodeR ( 4 , nr_Zbottom ) = 7.0 nodeR ( 5 , nr_Zbottom ) = 6.0 nodeR ( 6 , nr_Zbottom ) = 4.0 nodeName ( 2 )% str = 'inter01' nodeName ( 3 )% str = 'inter02' nodeName ( 4 )% str = 'inter03' nodeName ( 5 )% str = 'inter04' nodeName ( 6 )% str = 'inter05' ! designate the downstream node nodeI ( 7 , ni_node_type ) = nBCdn nodeR ( 7 , nr_Zbottom ) = 1.5 nodeName ( 7 )% str = 'DownstreamBC' ! assign the link types linkI (:, li_link_type ) = lChannel ! assign all as rectangular channels linkI (:, li_geometry ) = lRectangular ! assign the link position and mappings ! link 1 linkI ( 1 , li_Mnode_u ) = 1 ! map to upstream node linkI ( 1 , li_Mnode_d ) = 2 ! map to downstream node linkR ( 1 , lr_Length ) = 15 5.0 linkR ( 1 , lr_Breadth ) = 2.5 ! link 2 linkI ( 2 , li_Mnode_u ) = 2 ! map to upstream node linkI ( 2 , li_Mnode_d ) = 3 ! map to downstream node linkR ( 2 , lr_Length ) = 24 7.0 linkR ( 2 , lr_Breadth ) = 3.2 ! link 3 linkI ( 3 , li_Mnode_u ) = 3 ! map to upstream node linkI ( 3 , li_Mnode_d ) = 4 ! map to downstream node linkR ( 3 , lr_Length ) = 32 3.0 linkR ( 3 , lr_Breadth ) = 4.1 ! link 4 linkI ( 4 , li_Mnode_u ) = 4 ! map to upstream node linkI ( 4 , li_Mnode_d ) = 5 ! map to downstream node linkR ( 4 , lr_Length ) = 28 0.0 linkR ( 4 , lr_Breadth ) = 3.9 ! link 5 linkI ( 5 , li_Mnode_u ) = 5 ! map to upstream node linkI ( 5 , li_Mnode_d ) = 6 ! map to downstream node linkR ( 5 , lr_Length ) = 25 6.0 linkR ( 5 , lr_Breadth ) = 4.5 ! link 6 linkI ( 6 , li_Mnode_u ) = 6 ! map to upstream node linkI ( 6 , li_Mnode_d ) = 7 ! map to downstream node linkR ( 6 , lr_Length ) = 12 3.0 linkR ( 6 , lr_Breadth ) = 4.7 ! cycle through links to assign nodes do ii = 1 , N_link ! get the upstream node of the link (if it exists) thisnode = linkI ( ii , li_Mnode_u ) ! look for next available downstream link position if ( thisnode > 0 ) then if ( nodeI ( thisnode , ni_Mlink_d1 ) == nullvalueI ) then nodeI ( thisnode , ni_Mlink_d1 ) = ii else print * , 'node ' , thisnode print * , 'error: attempt to assign 2 downstream links to 1 node in ' , subroutine_name stop endif ! increment the downstream link counter nodeI ( thisnode , ni_N_link_d ) = nodeI ( thisnode , ni_N_link_d ) + 1 endif ! get the downstream node of the link (if it exists) thisnode = linkI ( ii , li_Mnode_d ) ! look for the next available upstream link position if ( thisnode > 0 ) then if ( nodeI ( thisnode , ni_Mlink_u1 ) == nullvalueI ) then nodeI ( thisnode , ni_Mlink_u1 ) = ii elseif ( nodeI ( thisnode , ni_Mlink_u2 ) == nullvalueI ) then nodeI ( thisnode , ni_Mlink_u2 ) = ii else print * , 'node ' , thisnode print * , 'error: attempt to assign 3 upstream links to 1 node in ' , subroutine_name stop endif ! increment the upstream link counter nodeI ( thisnode , ni_N_link_u ) = nodeI ( thisnode , ni_N_link_u ) + 1 endif enddo print * print * , 'link info' print * , linkI (:, li_idx ), ' idx' print * , linkI (:, li_link_type ), ' type' print * , linkI (:, li_Mnode_u ) , ' upstream node' print * , linkI (:, li_Mnode_d ) , ' downstream node' print * , print * , 'node info' print * , nodeI (:, ni_idx ), ' idx' print * , nodeI (:, ni_node_type ), ' type' print * , nodeI (:, ni_N_link_d ), 'number of downstream links' print * , nodeI (:, ni_Mlink_d1 ), 'downstream1 link' !print *, nodeI(:,ni_Mlink_d2), 'downstream2 link' !print *, nodeI(:,ni_Mlink_d3), 'downstream2 link' print * , nodeI (:, ni_N_link_u ), 'number of upstream links' print * , nodeI (:, ni_Mlink_u1 ), 'upstream1 link' !print *, nodeI(:,ni_Mlink_u2), 'upstream2 link' !print *, nodeI(:,ni_Mlink_u3), 'upstream2 link' !print *, nodeI(2,8) !stop if ( debuglevel > 0 ) print * , '*** leave ' , subroutine_name end subroutine custom_6link_1_line_network ! !========================================================================== !========================================================================== ! subroutine custom_3link_Y_network & ( linkR , nodeR , linkI , nodeI , linkName , nodeName ) character ( 64 ) :: subroutine_name = 'custom_3link_Y_network' integer , intent ( in out ) :: linkI (:,:) integer , intent ( in out ) :: nodeI (:,:) real , intent ( in out ) :: linkR (:,:) real , intent ( in out ) :: nodeR (:,:) type ( string ), dimension (:), intent ( in out ) :: linkName , nodeName integer :: ii integer :: thisnode !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name ! ERROR CHECK -------------------------- if ( N_link /= 3 ) then print * , 'error this network requires 3 links in ' , subroutine_name STOP endif if ( N_node /= 4 ) then print * , 'error this network requires 4 nodes in ' , subroutine_name STOP endif ! SET UP CONNECTIVITY AND PHYSICS ------------------ ! assign the indexes linkI (:, li_idx ) = ( / ( ii , ii = 1 , N_link ) / ) nodeI (:, ni_idx ) = ( / ( ii , ii = 1 , N_node ) / ) ! assign zeros for accumulators nodeI (:, ni_N_link_d ) = 0 nodeI (:, ni_N_link_u ) = 0 ! assign uniform physical data linkI (:, li_roughness_type ) = lManningsN ! assign no names for links do ii = 1 , N_link linkName ( ii )% str = \"\" end do !print *, linkI(:,li_idx) !print *, nodeI(:,ni_idx) ! designate the upstream nodes nodeI ( 1 , ni_node_type ) = nBCup nodeI ( 3 , ni_node_type ) = nBCup nodeR ( 1 , nr_Zbottom ) = 1 0.0 nodeR ( 3 , nr_Zbottom ) = 1 0.0 nodeName ( 1 )% str = 'UpstreamBC01' nodeName ( 3 )% str = 'UpstreamBC02' ! designate the junction node for multiple links nodeI ( 2 , ni_node_type ) = nJm nodeR ( 2 , nr_Zbottom ) = 5.0 nodeName ( 2 )% str = 'Junction' ! designate the downstream node nodeI ( 4 , ni_node_type ) = nBCdn nodeR ( 4 , nr_Zbottom ) = 0 nodeName ( 4 )% str = 'DownstreamBC' ! assign the link types linkI (:, li_link_type ) = lChannel ! assign all as rectangular channels linkI (:, li_geometry ) = lRectangular ! assign the link position and mappings ! link 1 - upstream Y branch 1 linkI ( 1 , li_Mnode_u ) = 1 ! map to upstream node linkI ( 1 , li_Mnode_d ) = 2 ! map to downstream node linkR ( 1 , lr_Length ) = 1000 0.0 linkR ( 1 , lr_Breadth ) = 2.5 ! link 2 - upstream Y branch 2 linkI ( 2 , li_Mnode_u ) = 3 ! map to upstream node linkI ( 2 , li_Mnode_d ) = 2 ! map to downstream node linkR ( 2 , lr_Length ) = 1000 0.0 linkR ( 2 , lr_Breadth ) = 3.2 ! link 3 - downstram branch linkI ( 3 , li_Mnode_u ) = 2 ! map to upstream node linkI ( 3 , li_Mnode_d ) = 4 ! map to downstream node linkR ( 3 , lr_Length ) = 1000 0.0 linkR ( 3 , lr_Breadth ) = 4.1 ! cycle through links to assign nodes do ii = 1 , N_link ! get the upstream node of the link (if it exists) thisnode = linkI ( ii , li_Mnode_u ) ! look for next available downstream link position if ( thisnode > 0 ) then if ( nodeI ( thisnode , ni_Mlink_d1 ) == nullvalueI ) then nodeI ( thisnode , ni_Mlink_d1 ) = ii else print * , 'node ' , thisnode print * , 'ni_Mlink_d1 ' , ni_Mlink_d1 print * , 'nodeI(thisnode,ni_Mlink_d1) ' , nodeI ( thisnode , ni_Mlink_d1 ) print * , 'error: attempt to assign 2 downstream links to 1 node in ' , subroutine_name stop endif ! increment the downstream link counter nodeI ( thisnode , ni_N_link_d ) = nodeI ( thisnode , ni_N_link_d ) + 1 endif ! get the downstream node of the link (if it exists) thisnode = linkI ( ii , li_Mnode_d ) ! look for the next available upstream link position if ( thisnode > 0 ) then if ( nodeI ( thisnode , ni_Mlink_u1 ) == nullvalueI ) then nodeI ( thisnode , ni_Mlink_u1 ) = ii elseif ( nodeI ( thisnode , ni_Mlink_u2 ) == nullvalueI ) then nodeI ( thisnode , ni_Mlink_u2 ) = ii else print * , 'node ' , thisnode print * , 'error: attempt to assign 3 upstream links to 1 node in ' , subroutine_name stop endif ! increment the upstream link counter nodeI ( thisnode , ni_N_link_u ) = nodeI ( thisnode , ni_N_link_u ) + 1 endif enddo print * print * , 'link info' print * , linkI (:, li_idx ), ' idx' print * , linkI (:, li_link_type ), ' type' print * , linkI (:, li_Mnode_u ) , ' upstream node' print * , linkI (:, li_Mnode_d ) , ' downstream node' print * , print * , 'node info' print * , nodeI (:, ni_idx ), ' idx' print * , nodeI (:, ni_node_type ), ' type' print * , nodeI (:, ni_N_link_d ), 'number of downstream links' print * , nodeI (:, ni_Mlink_d1 ), 'downstream1 link' !print *, nodeI(:,ni_Mlink_d2), 'downstream2 link' !print *, nodeI(:,ni_Mlink_d3), 'downstream2 link' print * , nodeI (:, ni_N_link_u ), 'number of upstream links' print * , nodeI (:, ni_Mlink_u1 ), 'upstream1 link' print * , nodeI (:, ni_Mlink_u2 ), 'upstream2 link' !print *, nodeI(:,ni_Mlink_u3), 'upstream2 link' !print *, nodeI(2,8) !stop if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine custom_3link_Y_network ! !========================================================================== !========================================================================== ! subroutine custom_6link_Y_network & ( linkR , nodeR , linkI , nodeI , linkName , nodeName ) character ( 64 ) :: subroutine_name = 'custom_6link_Y_network' integer , intent ( in out ) :: linkI (:,:) integer , intent ( in out ) :: nodeI (:,:) real , intent ( in out ) :: linkR (:,:) real , intent ( in out ) :: nodeR (:,:) type ( string ), dimension (:), intent ( in out ) :: linkName , nodeName integer :: ii integer :: thisnode !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name ! ERROR CHECK -------------------------- if ( N_link /= 6 ) then print * , 'error this network requires 6 links in ' , subroutine_name STOP endif if ( N_node /= 7 ) then print * , 'error this network requires 7 nodes in ' , subroutine_name STOP endif ! SET UP CONNECTIVITY AND PHYSICS ------------------ ! assign the indexes linkI (:, li_idx ) = ( / ( ii , ii = 1 , N_link ) / ) nodeI (:, ni_idx ) = ( / ( ii , ii = 1 , N_node ) / ) ! assign zeros for accumulators nodeI (:, ni_N_link_d ) = 0 nodeI (:, ni_N_link_u ) = 0 ! assign uniform physical data linkI (:, li_roughness_type ) = lManningsN ! assign no names for links do ii = 1 , N_link linkName ( ii )% str = \"\" end do !print *, linkI(:,li_idx) !print *, nodeI(:,ni_idx) ! designate the upstream nodes nodeI ( 1 , ni_node_type ) = nBCup nodeI ( 4 , ni_node_type ) = nBCup nodeR ( 1 , nr_Zbottom ) = 1 0.0 nodeR ( 4 , nr_Zbottom ) = 8.0 nodeName ( 1 )% str = 'UpstreamBC01' nodeName ( 4 )% str = 'UpstreamBC02' ! designated the 2-element junctions nodeI ( 2 , ni_node_type ) = nJ2 nodeI ( 5 , ni_node_type ) = nJ2 nodeI ( 6 , ni_node_type ) = nJ2 nodeR ( 2 , nr_Zbottom ) = 9.0 nodeR ( 5 , nr_Zbottom ) = 7.0 nodeR ( 6 , nr_Zbottom ) = 3.0 nodeName ( 2 )% str = 'inter01' nodeName ( 5 )% str = 'inter02' nodeName ( 6 )% str = 'inter03' ! designate the junction node for multiple links nodeI ( 3 , ni_node_type ) = nJm nodeR ( 3 , nr_Zbottom ) = 4.0 ! designate the downstream node nodeI ( 7 , ni_node_type ) = nBCdn nodeR ( 7 , nr_Zbottom ) = 1.5 nodeName ( 7 )% str = 'DownstreamBC' ! assign the link types linkI (:, li_link_type ) = lChannel ! assign all as rectangular channels linkI (:, li_geometry ) = lRectangular ! assign the link position and mappings ! link 1 - upstream Y branch 1a linkI ( 1 , li_Mnode_u ) = 1 ! map to upstream node linkI ( 1 , li_Mnode_d ) = 2 ! map to downstream node linkR ( 1 , lr_Length ) = 15 5.0 linkR ( 1 , lr_Breadth ) = 2.5 ! link 2 - upstream Y branch 1b linkI ( 2 , li_Mnode_u ) = 2 ! map to upstream node linkI ( 2 , li_Mnode_d ) = 3 ! map to downstream node (Y) linkR ( 2 , lr_Length ) = 24 7.0 linkR ( 2 , lr_Breadth ) = 3.2 ! link 3 - upstream Y branch 2a linkI ( 3 , li_Mnode_u ) = 4 ! map to upstream node linkI ( 3 , li_Mnode_d ) = 5 ! map to downstream node linkR ( 3 , lr_Length ) = 19 2.0 linkR ( 3 , lr_Breadth ) = 2.9 ! link 4 - upstream Y branch 2b linkI ( 4 , li_Mnode_u ) = 5 ! map to upstream node linkI ( 4 , li_Mnode_d ) = 3 ! map to downstream node linkR ( 4 , lr_Length ) = 23 9.0 linkR ( 4 , lr_Breadth ) = 3.7 ! link 5 - downstram branch linkI ( 5 , li_Mnode_u ) = 3 ! map to upstream node linkI ( 5 , li_Mnode_d ) = 6 ! map to downstream node linkR ( 5 , lr_Length ) = 32 3.0 linkR ( 5 , lr_Breadth ) = 4.1 linkI ( 6 , li_Mnode_u ) = 6 ! map to upstream node linkI ( 6 , li_Mnode_d ) = 7 ! map to downstream node linkR ( 6 , lr_Length ) = 38 9.0 linkR ( 6 , lr_Breadth ) = 4.6 ! cycle through links to assign nodes do ii = 1 , N_link ! get the upstream node of the link (if it exists) thisnode = linkI ( ii , li_Mnode_u ) ! look for next available downstream link position if ( thisnode > 0 ) then if ( nodeI ( thisnode , ni_Mlink_d1 ) == nullvalueI ) then nodeI ( thisnode , ni_Mlink_d1 ) = ii else print * , 'node ' , thisnode print * , 'error: attempt to assign 2 downstream links to 1 node in ' , subroutine_name stop endif ! increment the downstream link counter nodeI ( thisnode , ni_N_link_d ) = nodeI ( thisnode , ni_N_link_d ) + 1 endif ! get the downstream node of the link (if it exists) thisnode = linkI ( ii , li_Mnode_d ) ! look for the next available upstream link position if ( thisnode > 0 ) then if ( nodeI ( thisnode , ni_Mlink_u1 ) == nullvalueI ) then nodeI ( thisnode , ni_Mlink_u1 ) = ii elseif ( nodeI ( thisnode , ni_Mlink_u2 ) == nullvalueI ) then nodeI ( thisnode , ni_Mlink_u2 ) = ii else print * , 'node ' , thisnode print * , 'error: attempt to assign 3 upstream links to 1 node in ' , subroutine_name stop endif ! increment the upstream link counter nodeI ( thisnode , ni_N_link_u ) = nodeI ( thisnode , ni_N_link_u ) + 1 endif enddo print * print * , 'link info' print * , linkI (:, li_idx ), ' idx' print * , linkI (:, li_link_type ), ' type' print * , linkI (:, li_Mnode_u ) , ' upstream node' print * , linkI (:, li_Mnode_d ) , ' downstream node' print * , print * , 'node info' print * , nodeI (:, ni_idx ), ' idx' print * , nodeI (:, ni_node_type ), ' type' print * , nodeI (:, ni_N_link_d ), 'number of downstream links' print * , nodeI (:, ni_Mlink_d1 ), 'downstream1 link' !print *, nodeI(:,ni_Mlink_d2), 'downstream2 link' !print *, nodeI(:,ni_Mlink_d3), 'downstream2 link' print * , nodeI (:, ni_N_link_u ), 'number of upstream links' print * , nodeI (:, ni_Mlink_u1 ), 'upstream1 link' print * , nodeI (:, ni_Mlink_u2 ), 'upstream2 link' !print *, nodeI(:,ni_Mlink_u3), 'upstream2 link' !print *, nodeI(2,8) !stop if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine custom_6link_Y_network ! !========================================================================== !========================================================================== end module custom_network","title":"custom_networkOLD.f08 – SWMMengine","tags":"","loc":"sourcefile/custom_networkold.f08.html"},{"text":"This file depends on sourcefile~~face_values.f08~~EfferentGraph sourcefile~face_values.f08 face_values.f08 sourcefile~globals.f08 globals.f08 sourcefile~face_values.f08->sourcefile~globals.f08 sourcefile~utility.f08 utility.f08 sourcefile~face_values.f08->sourcefile~utility.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~face_values.f08->sourcefile~setting_definition.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~face_values.f08->sourcefile~array_index.f08 sourcefile~bc.f08 bc.f08 sourcefile~face_values.f08->sourcefile~bc.f08 sourcefile~adjustments.f08 adjustments.f08 sourcefile~face_values.f08->sourcefile~adjustments.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~face_values.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~adjustments.f08->sourcefile~globals.f08 sourcefile~adjustments.f08->sourcefile~utility.f08 sourcefile~adjustments.f08->sourcefile~setting_definition.f08 sourcefile~adjustments.f08->sourcefile~array_index.f08 sourcefile~adjustments.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 var pansourcefileface_valuesf08EfferentGraph = svgPanZoom('#sourcefileface_valuesf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~face_values.f08~~AfferentGraph sourcefile~face_values.f08 face_values.f08 sourcefile~initial_condition.f08 initial_condition.f08 sourcefile~initial_condition.f08->sourcefile~face_values.f08 sourcefile~runge_kutta.f08 runge_kutta.f08 sourcefile~runge_kutta.f08->sourcefile~face_values.f08 sourcefile~explicit_euler.f08 explicit_euler.f08 sourcefile~explicit_euler.f08->sourcefile~face_values.f08 sourcefile~time_loop.f08 time_loop.f08 sourcefile~time_loop.f08->sourcefile~face_values.f08 sourcefile~time_loop.f08->sourcefile~runge_kutta.f08 sourcefile~time_loop.f08->sourcefile~explicit_euler.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~initial_condition.f08 sourcefile~main.f08->sourcefile~time_loop.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules face_values Source Code face_values.f08 Source Code ! ! module face_values ! ! Interpolates values from adjacent elements to faces ! !========================================================================== ! module face_values ! ! compute values on faces from adjacent elements ! use adjustments use array_index use bc use data_keys use globals use setting_definition use utility implicit none private public :: face_update integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine face_update & ( elem2R , elem2I , elemMR , faceR , faceI , faceYN , & bcdataDn , bcdataUp , e2r_Velocity_new , eMr_Velocity_new , e2r_Volume_new , & eMr_Volume_new , thisTime , thisIter ) ! ! top-level computation of all face values from adjacent elements ! character ( 64 ) :: subroutine_name = 'face_update' integer , intent ( in out ) :: faceI (:,:) real , intent ( in out ) :: faceR (:,:) real , intent ( in out ) :: elem2R (:,:) real , intent ( in ) :: elemMR (:,:) integer , intent ( in ) :: elem2I (:,:) type ( bcType ), intent ( in out ) :: bcdataDn (:), bcdataUp (:) real , intent ( in ) :: thisTime integer , intent ( in ) :: e2r_Velocity_new , eMr_Velocity_new , thisIter integer , intent ( in ) :: e2r_Volume_new , eMr_Volume_new logical , intent ( in out ) :: faceYN (:,:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name call face_interp_for_elem2 & ( elem2R , faceR , faceI , faceYN , bcdataDn , bcdataUp , e2r_Volume_new ) call bc_applied_onface & ( faceR , faceI , elem2R , elem2I , bcdataDn , bcdataUp , e2r_Velocity_new , thisTime ) if ( N_elemM > 0 ) then call face_interp_for_upstreamchannel_to_downstreamjunction & ( elem2R , elemMR , faceR , faceI , faceYN , e2r_Volume_new , eMr_Volume_new ) call face_interp_for_downstreamchannel_to_upstreamjunction & ( elem2R , elemMR , faceR , faceI , faceYN , e2r_Volume_new , eMr_Volume_new ) endif call face_hydraulic_jump ( elem2R , elemMR , faceR , faceI , e2r_Velocity_new , eMr_Velocity_new ) call face_surface_elevation_interp ( elem2R , elemMR , faceR , faceI , faceYN ) !% compute depth faceR (:, fr_HydDepth_u ) = zeroR faceR (:, fr_HydDepth_d ) = zeroR where ( faceR (:, fr_Topwidth ) > zeroR ) faceR (:, fr_HydDepth_u ) = faceR (:, fr_Area_u ) / faceR (:, fr_Topwidth ) faceR (:, fr_HydDepth_d ) = faceR (:, fr_Area_d ) / faceR (:, fr_Topwidth ) endwhere if ( thisIter == 1 ) then !% at end of first step of RK2, the face flow rate is the BC outflow for the step call face_bc_flowrate_update ( bcdataDn , bcdataUp , faceR ) endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine face_update ! !========================================================================== ! PRIVATE BELOW HERE !========================================================================== ! subroutine face_bc_flowrate_update & ( bcdataDn , bcdataUp , faceR ) ! ! stores the last flowrate used on the boundary ! Required for correct diagnostics ! Overwritten by correct BC in next step ! character ( 64 ) :: subroutine_name = 'face_bc_flowrate_update' type ( bcType ), target , intent ( in out ) :: bcdataDn (:), bcdataUp (:) real , intent ( in ) :: faceR (:,:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name call face_bc_flowrate_update_onevalue ( bcdataDn , faceR ) call face_bc_flowrate_update_onevalue ( bcdataUp , faceR ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine face_bc_flowrate_update ! !========================================================================== !========================================================================== ! subroutine face_bc_flowrate_update_onevalue & ( bcdata , faceR ) character ( 64 ) :: subroutine_name = 'face_bc_flowrate_update_onevalue' type ( bcType ), target , intent ( in out ) :: bcdata (:) real , intent ( in ) :: faceR (:,:) integer , pointer :: fID integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do mm = 1 , size ( bcdata ) fID => bcdata ( mm )% FaceID bcdata ( mm )% ThisFlowrate = faceR ( fID , fr_Flowrate ) !print *,trim(subroutine_name),mm,bcdata(mm)%ThisFlowrate enddo if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine face_bc_flowrate_update_onevalue ! !========================================================================== !========================================================================== ! subroutine face_interp_for_elem2 & ( elem2R , faceR , faceI , faceYN , bcdataDn , bcdataUp , e2r_Volume_new ) ! ! face interpolation between elements that have only 2 faces ! character ( 64 ) :: subroutine_name = 'face_interp_for_elem2' integer , intent ( in ) :: faceI (:,:) real , target , intent ( in out ) :: faceR (:,:) real , target , intent ( in ) :: elem2R (:,:) logical , target , intent ( in out ) :: faceYN (:,:) type ( bcType ), intent ( in ) :: bcdataDn (:), bcdataUp (:) integer , intent ( in ) :: e2r_Volume_new logical , pointer :: facemask (:) real , pointer :: valueUp (:), valueDn (:), weightUp (:), weightDn (:) real , pointer :: inoutarray (:) integer :: mm integer , dimension ( 3 ) :: e2rset , frset !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name valueUp => faceR (:, fr_Temp ( next_fr_temparray )) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) valueDn => faceR (:, fr_Temp ( next_fr_temparray )) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) weightUp => faceR (:, fr_Temp ( next_fr_temparray )) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) weightDn => faceR (:, fr_Temp ( next_fr_temparray )) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) facemask => faceYN (:, fYN_Temp ( next_fYN_temparray )) next_fYN_temparray = utility_advance_temp_array ( next_fYN_temparray , fYN_n_temp ) facemask = ( ( faceI (:, fi_etype_u ) == eChannel ) . and . & ( faceI (:, fi_etype_d ) == eChannel ) ) !%  use timescale for interpolation for Topwidth, Area, Flowrate weightUp = setting % Limiter % Timescale % Maximum weightDn = setting % Limiter % Timescale % Maximum where ( facemask ) weightUp = elem2R ( faceI (:, fi_Melem_u ), e2r_Timescale_d ) !tscale acting downstream from upstream element weightDn = elem2R ( faceI (:, fi_Melem_d ), e2r_Timescale_u ) !tscale acting upstream from downstream element endwhere !%  set of face interpolations that use timescale weighting frset = ( / fr_Topwidth , fr_Area_d , fr_Flowrate / ) e2rset = ( / e2r_Topwidth , e2r_Area , e2r_Flowrate / ) do mm = 1 , size ( frset ) call interp_channel_onetype & ( faceR , facemask , faceI , elem2R , & weightUp , weightDn , valueUp , valueDn , e2rset ( mm ), frset ( mm )) end do !%  store the duplicate areas (later adjusted for jumps) where ( facemask ) faceR (:, fr_Area_u ) = faceR (:, fr_Area_d ) endwhere !%  store simple extrapolation of the face - adjusted during jump procedure where ( facemask ) faceR (:, fr_Eta_u ) = elem2R ( faceI (:, fi_Melem_u ), e2r_Eta ) faceR (:, fr_Eta_d ) = elem2R ( faceI (:, fi_Melem_d ), e2r_Eta ) endwhere !%  set velocities and upstream values on faces (without hydraulic jump) call adjust_face_dynamic_limits & ( faceR , faceI , elem2R (:, e2r_Volume_new ), elem2R (:, e2r_Volume_new ), facemask , . false .) !%  Store identical values for fr_XXX_u for the moment !%  These are later adjusted for hydraulic jumps where ( facemask ) faceR (:, fr_Area_u ) = faceR (:, fr_Area_d ) faceR (:, fr_Velocity_u ) = faceR (:, fr_Velocity_d ) endwhere facemask = nullvalueL nullify ( facemask ) next_fYN_temparray = next_fYN_temparray - 1 valueUp = nullvalueR valueDn = nullvalueR weightUp = nullvalueR weightDn = nullvalueR nullify ( valueUp , valueDn , weightUp , weightDn ) next_fr_temparray = next_fr_temparray - 4 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine face_interp_for_elem2 ! !========================================================================== !========================================================================== ! subroutine face_interp_for_upstreamchannel_to_downstreamjunction & ( elem2R , elemMR , faceR , faceI , faceYN , e2r_Volume_new , eMr_Volume_new ) ! ! face interpolation with a junction downstream and channel upstream ! i.e. this is from an upstream junction branch to the channel ! character ( 64 ) :: subroutine_name = 'face_interp_for_upstreamchannel_to_downstreamjunction' integer , intent ( in ) :: faceI (:,:) real , target , intent ( in out ) :: faceR (:,:) real , target , intent ( in ) :: elem2R (:,:), elemMR (:,:) logical , target , intent ( in out ) :: faceYN (:,:) integer , intent ( in ) :: e2r_Volume_new , eMr_Volume_new logical , pointer :: facemask (:) real , pointer :: valueUp (:), valueDn (:), weightUp (:), weightDn (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name valueUp => faceR (:, fr_Temp ( next_fr_temparray )) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) valueDn => faceR (:, fr_Temp ( next_fr_temparray )) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) weightUp => faceR (:, fr_Temp ( next_fr_temparray )) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) weightDn => faceR (:, fr_Temp ( next_fr_temparray )) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) facemask => faceYN (:, fYN_Temp ( next_fYN_temparray )) next_fYN_temparray = utility_advance_temp_array ( next_fYN_temparray , fYN_n_temp ) facemask = ( ( faceI (:, fi_etype_u ) == eChannel ) . and . & ( faceI (:, fi_etype_d ) == eJunctionChannel ) ) where ( facemask ) weightUp = elem2R ( faceI (:, fi_Melem_u ), e2r_Timescale_d ) !tscale acting downstream endwhere do mm = 1 , upstream_face_per_elemM !    print *, trim(subroutine_name) !    print *, mm !    print *, facemask !    print *, faceI(:,fi_branch_d) !    print *, faceI(:,fi_Melem_d) !    print * ! where ( ( facemask ) . and . ( faceI (:, fi_branch_d ) == mm ) ) weightDn = elemMR ( faceI (:, fi_Melem_d ), eMr_TimescaleUp ( mm )) !tscale acting upstream endwhere end do !print *, trim(subroutine_name) !stop !%  use timescale for interpolation for Topwidth, Area, Flowrate call interp_with_junction_downstream & ( faceR , facemask , faceI , elem2R , elemMR , & weightUp , weightDn , valueUp , valueDn , & e2r_Topwidth , eMr_TopwidthUp , fr_Topwidth ) call interp_with_junction_downstream & ( faceR , facemask , faceI , elem2R , elemMR , & weightUp , weightDn , valueUp , valueDn , & e2r_Area , eMr_AreaUp , fr_Area_d ) call interp_with_junction_downstream & ( faceR , facemask , faceI , elem2R , elemMR , & weightUp , weightDn , valueUp , valueDn , & e2r_Flowrate , eMr_FlowrateUp , fr_Flowrate ) !%  store identical areas (adjusted elsewhere for hyd jump) where ( facemask ) faceR (:, fr_Area_u ) = faceR (:, fr_Area_d ) endwhere !%  Store the extraploated upstream and downstream free surface values !%  Adjusted elsewhere with hydraulic jump where ( facemask ) faceR (:, fr_Eta_d ) = elemMR ( faceI (:, fi_Melem_d ), eMr_Eta ) faceR (:, fr_Eta_u ) = elem2R ( faceI (:, fi_Melem_u ), e2r_Eta ) endwhere ! set velocities and upstream values on faces (without hydraulic jump) call adjust_face_dynamic_limits & ( faceR , faceI , elem2R (:, e2r_Volume_new ), elemMR (:, eMr_Volume_new ), facemask , . true .) facemask = nullvalueL nullify ( facemask ) next_fYN_temparray = next_fYN_temparray - 1 valueUp = nullvalueR valueDn = nullvalueR weightUp = nullvalueR weightDn = nullvalueR nullify ( valueUp , valueDn , weightUp , weightDn ) next_fr_temparray = next_fr_temparray - 4 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine face_interp_for_upstreamchannel_to_downstreamjunction ! !========================================================================== !========================================================================== ! subroutine face_interp_for_downstreamchannel_to_upstreamjunction & ( elem2R , elemMR , faceR , faceI , faceYN , e2r_Volume_new , eMr_Volume_new ) ! ! face interpolation with a junction upstream and channel downstream ! i.e. this is from a downstream junction branch to the downstream channel ! character ( 64 ) :: subroutine_name = 'face_interp_for_downstreamchannel_to_upstreamjunction' integer , intent ( in ) :: faceI (:,:) real , target , intent ( in out ) :: faceR (:,:) real , target , intent ( in ) :: elem2R (:,:), elemMR (:,:) logical , target , intent ( in out ) :: faceYN (:,:) integer , intent ( in ) :: e2r_Volume_new , eMr_Volume_new logical , pointer :: facemask (:) real , pointer :: valueUp (:), valueDn (:), weightUp (:), weightDn (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name valueUp => faceR (:, fr_Temp ( next_fr_temparray )) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) valueDn => faceR (:, fr_Temp ( next_fr_temparray )) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) weightUp => faceR (:, fr_Temp ( next_fr_temparray )) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) weightDn => faceR (:, fr_Temp ( next_fr_temparray )) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) facemask => faceYN (:, fYN_Temp ( next_fYN_temparray )) next_fYN_temparray = utility_advance_temp_array ( next_fYN_temparray , fYN_n_temp ) facemask = ( ( faceI (:, fi_etype_d ) == eChannel ) . and . & ( faceI (:, fi_etype_u ) == eJunctionChannel ) ) where ( facemask ) weightDn = elem2R ( faceI (:, fi_Melem_d ), e2r_Timescale_u ) !tscale acting upstream endwhere do mm = 1 , dnstream_face_per_elemM where ( ( facemask ) . and . ( faceI (:, fi_branch_u ) == mm ) ) weightUp = elemMR ( faceI (:, fi_Melem_u ), eMr_TimescaleDn ( mm )) !tscale acting dnstream endwhere end do !%  use timescale for interpolation for Topwidth, Area, Flowrate call interp_with_junction_upstream & ( faceR , facemask , faceI , elem2R , elemMR , & weightUp , weightDn , valueUp , valueDn , & e2r_Topwidth , eMr_TopwidthDn , fr_Topwidth ) call interp_with_junction_upstream & ( faceR , facemask , faceI , elem2R , elemMR , & weightUp , weightDn , valueUp , valueDn , & e2r_Area , eMr_AreaDn , fr_Area_d ) call interp_with_junction_upstream & ( faceR , facemask , faceI , elem2R , elemMR , & weightUp , weightDn , valueUp , valueDn , & e2r_Flowrate , eMr_FlowrateDn , fr_Flowrate ) !%  store identical areas (adjusted elsewhere for hyd jump) where ( facemask ) faceR (:, fr_Area_u ) = faceR (:, fr_Area_d ) endwhere !%  Store the extraploated upstream and downstream free surface values !%  Adjusted elsewhere with hydraulic jump where ( facemask ) faceR (:, fr_Eta_d ) = elem2R ( faceI (:, fi_Melem_d ), e2r_Eta ) faceR (:, fr_Eta_u ) = elemMR ( faceI (:, fi_Melem_u ), eMr_Eta ) endwhere !%  set velocities and upstream values on faces (without hydraulic jump) call adjust_face_dynamic_limits & ( faceR , faceI , elemMR (:, eMr_Volume_new ), elem2R (:, e2r_Volume_new ), facemask , . false .) facemask = nullvalueL nullify ( facemask ) next_fYN_temparray = next_fYN_temparray - 1 valueUp = nullvalueR valueDn = nullvalueR weightUp = nullvalueR weightDn = nullvalueR nullify ( valueUp , valueDn , weightUp , weightDn ) next_fr_temparray = next_fr_temparray - 4 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine face_interp_for_downstreamchannel_to_upstreamjunction ! !========================================================================== !========================================================================== ! subroutine face_hydraulic_jump & ( elem2R , elemMR , faceR , faceI , e2r_Velocity_new , eMr_Velocity_new ) ! ! handles effects of hydraulic jump ! character ( 64 ) :: subroutine_name = 'face_hydraulic_jump' real , target , intent ( in out ) :: faceR (:,:) real , intent ( in ) :: elem2R (:,:), elemMR (:,:) integer , target , intent ( in out ) :: faceI (:,:) integer , intent ( in ) :: e2r_Velocity_new , eMr_Velocity_new integer , pointer :: mapUp (:), mapDn (:), typUp (:), typDn (:), jumptype (:) real , pointer :: froudeUp (:), froudeDn (:), etaUp (:), etaDn (:) real , pointer :: areaUp (:), areaDn (:), velUp (:), velDn (:), flowrate (:) integer :: fr_froudeUp , fr_froudeDn real :: feps !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name fr_froudeUp = fr_Temp ( next_fr_temparray ) froudeUp => faceR (:, fr_froudeUp ) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) fr_froudeDn = fr_Temp ( next_fr_temparray ) froudeDn => faceR (:, fr_froudeDn ) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) feps = setting % Eps % FroudeJump mapUp => faceI (:, fi_Melem_u ) mapDn => faceI (:, fi_Melem_d ) typUp => faceI (:, fi_etype_u ) typDn => faceI (:, fi_etype_d ) etaUp => faceR (:, fr_Eta_u ) etaDn => faceR (:, fr_Eta_d ) areaUp => faceR (:, fr_Area_u ) areaDn => faceR (:, fr_Area_d ) velUp => faceR (:, fr_Velocity_u ) velDn => faceR (:, fr_Velocity_d ) flowrate => faceR (:, fr_Flowrate ) jumptype => faceI (:, fi_jump_type ) !%  compute the upstream and downstream froude number on each face !%  note the froude numbers are signed with + being downstream flow. where ( typUp == fChannel ) froudeUp = elem2R ( mapUp , e2r_Velocity_new ) / ( sqrt ( grav * elem2R ( mapUp , e2r_HydDepth ))) endwhere where ( typDn == fChannel ) froudeDn = elem2R ( mapDn , e2r_Velocity_new ) / ( sqrt ( grav * elem2R ( mapDn , e2r_HydDepth ))) endwhere !%  HACK - does not consider individual branches - only entire element values where ( typUp == fMultiple ) froudeUp = elemMR ( mapUp , eMr_Velocity_new ) / ( sqrt ( grav * elemMR ( mapUp , eMr_HydDepth ))) endwhere where ( typDn == fMultiple ) froudeDn = elemMR ( mapDn , eMr_Velocity_new ) / ( sqrt ( grav * elemMR ( mapDn , eMr_HydDepth ))) endwhere !%  Define whether the jump is upstream or downstream or none !%  Note the mask for water surface level is required because with a coarse !%  grid (relative to jump scales) on a steep slope it is possible to have !%  an eta transition that is not a step in the correct direction. In such !%  a case it is better to just use the time weighting approach (which give !%  priority to the upstream side. where ( ( froudeDn < oneR - feps ) . and . ( froudeUp > oneR + feps ) . and . & ( etaUp < etaDn ) ) jumptype = jump_downstream endwhere where ( ( froudeDn < - oneR - feps ) . and . ( froudeUp > - oneR + feps ) . and . & ( etaDn < etaUp ) ) jumptype = jump_upstream endwhere where (( jumptype /= jump_upstream ) . and . ( jumptype /= jump_downstream )) jumptype = jump_none endwhere !%  Assign areas on either side of jump by extrapolation !%  Note that this depends on the fr_Eta_u and fr_Eta_d being initially !%  assigned by extrapolation where ( ( jumptype /= jump_none ) . and . ( typUp == fChannel ) ) areaUp = elem2R ( mapUp , e2r_Area ) endwhere where ( ( jumptype /= jump_none ) . and . ( typDn == fChannel ) ) areaDn = elem2R ( mapDn , e2r_Area ) endwhere where ( ( jumptype /= jump_none ) . and . ( typUp == fMultiple ) ) areaUp = elemMR ( mapUp , eMr_Area ) endwhere where ( ( jumptype /= jump_none ) . and . ( typDn == fMultiple ) ) areaDn = elemMR ( mapDn , eMr_Area ) endwhere !%  assign velocities on either side of jump where ( jumptype /= jump_none ) velUp = flowrate / areaUp velDn = flowrate / areaDn endwhere !%  for no jumps, use a linear length interpolation for free surface (elsewhere) froudeUp = nullvalueR froudeDn = nullvalueR nullify ( froudeUp , froudeDn ) next_fr_temparray = next_fr_temparray - 2 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine face_hydraulic_jump ! !========================================================================== !========================================================================== ! subroutine face_surface_elevation_interp & ( elem2R , elemMR , faceR , faceI , faceYN ) character ( 64 ) :: subroutine_name = 'face_surface_elevation_interp' real , target , intent ( in out ) :: faceR (:,:) real , intent ( in ) :: elem2R (:,:), elemMR (:,:) integer , intent ( in ) :: faceI (:,:) logical , target , intent ( in out ) :: faceYN (:,:) real , pointer :: weightUp (:), weightDn (:), etaUp (:), etaDn (:) logical , pointer :: facemask (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !%  temporary storage weightUp => faceR (:, fr_Temp ( next_fr_temparray )) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) weightDn => faceR (:, fr_Temp ( next_fr_temparray )) next_fr_temparray = utility_advance_temp_array ( next_fr_temparray , fr_n_temp ) facemask => faceYN (:, fYN_Temp ( next_fYN_temparray )) next_fYN_temparray = utility_advance_temp_array ( next_fYN_temparray , fYN_n_temp ) etaUp => faceR (:, fr_Eta_u ) etaDn => faceR (:, fr_Eta_d ) !%  use distance (length) for interpolation for free surface where ( faceI (:, fi_etype_d ) == fChannel ) weightDn = onehalfR * elem2R ( faceI (:, fi_Melem_d ), e2r_Length ) endwhere where ( faceI (:, fi_etype_u ) == fChannel ) weightUp = onehalfR * elem2R ( faceI (:, fi_Melem_u ), e2r_Length ) endwhere !%  interpolate across branches of junction elements if ( N_elemM > 0 ) then do mm = 1 , upstream_face_per_elemM where ( ( faceI (:, fi_etype_d ) == fMultiple ) . and . ( faceI (:, fi_branch_d ) == mm ) ) weightDn = elemMR ( faceI (:, fi_Melem_d ), eMr_LengthUp ( mm )) !length of upstream branch endwhere end do do mm = 1 , dnstream_face_per_elemM where ( ( faceI (:, fi_etype_u ) == fMultiple ) . and . ( faceI (:, fi_branch_u ) == mm ) ) weightUp = elemMR ( faceI (:, fi_Melem_u ), eMr_LengthDn ( mm )) !length of dnstream branch endwhere end do endif !%  set the mask for channel and mulitple elements without a hyd jump facemask = ( (( faceI (:, fi_etype_d ) == fChannel ) . or . ( faceI (:, fi_etype_d ) == fMultiple )) & & . and . & (( faceI (:, fi_etype_u ) == fChannel ) . or . ( faceI (:, fi_etype_u ) == fMultiple )) & & . and . & ( faceI (:, fi_jump_type ) == jump_none ) ) where ( facemask ) etaDn = ( weightUp * etaDn + weightDn * etaUp ) / ( weightUp + weightDn ) endwhere etaUp = etaDn weightUp = nullvalueR weightDn = nullvalueR facemask = nullvalueL nullify ( weightUp , weightDn , facemask ) next_fr_temparray = next_fr_temparray - 2 next_fYN_temparray = next_fYN_temparray - 1 if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine face_surface_elevation_interp ! !========================================================================== !========================================================================== ! subroutine interp_channel_onetype & ( faceR , facemask , faceI , elem2R , & weightUp , weightDn , valueUp , valueDn , e2r_ThisType , fr_ThisType ) ! ! preforms weighted face interpolation for one type of channel ! character ( 64 ) :: subroutine_name = 'interp_channel_onetype' real , target , intent ( in out ) :: faceR (:,:) real , intent ( in out ) :: valueUp (:), valueDn (:) real , intent ( in ) :: weightUp (:), weightDn (:) real , intent ( in ) :: elem2R (:,:) integer , intent ( in ) :: faceI (:,:) integer , intent ( in ) :: e2r_ThisType , fr_ThisType logical , intent ( in ) :: facemask (:) real , pointer :: inoutarray (:) !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name where ( facemask ) valueUp = elem2R ( faceI (:, fi_Melem_u ), e2r_ThisType ) valueDn = elem2R ( faceI (:, fi_Melem_d ), e2r_ThisType ) endwhere inoutarray => faceR (:, fr_ThisType ) call linear_interpolation & ( inoutarray , facemask , weightUp , weightDn , valueUp , valueDn ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine interp_channel_onetype ! !========================================================================== !========================================================================== ! subroutine interp_with_junction_downstream & ( faceR , facemask , faceI , elem2R , elemMR , & weightUp , weightDn , valueUp , valueDn , & e2r_ThisValue , eMr_ThisValueUp , fr_ThisValue ) ! ! interp one value to a face when there is a junction downstream and channel upstream ! Uses branch values in elemMR array. ! character ( 64 ) :: subroutine_name = 'interp_with_junction_downstream' real , target , intent ( in out ) :: faceR (:,:) real , intent ( in out ) :: valueUp (:), valueDn (:) real , intent ( in ) :: weightUp (:), weightDn (:) real , intent ( in ) :: elem2R (:,:), elemMR (:,:) integer , intent ( in ) :: faceI (:,:) integer , intent ( in ) :: e2r_ThisValue , fr_ThisValue integer , intent ( in ) :: eMr_ThisValueUp (:) logical , intent ( in ) :: facemask (:) real , pointer :: inoutarray (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name where ( facemask ) valueUp = elem2R ( faceI (:, fi_Melem_u ), e2r_ThisValue ) endwhere do mm = 1 , upstream_face_per_elemM where ( ( facemask ) . and . ( faceI (:, fi_branch_d ) == mm ) ) valueDn = elemMR ( faceI (:, fi_Melem_d ), eMr_ThisValueUp ( mm )) endwhere end do inoutarray => faceR (:, fr_ThisValue ) call linear_interpolation & ( inoutarray , facemask , weightUp , weightDn , valueUp , valueDn ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine interp_with_junction_downstream ! !========================================================================== !========================================================================== ! subroutine interp_with_junction_upstream & ( faceR , facemask , faceI , elem2R , elemMR , & weightUp , weightDn , valueUp , valueDn , & e2r_ThisValue , eMr_ThisValueDn , fr_ThisValue ) ! ! interp to a face when there is a junction upstream and channel downstream ! Uses branch values in elemMR array. ! character ( 64 ) :: subroutine_name = 'interp_with_junction_upstream' real , target , intent ( in out ) :: faceR (:,:) real , intent ( in out ) :: valueUp (:), valueDn (:) real , intent ( in ) :: weightUp (:), weightDn (:) real , intent ( in ) :: elem2R (:,:), elemMR (:,:) integer , intent ( in ) :: faceI (:,:) integer , intent ( in ) :: e2r_ThisValue , fr_ThisValue integer , intent ( in ) :: eMr_ThisValueDn (:) logical , intent ( in ) :: facemask (:) real , pointer :: inoutarray (:) integer :: mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name where ( facemask ) valueDn = elem2R ( faceI (:, fi_Melem_d ), e2r_ThisValue ) endwhere do mm = 1 , dnstream_face_per_elemM where ( ( facemask ) . and . ( faceI (:, fi_branch_u ) == mm ) ) valueUp = elemMR ( faceI (:, fi_Melem_u ), eMr_ThisValueDn ( mm )) endwhere end do inoutarray => faceR (:, fr_ThisValue ) call linear_interpolation & ( inoutarray , facemask , weightUp , weightDn , valueUp , valueDn ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine interp_with_junction_upstream ! !========================================================================== !========================================================================== ! pure subroutine linear_interpolation & ( inoutarray , facemask , & upstreamWeight , downstreamWeight , upstreamValue , downstreamValue ) ! ! linear weighting for interpolation where the upstreamWeight is applied to the ! downstream value - e.g., if length is the weighting, then the upstream value ! being further away gives a larger emphasis to the downstream value ! real , intent ( in out ) :: inoutarray (:) logical , intent ( in ) :: facemask (:) real , intent ( in ) :: upstreamWeight (:), downstreamWeight (:) real , intent ( in ) :: upstreamValue (:), downstreamValue (:) !-------------------------------------------------------------------------- ! where ( facemask ) inoutarray = ( upstreamWeight * downstreamValue & + downstreamWeight * upstreamValue ) & / ( upstreamWeight + downstreamWeight ) endwhere end subroutine linear_interpolation ! !========================================================================== ! END OF MODULE face_values !========================================================================== end module face_values","title":"face_values.f08 – SWMMengine","tags":"","loc":"sourcefile/face_values.f08.html"},{"text":"This file depends on sourcefile~~initial_condition.f08~~EfferentGraph sourcefile~initial_condition.f08 initial_condition.f08 sourcefile~globals.f08 globals.f08 sourcefile~initial_condition.f08->sourcefile~globals.f08 sourcefile~element_geometry.f08 element_geometry.f08 sourcefile~initial_condition.f08->sourcefile~element_geometry.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~initial_condition.f08->sourcefile~setting_definition.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~initial_condition.f08->sourcefile~array_index.f08 sourcefile~element_dynamics.f08 element_dynamics.f08 sourcefile~initial_condition.f08->sourcefile~element_dynamics.f08 sourcefile~face_values.f08 face_values.f08 sourcefile~initial_condition.f08->sourcefile~face_values.f08 sourcefile~junction.f08 junction.f08 sourcefile~initial_condition.f08->sourcefile~junction.f08 sourcefile~bc.f08 bc.f08 sourcefile~initial_condition.f08->sourcefile~bc.f08 sourcefile~utility.f08 utility.f08 sourcefile~initial_condition.f08->sourcefile~utility.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~initial_condition.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~element_geometry.f08->sourcefile~globals.f08 sourcefile~element_geometry.f08->sourcefile~setting_definition.f08 sourcefile~element_geometry.f08->sourcefile~array_index.f08 sourcefile~element_geometry.f08->sourcefile~junction.f08 sourcefile~element_geometry.f08->sourcefile~bc.f08 sourcefile~element_geometry.f08->sourcefile~utility.f08 sourcefile~element_geometry.f08->sourcefile~data_keys.f08 sourcefile~adjustments.f08 adjustments.f08 sourcefile~element_geometry.f08->sourcefile~adjustments.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~element_dynamics.f08->sourcefile~globals.f08 sourcefile~element_dynamics.f08->sourcefile~setting_definition.f08 sourcefile~element_dynamics.f08->sourcefile~array_index.f08 sourcefile~element_dynamics.f08->sourcefile~junction.f08 sourcefile~element_dynamics.f08->sourcefile~bc.f08 sourcefile~element_dynamics.f08->sourcefile~utility.f08 sourcefile~element_dynamics.f08->sourcefile~data_keys.f08 sourcefile~element_dynamics.f08->sourcefile~adjustments.f08 sourcefile~face_values.f08->sourcefile~globals.f08 sourcefile~face_values.f08->sourcefile~setting_definition.f08 sourcefile~face_values.f08->sourcefile~array_index.f08 sourcefile~face_values.f08->sourcefile~bc.f08 sourcefile~face_values.f08->sourcefile~utility.f08 sourcefile~face_values.f08->sourcefile~data_keys.f08 sourcefile~face_values.f08->sourcefile~adjustments.f08 sourcefile~junction.f08->sourcefile~globals.f08 sourcefile~junction.f08->sourcefile~setting_definition.f08 sourcefile~junction.f08->sourcefile~array_index.f08 sourcefile~junction.f08->sourcefile~utility.f08 sourcefile~junction.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~adjustments.f08->sourcefile~globals.f08 sourcefile~adjustments.f08->sourcefile~setting_definition.f08 sourcefile~adjustments.f08->sourcefile~array_index.f08 sourcefile~adjustments.f08->sourcefile~utility.f08 sourcefile~adjustments.f08->sourcefile~data_keys.f08 var pansourcefileinitial_conditionf08EfferentGraph = svgPanZoom('#sourcefileinitial_conditionf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~initial_condition.f08~~AfferentGraph sourcefile~initial_condition.f08 initial_condition.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~initial_condition.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules initial_condition Source Code initial_condition.f08 Source Code ! ! module initial_condition ! ! Provides setup of initial conditions for geometry and dynamics ! !========================================================================== ! module initial_condition ! ! initial conditions on the elements and faces ! use array_index use bc use data_keys use element_geometry use element_dynamics use face_values use globals use junction use setting_definition use utility implicit none private public :: initial_condition_setup integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine initial_condition_setup & ( elem2R , elem2I , elem2YN , elemMR , elemMI , elemMYN , faceR , faceI , faceYN , & linkR , linkI , nodeR , nodeI , bcdataDn , bcdataUp , thisTime ) character ( 64 ) :: subroutine_name = 'initial_condition_setup' real , intent ( in out ) :: elem2R (:,:), elemMR (:,:), faceR (:,:) integer , intent ( in out ) :: elem2I (:,:), elemMI (:,:), faceI (:,:) logical , intent ( in out ) :: elem2YN (:,:), elemMYN (:,:), faceYN (:,:) real , intent ( in ) :: linkR (:,:), nodeR (:,:) integer , target , intent ( in ) :: linkI (:,:), nodeI (:,:) real , intent ( in ) :: thisTime type ( bcType ), intent ( in out ) :: bcdataDn (:), bcdataUp (:) integer :: idx !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name !% get data that can be extracted from links call initial_conditions_from_linkdata & ( elem2R , elem2I , elemMR , elemMI , linkR , linkI ) call initial_junction_conditions & ( faceR , faceI , elem2R , elem2I , elemMR , elemMI , nodeR , nodeI ) !% set the bc elements (outside of face) to null values call bc_nullify_ghost_elem ( elem2R , bcdataDn ) call bc_nullify_ghost_elem ( elem2R , bcdataUp ) !% update the geometry call element_geometry_update & ( elem2R , elem2I , elem2YN , e2r_Volume , & elemMR , elemMI , elemMYN , eMr_Volume , & faceR , faceI , bcdataDn , bcdataUp , thisTime , 0 ) call element_dynamics_update & ( elem2R , elemMR , faceR , elem2I , elemMI , elem2YN , elemMYN , & bcdataDn , bcdataUp , e2r_Velocity , eMr_Velocity , & e2r_Volume , eMr_Volume , thisTime ) call face_update & ( elem2R , elem2I , elemMR , faceR , faceI , faceYN , & bcdataDn , bcdataUp , e2r_Velocity , eMr_Velocity , & e2r_Volume , eMr_Volume , thisTime , 0 ) !% set the element-specific smallvolume value !% HACK - THIS IS ONLY FOR RECTANGULAR ELEMENTS if ( setting % SmallVolume % UseSmallVolumes ) then elem2R (:, e2r_SmallVolume ) = setting % SmallVolume % DepthCutoff * elem2R (:, e2r_BreadthScale ) * elem2R (:, e2r_Length ) elemMR (:, eMr_SmallVolume ) = setting % SmallVolume % DepthCutoff * elemMR (:, eMr_BreadthScale ) * elemMR (:, eMr_Length ) else elem2R (:, e2r_SmallVolume ) = zeroR elemMR (:, eMr_SmallVolume ) = zeroR endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine initial_condition_setup ! !========================================================================== ! PRIVATE BELOW HERE !========================================================================== ! subroutine initial_conditions_from_linkdata & ( elem2R , elem2I , elemMR , elemMI , linkR , linkI ) ! ! The link data structure can store a variety of geometric data. ! This will be expanded in the future ! character ( 64 ) :: subroutine_name = 'initial_conditions_from_linkdata' real , intent ( in out ) :: elem2R (:,:), elemMR (:,:) integer , intent ( in out ) :: elem2I (:,:), elemMI (:,:) real , target , intent ( in ) :: linkR (:,:) integer , target , intent ( in ) :: linkI (:,:) real :: kappa real , pointer :: dup , ddn integer , pointer :: Lindx , LdepthType integer :: ii , ei_max , mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name do ii = 1 , N_link Lindx => linkI ( ii , li_idx ) LdepthType => linkI ( ii , li_InitialDepthType ) !% up and downstream depths on this link dup => linkR ( ii , lr_InitialUpstreamDepth ) ddn => linkR ( ii , lr_InitialDnstreamDepth ) select case ( LdepthType ) case ( 1 ) !%  Initial depth -------------------------------------------------- if ( linkR ( ii , lr_InitialDepth ) /= nullvalueR ) then !%  if the link has a uniform depth as an initial condition where ( elem2I (:, e2i_link_ID ) == Lindx ) elem2R (:, e2r_HydDepth ) = linkR ( ii , lr_InitialDepth ) endwhere else where ( elem2I (:, e2i_link_ID ) == Lindx ) elem2R (:, e2r_HydDepth ) = 0.5 * ( dup + ddn ) endwhere endif case ( 2 ) !% if the link has linearly-varying depth !% depth at the downstream element (link position =1) where ( ( elem2I (:, e2i_link_Pos ) == 1 ) . and . ( elem2I (:, e2i_link_ID ) == Lindx ) ) elem2R (:, e2r_HydDepth ) = ddn endwhere !%  using a linear distribution over the links ei_max = maxval ( elem2I (:, e2i_link_Pos ), 1 , elem2I (:, e2i_link_ID ) == Lindx ) do mm = 2 , ei_max !% find the element that is at the mm position in the link where ( ( elem2I (:, e2i_link_Pos ) == mm ) . and . ( elem2I (:, e2i_link_ID ) == Lindx ) ) ! use a linear interp elem2R (:, e2r_HydDepth ) = ddn + ( dup - ddn ) * real ( mm - 1 ) / real ( ei_max - 1 ) endwhere end do case ( 3 ) ! HACK - this needs work to make the exponent driven by dup and ddn ! to ensure decay to dup over length !% exponential decay !% if the link has linearly-varying depth !% depth at the downstream element (link position =1) where ( ( elem2I (:, e2i_link_Pos ) == 1 ) . and . ( elem2I (:, e2i_link_ID ) == Lindx ) ) elem2R (:, e2r_HydDepth ) = ddn endwhere !%  using a linear distribution over the links ei_max = maxval ( elem2I (:, e2i_link_Pos ), 1 , elem2I (:, e2i_link_ID ) == Lindx ) do mm = 2 , ei_max kappa = real ( ei_max - 1 ) !% find the element that is at the mm position in the link if ( ddn - dup > zeroR ) then !%  depth decreases exponentially going upstream where ( ( elem2I (:, e2i_link_Pos ) == mm ) . and . & ( elem2I (:, e2i_link_ID ) == Lindx ) ) elem2R (:, e2r_HydDepth ) = ( ddn - dup ) * exp ( - real ( mm - 1 )) + dup endwhere elseif ( ddn - dup < zeroR ) then !%  depth increases exponentially going upstream where ( ( elem2I (:, e2i_link_Pos ) == mm ) . and . & ( elem2I (:, e2i_link_ID ) == Lindx ) ) elem2R (:, e2r_HydDepth ) = dup - ( dup - ddn ) * exp ( - real ( mm - 1 )) endwhere else !%  uniform depth where ( ( elem2I (:, e2i_link_Pos ) == mm ) . and . & ( elem2I (:, e2i_link_ID ) == Lindx ) ) ! use a linear interp elem2R (:, e2r_HydDepth ) = ddn endwhere endif end do end select !%  handle all the initial conditions that don't depend on geometry type !% where ( elem2I (:, e2i_link_ID ) == Lindx ) elem2I (:, e2i_roughness_type ) = linkI ( ii , li_roughness_type ) elem2R (:, e2r_Roughness ) = linkR ( ii , lr_Roughness ) elem2R (:, e2r_BreadthScale ) = linkR ( ii , lr_BreadthScale ) elem2R (:, e2r_Eta ) = elem2R (:, e2r_Zbottom ) + elem2R (:, e2r_HydDepth ) elem2R (:, e2r_Flowrate ) = linkR ( ii , lr_InitialFlowrate ) endwhere if ( linkI ( ii , li_geometry ) == lRectangular ) then !% handle rectangular elements where ( elem2I (:, e2i_link_ID ) == Lindx ) elem2I (:, e2i_geometry ) = eRectangular elem2R (:, e2r_Topwidth ) = linkR ( ii , lr_BreadthScale ) elem2R (:, e2r_Area ) = elem2R (:, e2r_HydDepth ) * elem2R (:, e2r_BreadthScale ) elem2R (:, e2r_Volume ) = elem2R (:, e2r_Area ) * elem2R (:, e2r_Length ) elem2R (:, e2r_Perimeter ) = elem2R (:, e2r_BreadthScale ) + twoR * elem2R (:, e2r_HydDepth ) endwhere else !% handle elements of other geometry types print * , 'error: initialization for non-rectangular elements needed in ' , subroutine_name stop end if !%  Update velocity where ( ( elem2I (:, e2i_link_ID ) == Lindx ) . and . ( elem2R (:, e2r_Area ) > zeroR ) ) elem2R (:, e2r_Velocity ) = elem2R (:, e2r_Flowrate ) / elem2R (:, e2r_Area ) endwhere !print *, elem2R(:,e2r_HydDepth) !stop enddo !print *, elem2R(:,e2r_Flowrate) !print *, trim(subroutine_name) !stop if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine initial_conditions_from_linkdata ! !========================================================================== !========================================================================== ! subroutine initial_junction_conditions & ( faceR , faceI , elem2R , elem2I , elemMR , elemMI , nodeR , nodeI ) character ( 64 ) :: subroutine_name = 'initial_junction_conditions' real , intent ( in out ) :: elemMR (:,:) real , target , intent ( in ) :: elem2R (:,:), nodeR (:,:), faceR (:,:) integer , target , intent ( in ) :: elem2I (:,:), elemMI (:,:), nodeI (:,:), faceI (:,:) integer , pointer :: tface , telem real :: upvalue ( upstream_face_per_elemM ), dnvalue ( dnstream_face_per_elemM ) integer :: ii , mm !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name if ( N_elemM > 0 ) then !% initialize the free surface from the average of the adjacent elements call junction_adjacent_element_average & ( elem2R , elemMR , elemMI , faceI , e2r_Eta , eMr_Eta ) !% initialize the branch areas to the values of the adjacent elements call junction_adjacent_element_values_to_branches & ( elem2R , elemMR , elemMI , faceI , e2r_Area , eMr_AreaUp , eMr_AreaDn ) !% initialize the branch flowrates to the values of the adjacent elements call junction_adjacent_element_values_to_branches & ( elem2R , elemMR , elemMI , faceI , e2r_Flowrate , eMr_FlowrateUp , eMr_FlowrateDn ) !% initialize element momentum to the average of the net upstream and downstrea !% fluxes call junction_branch_average_of_inflows_and_outflows ( elemMR , elemMI ) !% here we assume the branch and junction topwidths are already initialized !% in a prior call to junction_geometry_setup !print *, elemMR(:,eMr_Topwidth) !print *, elemMR(:,eMr_TopwidthAll) where ( elemMI (:, eMi_elem_type ) == eJunctionChannel ) elemMR (:, eMr_HydDepth ) = elemMR (:, eMr_Eta ) - elemMR (:, eMr_Zbottom ) endwhere ! HACK -- need other geometry types where (( elemMI (:, eMi_geometry ) == eRectangular ) . and . & ( elemMI (:, eMi_elem_type ) == eJunctionChannel )) elemMR (:, eMr_Area ) = elemMR (:, eMr_HydDepth ) * elemMR (:, eMr_Topwidth ) elemMR (:, eMr_Volume ) = elemMR (:, eMr_Area ) * elemMR (:, eMr_Length ) elemMR (:, eMr_Perimeter ) = elemMR (:, eMr_Breadthscale ) + twoR * elemMR (:, eMr_HydDepth ) elemMR (:, eMr_HydRadius ) = elemMR (:, eMr_Area ) / elemMR (:, eMr_Perimeter ) endwhere !% velocities call junction_branch_velocities ( elemMR , elemMI ) where (( elemMI (:, eMi_elem_type ) == eJunctionChannel ) . and . & ( elemMr (:, eMr_Area ) > zeroR )) elemMR (:, eMr_Velocity ) = elemMR (:, eMr_Flowrate ) / elemMR (:, eMr_Area ) endwhere end if if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine initial_junction_conditions ! !========================================================================== !========================================================================== ! ! subroutine initial_condition_setupOLD & !    (elem2R, elemMR, elem2I, elemMI, elem2YN, elemMYN, & !     faceR, faceI, faceYN, bcdataDn, bcdataUp) ! ! character(64) :: subroutine_name = 'initial_condition_setup' ! ! real,      intent(in out)  :: elem2R(:,:), elemMR(:,:), faceR(:,:) ! ! integer,   intent(in out)  :: elem2I(:,:), elemMI(:,:) ! ! logical,   intent(in out)  :: elem2YN(:,:), elemMYN(:,:), faceYN(:,:) ! ! integer,   intent(in out)      :: faceI(:,:) ! ! type(bcType),  intent(in)  :: bcdataDn(:), bcdataUp(:) ! ! real  ::  uniform_water_depth, uniform_bottom_roughness, uniform_flowrate ! ! integer :: mm !!-------------------------------------------------------------------------- ! if ((debuglevel > 0) .or. (debuglevelall > 0)) print *, '*** enter ',subroutine_name ! ! select case (casename) !    case ('1link_network') !        uniform_water_depth = 0.5 !        uniform_bottom_roughness = 0.03 !        uniform_flowrate = 0.822225 ! !        print *, 'in ',subroutine_name,'---------------------------' !        print *, 'setting initial uniform water depth of ',uniform_water_depth ! !!        call initial_condition_for_uniform_rectangular_channel & !!            (uniform_water_depth, uniform_bottom_roughness, & !!             elem2R, elemMR, elem2I, elemMI, elem2YN, elemMYN, & !!             faceI, bcdataDn, bcdataUp) !! !        call bc_nullify_ghost_elem (elem2R, bcdataDn) !        call bc_nullify_ghost_elem (elem2R, bcdataUp) ! !        call element_geometry_update & !            (elem2R, elem2I, elem2YN, e2r_Volume, & !             elemMR, elemMI, elemMYN, eMr_Volume, & !             faceI, bcdataDn, bcdataUp) ! !        ! HACK hard code setup of flowrate ! !        elem2R(:,e2r_Flowrate) = uniform_flowrate !        elem2R(:,e2r_Velocity) = elem2R(:,e2r_Flowrate) / elem2R(:,e2r_Area) !        print *, 'setting initial flowrate of ',uniform_flowrate ! !        call element_dynamics_update & !            (elem2R, elemMR, faceR, elem2I, elemMI, elem2YN, elemMYN, & !             bcdataDn, bcdataUp, e2r_Velocity, eMr_Velocity) ! !        call face_update & !            (elem2R, elemMR, faceR, faceI, faceYN, & !             bcdataDn, bcdataUp, e2r_Velocity, eMr_Velocity) ! !    case ('6link_1_line_network') !        print *, 'error initial condition not defined for ',casename,' in ',subroutine_name !        stop ! !    case ('3link_Y_network') !        print *, 'error initial condition not defined for ',casename,' in ',subroutine_name !        stop ! !    case ('6link_Y_network') !        print *, 'error initial condition not defined for ',casename,' in ',subroutine_name !        stop ! !    case default !        print * !        print *, 'casename = ',casename !        print *, 'error: valid casename not selected in ',subroutine_name !        stop ! end select ! ! ! remainder of geometry based on branches ! call junction_geometry_from_branches (elemMR, elemMI) ! ! ! if ((debuglevel > 0) .or. (debuglevelall > 0)) print *, '*** leave ',subroutine_name ! end subroutine initial_condition_setupOLD !! !========================================================================== !========================================================================== ! ! subroutine initial_condition_for_uniform_rectangular_channelOLD & !    (uniform_water_depth, uniform_bottom_roughness, & !     elem2R, elemMR, elem2I, elemMI, elem2YN, elemMYN, & !     faceI, bcdataDn, bcdataUp) !! !! simple rectangular channels with initial uniform depth !! ! character(64) :: subroutine_name = 'initial_condition_for_uniform_rectangular_channel' ! ! real,      intent(in out)  :: elem2R(:,:), elemMR(:,:) ! ! integer,   intent(in out)  :: elem2I(:,:), elemMI(:,:) ! ! logical,   intent(in out)  :: elem2YN(:,:), elemMYN(:,:) ! ! integer,   intent(in)      :: faceI(:,:) ! ! type(bcType),  target,  intent(in)  :: bcdataDn(:), bcdataUp(:) ! ! real,  intent(in)  :: uniform_water_depth, uniform_bottom_roughness ! ! integer,   pointer :: eID ! ! integer :: ii ! !!-------------------------------------------------------------------------- ! if ((debuglevel > 0) .or. (debuglevelall > 0)) print *, '*** enter ',subroutine_name ! ! ! 2-face elements - rectangular ! ! note that topwidth, zbottom, length were extracted from link data in network processing ! elem2R(:,e2r_Area)         = uniform_water_depth * elem2R(:,e2r_Topwidth) ! ! elem2R(:,e2r_Volume)       = elem2R(:,e2r_Area) * elem2R(:,e2r_Length) ! ! elem2R(:,e2r_Perimeter)    = elem2R(:,e2r_Topwidth) + twoR * uniform_water_depth ! ! elem2R(:,e2r_Eta)          = uniform_water_depth + elem2R(:,e2r_Zbottom) ! ! elem2R(:,e2r_Roughness)    = uniform_bottom_roughness ! ! elem2R(:,e2r_Flowrate)     = zeroR ! elem2R(:,e2r_Velocity)     = zeroR ! ! ! multi-face elements - rectangular ! ! note that topwidth, zbottom, length were extracted from link data in network processing ! elemMR(:,eMr_AreaAll)      = uniform_water_depth * elemMR(:,eMr_TopwidthAll) ! ! elemMR(:,eMr_Eta)          = uniform_water_depth + elemMR(:,eMr_Zbottom) ! ! elemMR(:,eMr_Perimeter)    = elemMR(:,eMr_Topwidth) + twoR * uniform_water_depth ! ! elem2R(:,eMr_Roughness)    = uniform_bottom_roughness ! ! elemMR(:,eMr_Flowrate)     = zeroR ! elemMR(:,eMr_Velocity)     = zeroR ! ! ! if ((debuglevel > 0) .or. (debuglevelall > 0)) print *, '*** leave ',subroutine_name ! end subroutine initial_condition_for_uniform_rectangular_channelOLD !! !========================================================================== ! END OF MODULE initial_condition !========================================================================== end module initial_condition","title":"initial_condition.f08 – SWMMengine","tags":"","loc":"sourcefile/initial_condition.f08.html"},{"text":"This file depends on sourcefile~~case_simple_channel.f08~~EfferentGraph sourcefile~case_simple_channel.f08 case_simple_channel.f08 sourcefile~globals.f08 globals.f08 sourcefile~case_simple_channel.f08->sourcefile~globals.f08 sourcefile~setting_definition.f08 setting_definition.f08 sourcefile~case_simple_channel.f08->sourcefile~setting_definition.f08 sourcefile~allocate_storage.f08 allocate_storage.f08 sourcefile~case_simple_channel.f08->sourcefile~allocate_storage.f08 sourcefile~array_index.f08 array_index.f08 sourcefile~case_simple_channel.f08->sourcefile~array_index.f08 sourcefile~bc.f08 bc.f08 sourcefile~case_simple_channel.f08->sourcefile~bc.f08 sourcefile~data_keys.f08 data_keys.f08 sourcefile~case_simple_channel.f08->sourcefile~data_keys.f08 sourcefile~globals.f08->sourcefile~setting_definition.f08 sourcefile~type_definitions.f08 type_definitions.f08 sourcefile~globals.f08->sourcefile~type_definitions.f08 sourcefile~setting_definition.f08->sourcefile~type_definitions.f08 sourcefile~allocate_storage.f08->sourcefile~globals.f08 sourcefile~allocate_storage.f08->sourcefile~array_index.f08 sourcefile~utility.f08 utility.f08 sourcefile~allocate_storage.f08->sourcefile~utility.f08 sourcefile~array_index.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~globals.f08 sourcefile~bc.f08->sourcefile~setting_definition.f08 sourcefile~bc.f08->sourcefile~array_index.f08 sourcefile~bc.f08->sourcefile~data_keys.f08 sourcefile~bc.f08->sourcefile~type_definitions.f08 sourcefile~bc.f08->sourcefile~utility.f08 sourcefile~data_keys.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~globals.f08 sourcefile~utility.f08->sourcefile~setting_definition.f08 sourcefile~utility.f08->sourcefile~array_index.f08 sourcefile~utility.f08->sourcefile~data_keys.f08 var pansourcefilecase_simple_channelf08EfferentGraph = svgPanZoom('#sourcefilecase_simple_channelf08EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~case_simple_channel.f08~~AfferentGraph sourcefile~case_simple_channel.f08 case_simple_channel.f08 sourcefile~test_cases.f08 test_cases.f08 sourcefile~test_cases.f08->sourcefile~case_simple_channel.f08 sourcefile~main.f08 main.f08 sourcefile~main.f08->sourcefile~test_cases.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules case_simple_channel Source Code case_simple_channel.f08 Source Code ! module case_simple_channel ! ! Custom test case for a simple channel created with one link and two nodes ! Used in conjunction with test_cases module for custom setup. ! !========================================================================== ! module case_simple_channel ! use allocate_storage use array_index use bc use data_keys use globals use setting_definition implicit none private public :: case_simple_channel_initialize integer :: debuglevel = 0 contains ! !========================================================================== !========================================================================== ! subroutine case_simple_channel_initialize & ( channel_length , channel_breadth , subdivide_length , lowerZ , upperZ , & initial_flowrate , depth_upstream , depth_dnstream , & ManningsN , roughness_type , idepth_type , & linkR , nodeR , linkI , nodeI , linkYN , nodeYN , linkName , nodeName , & bcdataDn , bcdataUp ) ! ! initialize the link-node system and boundary conditions for a simple channel ! character ( 64 ) :: subroutine_name = 'case_simple_channel_initialize' real , intent ( in ) :: channel_length , channel_breadth , subdivide_length real , intent ( in ) :: lowerZ , upperZ , ManningsN , initial_flowrate real , intent ( in ) :: depth_upstream , depth_dnstream integer , intent ( in ) :: roughness_type , idepth_type integer , dimension (:,:), allocatable , target , intent ( out ) :: linkI integer , dimension (:,:), allocatable , target , intent ( out ) :: nodeI real , dimension (:,:), allocatable , target , intent ( out ) :: linkR real , dimension (:,:), allocatable , target , intent ( out ) :: nodeR logical , dimension (:,:), allocatable , target , intent ( out ) :: linkYN logical , dimension (:,:), allocatable , target , intent ( out ) :: nodeYN type ( string ), dimension (:), allocatable , target , intent ( out ) :: linkName type ( string ), dimension (:), allocatable , target , intent ( out ) :: nodeName type ( bcType ), dimension (:), allocatable , intent ( out ) :: bcdataUp , bcdataDn integer :: ntimepoint , ndnstreamBC , nupstreamBC !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name ! Boundary conditions ntimepoint = 2 nupstreamBC = 1 ndnstreamBC = 1 ! check if call bc_allocate & ( bcdataDn , bcdataUp , ndnstreamBC , nupstreamBC , ntimepoint ) ! assign values ! downstream is default to elevation bcdataDn ( 1 )% NodeID = 2 bcdataDn ( 1 )% TimeArray ( 1 ) = setting % Time % StartTime bcdataDn ( 1 )% TimeArray ( 2 ) = setting % Time % EndTime + 10 0.0 !s bcdataDn ( 1 )% ValueArray ( 1 ) = lowerZ + depth_dnstream ! m bcdataDn ( 1 )% ValueArray ( 2 ) = lowerZ + depth_dnstream ! m ! upstream is default to flowrate bcdataUp ( 1 )% NodeID = 1 bcdataUp ( 1 )% TimeArray ( 1 ) = setting % Time % StartTime bcdataUp ( 1 )% TimeArray ( 2 ) = setting % Time % EndTime + 10 0.0 !s bcdataUp ( 1 )% ValueArray ( 1 ) = initial_flowrate ! m&#94;3/s bcdataUp ( 1 )% ValueArray ( 2 ) = initial_flowrate ! m&#94;3/2 call case_simple_channel_links_and_nodes & ( channel_length , channel_breadth , subdivide_length , lowerZ , upperZ , & initial_flowrate , depth_upstream , depth_dnstream , ManningsN , & roughness_type , idepth_type , & linkR , nodeR , linkI , nodeI , linkYN , nodeYN , linkName , nodeName ) if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine case_simple_channel_initialize ! !========================================================================== ! ! PRIVATE BELOW HERE ! !========================================================================== ! subroutine case_simple_channel_links_and_nodes & ( channel_length , channel_breadth , subdivide_length , lowerZ , upperZ , & initial_flowrate , depth_upstream , depth_dnstream , ManningsN , & roughness_type , idepth_type , & linkR , nodeR , linkI , nodeI , linkYN , nodeYN , linkName , nodeName ) ! ! creates a simple rectangular channel with 1 link and 2 nodes ! character ( 64 ) :: subroutine_name = 'case_simple_channel_links_and_nodes' real , intent ( in ) :: channel_length , channel_breadth , subdivide_length real , intent ( in ) :: lowerZ , upperZ , ManningsN , initial_flowrate real , intent ( in ) :: depth_upstream , depth_dnstream integer , intent ( in ) :: roughness_type , idepth_type integer , dimension (:,:), allocatable , target , intent ( out ) :: linkI integer , dimension (:,:), allocatable , target , intent ( out ) :: nodeI real , dimension (:,:), allocatable , target , intent ( out ) :: linkR real , dimension (:,:), allocatable , target , intent ( out ) :: nodeR logical , dimension (:,:), allocatable , target , intent ( out ) :: linkYN logical , dimension (:,:), allocatable , target , intent ( out ) :: nodeYN type ( string ), dimension (:), allocatable , target , intent ( out ) :: linkName type ( string ), dimension (:), allocatable , target , intent ( out ) :: nodeName integer :: ii !-------------------------------------------------------------------------- if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** enter ' , subroutine_name N_link = 1 N_node = 2 call allocate_linknode_storage & ( linkR , nodeR , linkI , nodeI , linkYN , nodeYN , linkName , nodeName ) ! assign the indexes linkI (:, li_idx ) = ( / ( ii , ii = 1 , N_link ) / ) nodeI (:, ni_idx ) = ( / ( ii , ii = 1 , N_node ) / ) ! assign no names for links do ii = 1 , N_link linkName ( ii )% str = \"Channel\" end do ! assign zeros for accumulators nodeI (:, ni_N_link_d ) = 0 nodeI (:, ni_N_link_u ) = 0 ! assign uniform physical data linkI (:, li_roughness_type ) = roughness_type linkR (:, lr_Roughness ) = ManningsN ! designate the upstream nodes nodeI ( 1 , ni_node_type ) = nBCup nodeR ( 1 , nr_Zbottom ) = upperZ nodeName ( 1 )% str = 'UpstreamBC' ! designate the downstream node nodeI ( 2 , ni_node_type ) = nBCdn nodeR ( 2 , nr_Zbottom ) = lowerZ nodeName ( 2 )% str = 'DownstreamBC' ! assign the link types linkI (:, li_link_type ) = lChannel ! assign all as rectangular channels linkI (:, li_geometry ) = lRectangular ! assign the link position and mappings linkI ( 1 , li_Mnode_u ) = 1 ! map to upstream node linkI ( 1 , li_Mnode_d ) = 2 ! map to downstream node linkR ( 1 , lr_Length ) = channel_length linkR ( 1 , lr_BreadthScale ) = channel_breadth linkR ( 1 , lr_ElementLength ) = subdivide_length linkR ( 1 , lr_InitialFlowrate ) = initial_flowrate linkR ( 1 , lr_InitialUpstreamDepth ) = depth_upstream linkR ( 1 , lr_InitialDnstreamDepth ) = depth_dnstream linkI ( 1 , li_InitialDepthType ) = idepth_type if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) then print * print * , subroutine_name , '-----------------------------------' print * , 'link info' print * , linkI (:, li_idx ), ' idx' print * , linkI (:, li_link_type ), ' type' print * , linkI (:, li_Mnode_u ) , ' upstream node' print * , linkI (:, li_Mnode_d ) , ' downstream node' print * , print * , 'node info' print * , nodeI (:, ni_idx ), ' idx' print * , nodeI (:, ni_node_type ), ' type' print * , nodeI (:, ni_N_link_d ), 'number of downstream links' !print *, nodeI(:,ni_Mlink_d1), 'downstream1 link' print * , nodeI (:, ni_N_link_u ), 'number of upstream links' !print *, nodeI(:,ni_Mlink_u1), 'upstream1 link' endif if (( debuglevel > 0 ) . or . ( debuglevelall > 0 )) print * , '*** leave ' , subroutine_name end subroutine case_simple_channel_links_and_nodes ! !========================================================================== ! END OF MODULE case_simple_channel !========================================================================== end module case_simple_channel","title":"case_simple_channel.f08 – SWMMengine","tags":"","loc":"sourcefile/case_simple_channel.f08.html"},{"text":"type, public :: date Contents Variables day month year Components Type Visibility Attributes Name Initial integer, public :: day integer, public :: month integer, public :: year","title":"date – SWMMengine ","tags":"","loc":"type/date.html"},{"text":"type, public :: string Contents Variables str Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: str","title":"string – SWMMengine ","tags":"","loc":"type/string.html"},{"text":"type, public :: diagnosticVolumeType Inherited by type~~diagnosticvolumetype~~InheritedByGraph type~diagnosticvolumetype diagnosticVolumeType type~diagnostictype diagnosticType type~diagnostictype->type~diagnosticvolumetype Volume Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Step Time Volume VolumeChange NetInflowVolume InflowRate OutflowRate ConservationThisStep ConservationTotal Components Type Visibility Attributes Name Initial integer, public :: Step real, public :: Time real, public :: Volume real, public :: VolumeChange real, public :: NetInflowVolume real, public :: InflowRate real, public :: OutflowRate real, public :: ConservationThisStep real, public :: ConservationTotal","title":"diagnosticVolumeType – SWMMengine ","tags":"","loc":"type/diagnosticvolumetype.html"},{"text":"type, public :: diagnosticType Inherits type~~diagnostictype~~InheritsGraph type~diagnostictype diagnosticType type~diagnosticvolumetype diagnosticVolumeType type~diagnostictype->type~diagnosticvolumetype Volume Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Volume Components Type Visibility Attributes Name Initial type( diagnosticVolumeType ), public :: Volume","title":"diagnosticType – SWMMengine ","tags":"","loc":"type/diagnostictype.html"},{"text":"type, public :: bcType Contents Variables Idx NodeID FaceID ElemGhostID ElemInsideID Updn Category TimeArray ValueArray ThisValue ThisTime ThisFlowrate Components Type Visibility Attributes Name Initial integer, public :: Idx integer, public :: NodeID integer, public :: FaceID integer, public :: ElemGhostID integer, public :: ElemInsideID integer, public :: Updn integer, public :: Category real, public, dimension(:), allocatable :: TimeArray real, public, dimension(:), allocatable :: ValueArray real, public :: ThisValue real, public :: ThisTime real, public :: ThisFlowrate","title":"bcType – SWMMengine ","tags":"","loc":"type/bctype.html"},{"text":"type, public :: outputfileType Inherited by type~~outputfiletype~~InheritedByGraph type~outputfiletype outputfileType type~debugfiletype debugfileType type~debugfiletype->type~outputfiletype FileInfo type~threadedfiletype threadedfileType type~threadedfiletype->type~outputfiletype FileInfo Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables UnitNumber FileName FolderName FolderPath FileStatus WriteName IsOpen Components Type Visibility Attributes Name Initial integer, public :: UnitNumber = 0 character(len=256), public :: FileName = 'dummy.txt' character(len=256), public :: FolderName = 'dummyFolder' character(len=256), public :: FolderPath = './' character(len=32), public :: FileStatus = 'new' character(len=512), public :: WriteName = '' logical, public :: IsOpen = .false.","title":"outputfileType – SWMMengine ","tags":"","loc":"type/outputfiletype.html"},{"text":"type, public :: debugfileType Inherits type~~debugfiletype~~InheritsGraph type~debugfiletype debugfileType type~outputfiletype outputfileType type~debugfiletype->type~outputfiletype FileInfo Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables FileInfo ArrayName ColumnIndex Components Type Visibility Attributes Name Initial type( outputfileType ), public :: FileInfo character(len=32), public :: ArrayName integer, public :: ColumnIndex","title":"debugfileType – SWMMengine ","tags":"","loc":"type/debugfiletype.html"},{"text":"type, public :: threadedfileType Inherits type~~threadedfiletype~~InheritsGraph type~threadedfiletype threadedfileType type~outputfiletype outputfileType type~threadedfiletype->type~outputfiletype FileInfo Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables FileInfo DataName Components Type Visibility Attributes Name Initial type( outputfileType ), public :: FileInfo character(len=32), public :: DataName","title":"threadedfileType – SWMMengine ","tags":"","loc":"type/threadedfiletype.html"},{"text":"type, public :: adjustVshapedFlowrateType Inherited by type~~adjustvshapedflowratetype~~InheritedByGraph type~adjustvshapedflowratetype adjustVshapedFlowrateType type~methodtype methodType type~methodtype->type~adjustvshapedflowratetype AdjustVshapedFlowrate type~settingtype settingType type~settingtype->type~methodtype Method Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Apply Coef Components Type Visibility Attributes Name Initial logical, public :: Apply = .true. real, public :: Coef = 0.1","title":"adjustVshapedFlowrateType – SWMMengine ","tags":"","loc":"type/adjustvshapedflowratetype.html"},{"text":"type, public :: BClimiterType Inherited by type~~bclimitertype~~InheritedByGraph type~bclimitertype BClimiterType type~limitertype limiterType type~limitertype->type~bclimitertype BC type~settingtype settingType type~settingtype->type~limitertype Limiter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables UseInflowFroudeNumberLimiter FroudeInflowMaximum Components Type Visibility Attributes Name Initial logical, public :: UseInflowFroudeNumberLimiter = .true. real, public :: FroudeInflowMaximum = 1.5","title":"BClimiterType – SWMMengine ","tags":"","loc":"type/bclimitertype.html"},{"text":"type, public :: flowrateType Inherited by type~~flowratetype~~InheritedByGraph type~flowratetype flowrateType type~limitertype limiterType type~limitertype->type~flowratetype Flowrate type~settingtype settingType type~settingtype->type~limitertype Limiter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables UseFaceVolumeTransport FaceVolumeTransport Components Type Visibility Attributes Name Initial logical, public :: UseFaceVolumeTransport = .true. real, public :: FaceVolumeTransport = 0.5","title":"flowrateType – SWMMengine ","tags":"","loc":"type/flowratetype.html"},{"text":"type, public :: timescaleType Inherited by type~~timescaletype~~InheritedByGraph type~timescaletype timescaleType type~limitertype limiterType type~limitertype->type~timescaletype Timescale type~settingtype settingType type~settingtype->type~limitertype Limiter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Maximum Minimum Components Type Visibility Attributes Name Initial real, public :: Maximum = 1e6 real, public :: Minimum = 1e-6","title":"timescaleType – SWMMengine ","tags":"","loc":"type/timescaletype.html"},{"text":"type, public :: velocityType Inherited by type~~velocitytype~~InheritedByGraph type~velocitytype velocityType type~limitertype limiterType type~limitertype->type~velocitytype Velocity type~settingtype settingType type~settingtype->type~limitertype Limiter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables UseLimitMax Maximum Components Type Visibility Attributes Name Initial logical, public :: UseLimitMax = .true. real, public :: Maximum = 20","title":"velocityType – SWMMengine ","tags":"","loc":"type/velocitytype.html"},{"text":"type, public :: constantType Inherited by type~~constanttype~~InheritedByGraph type~constanttype constantType type~settingtype settingType type~settingtype->type~constanttype Constant Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables gravity Components Type Visibility Attributes Name Initial real, public :: gravity = 9.81","title":"constantType – SWMMengine ","tags":"","loc":"type/constanttype.html"},{"text":"type, public :: debugoutType Inherited by type~~debugouttype~~InheritedByGraph type~debugouttype debugoutType type~settingtype settingType type~settingtype->type~debugouttype DebugOut Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables elem2R elem2I elem2YN elemMR elemMI elemMYN faceR faceI faceYN nodeR nodeI nodeYN linkR linkI linkYN DisplayInterval SuppressAllFiles SuppressTimeStep SuppressTimeValue SuppressNdat FolderName FileName FolderPath Components Type Visibility Attributes Name Initial logical, public :: elem2R = .false. logical, public :: elem2I = .false. logical, public :: elem2YN = .false. logical, public :: elemMR = .false. logical, public :: elemMI = .false. logical, public :: elemMYN = .false. logical, public :: faceR = .false. logical, public :: faceI = .false. logical, public :: faceYN = .false. logical, public :: nodeR = .false. logical, public :: nodeI = .false. logical, public :: nodeYN = .false. logical, public :: linkR = .false. logical, public :: linkI = .false. logical, public :: linkYN = .false. integer, public :: DisplayInterval = 1 logical, public :: SuppressAllFiles = .false. logical, public :: SuppressTimeStep = .false. logical, public :: SuppressTimeValue = .false. logical, public :: SuppressNdat = .false. character(len=64), public :: FolderName = 'debugoutputA' character(len=64), public :: FileName = 'debug' character(len=256), public :: FolderPath = './'","title":"debugoutType – SWMMengine ","tags":"","loc":"type/debugouttype.html"},{"text":"type, public :: epsilonType Inherited by type~~epsilontype~~InheritedByGraph type~epsilontype epsilonType type~settingtype settingType type~settingtype->type~epsilontype Eps Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables FroudeJump InflowDepthIncreaseFroudeLimit Components Type Visibility Attributes Name Initial real, public :: FroudeJump = 0.1 real, public :: InflowDepthIncreaseFroudeLimit = 0.1","title":"epsilonType – SWMMengine ","tags":"","loc":"type/epsilontype.html"},{"text":"type, public :: limiterType Inherits type~~limitertype~~InheritsGraph type~limitertype limiterType type~velocitytype velocityType type~limitertype->type~velocitytype Velocity type~timescaletype timescaleType type~limitertype->type~timescaletype Timescale type~bclimitertype BClimiterType type~limitertype->type~bclimitertype BC type~flowratetype flowrateType type~limitertype->type~flowratetype Flowrate Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~limitertype~~InheritedByGraph type~limitertype limiterType type~settingtype settingType type~settingtype->type~limitertype Limiter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables BC Flowrate Velocity Timescale Components Type Visibility Attributes Name Initial type( BClimiterType ), public :: BC type( flowrateType ), public :: Flowrate type( velocityType ), public :: Velocity type( timescaleType ), public :: Timescale","title":"limiterType – SWMMengine ","tags":"","loc":"type/limitertype.html"},{"text":"type, public :: methodType Inherits type~~methodtype~~InheritsGraph type~methodtype methodType type~adjustvshapedflowratetype adjustVshapedFlowrateType type~methodtype->type~adjustvshapedflowratetype AdjustVshapedFlowrate Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~methodtype~~InheritedByGraph type~methodtype methodType type~settingtype settingType type~settingtype->type~methodtype Method Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables AdjustVshapedFlowrate Components Type Visibility Attributes Name Initial type( adjustVshapedFlowrateType ), public :: AdjustVshapedFlowrate","title":"methodType – SWMMengine ","tags":"","loc":"type/methodtype.html"},{"text":"type, public :: outputThreadedLinkType Inherited by type~~outputthreadedlinktype~~InheritedByGraph type~outputthreadedlinktype outputThreadedLinkType type~settingtype settingType type~settingtype->type~outputthreadedlinktype OutputThreadedLink Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables DisplayInterval SuppressAllFiles UseThisOutput area flowrate velocity eta depth FolderName FileName FolderPath Components Type Visibility Attributes Name Initial integer, public :: DisplayInterval = 1 logical, public :: SuppressAllFiles = .false. logical, public :: UseThisOutput = .false. logical, public :: area = .false. logical, public :: flowrate = .false. logical, public :: velocity = .false. logical, public :: eta = .false. logical, public :: depth = .false. character(len=64), public :: FolderName = 'OutputThreaded' character(len=64), public :: FileName = 'out' character(len=256), public :: FolderPath = './'","title":"outputThreadedLinkType – SWMMengine ","tags":"","loc":"type/outputthreadedlinktype.html"},{"text":"type, public :: smallvolumeType Inherited by type~~smallvolumetype~~InheritedByGraph type~smallvolumetype smallvolumeType type~settingtype settingType type~settingtype->type~smallvolumetype SmallVolume Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables UseSmallVolumes DepthCutoff ManningsN MinimumTopwidth MinimumArea MinimumPerimeter MinimumHydRadius Components Type Visibility Attributes Name Initial logical, public :: UseSmallVolumes = .true. real, public :: DepthCutoff = 0.01 real, public :: ManningsN = 0.01 real, public :: MinimumTopwidth = 0.5 real, public :: MinimumArea = 0.005 real, public :: MinimumPerimeter = 0.52 real, public :: MinimumHydRadius = 0.009","title":"smallvolumeType – SWMMengine ","tags":"","loc":"type/smallvolumetype.html"},{"text":"type, public :: stepType Inherited by type~~steptype~~InheritedByGraph type~steptype stepType type~settingtype settingType type~settingtype->type~steptype Step Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables First Final Current FromRestart Components Type Visibility Attributes Name Initial integer, public :: First integer, public :: Final integer, public :: Current integer, public :: FromRestart","title":"stepType – SWMMengine ","tags":"","loc":"type/steptype.html"},{"text":"type, public :: testcaseType Inherited by type~~testcasetype~~InheritedByGraph type~testcasetype testcaseType type~settingtype settingType type~settingtype->type~testcasetype TestCase Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables UseTestCase TestName Components Type Visibility Attributes Name Initial logical, public :: UseTestCase character(len=64), public :: TestName","title":"testcaseType – SWMMengine ","tags":"","loc":"type/testcasetype.html"},{"text":"type, public :: timeType Inherited by type~~timetype~~InheritedByGraph type~timetype timeType type~settingtype settingType type~settingtype->type~timetype Time Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables DateTimeStamp Dt StartTime EndTime ThisTime NextTime Components Type Visibility Attributes Name Initial character(len=14), public :: DateTimeStamp real, public :: Dt real, public :: StartTime = 0.0 real, public :: EndTime = 0.0 real, public :: ThisTime real, public :: NextTime","title":"timeType – SWMMengine ","tags":"","loc":"type/timetype.html"},{"text":"type, public :: zerovalueType Inherited by type~~zerovaluetype~~InheritedByGraph type~zerovaluetype zerovalueType type~settingtype settingType type~settingtype->type~zerovaluetype ZeroValue Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables UseZeroValues Area Depth Flowrate Topwidth Velocity Volume Components Type Visibility Attributes Name Initial logical, public :: UseZeroValues = .true. real, public :: Area = 1.0e-7 real, public :: Depth = 1.0e-4 real, public :: Flowrate = 0.0 real, public :: Topwidth = 1.0e-4 real, public :: Velocity = 0.0 real, public :: Volume = 1.0e-6","title":"zerovalueType – SWMMengine ","tags":"","loc":"type/zerovaluetype.html"},{"text":"type, public :: settingType Inherits type~~settingtype~~InheritsGraph type~settingtype settingType type~debugouttype debugoutType type~settingtype->type~debugouttype DebugOut type~testcasetype testcaseType type~settingtype->type~testcasetype TestCase type~epsilontype epsilonType type~settingtype->type~epsilontype Eps type~outputthreadedlinktype outputThreadedLinkType type~settingtype->type~outputthreadedlinktype OutputThreadedLink type~constanttype constantType type~settingtype->type~constanttype Constant type~steptype stepType type~settingtype->type~steptype Step type~smallvolumetype smallvolumeType type~settingtype->type~smallvolumetype SmallVolume type~zerovaluetype zerovalueType type~settingtype->type~zerovaluetype ZeroValue type~methodtype methodType type~settingtype->type~methodtype Method type~timetype timeType type~settingtype->type~timetype Time type~limitertype limiterType type~settingtype->type~limitertype Limiter type~adjustvshapedflowratetype adjustVshapedFlowrateType type~methodtype->type~adjustvshapedflowratetype AdjustVshapedFlowrate type~velocitytype velocityType type~limitertype->type~velocitytype Velocity type~timescaletype timescaleType type~limitertype->type~timescaletype Timescale type~bclimitertype BClimiterType type~limitertype->type~bclimitertype BC type~flowratetype flowrateType type~limitertype->type~flowratetype Flowrate Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables dummy Constant DebugOut Eps Limiter Method OutputThreadedLink SmallVolume Step TestCase Time ZeroValue Components Type Visibility Attributes Name Initial integer, public :: dummy type( constantType ), public :: Constant type( debugoutType ), public :: DebugOut type( epsilonType ), public :: Eps type( limiterType ), public :: Limiter type( methodType ), public :: Method type( outputThreadedLinkType ), public :: OutputThreadedLink type( smallvolumeType ), public :: SmallVolume type( stepType ), public :: Step type( testcaseType ), public :: TestCase type( timeType ), public :: Time type( zerovalueType ), public :: ZeroValue","title":"settingType – SWMMengine ","tags":"","loc":"type/settingtype.html"},{"text":"public subroutine checking_consistency() Arguments None Called by proc~~checking_consistency~~CalledByGraph proc~checking_consistency checking_consistency program~main main program~main->proc~checking_consistency Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"checking_consistency – SWMMengine","tags":"","loc":"proc/checking_consistency.html"},{"text":"public subroutine checking_smallvolume_consistency(elem2R, elemMR) Arguments Type Intent Optional Attributes Name real, intent(in) :: elem2R (:,:) real, intent(in) :: elemMR (:,:) Called by proc~~checking_smallvolume_consistency~~CalledByGraph proc~checking_smallvolume_consistency checking_smallvolume_consistency program~main main program~main->proc~checking_smallvolume_consistency Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"checking_smallvolume_consistency – SWMMengine","tags":"","loc":"proc/checking_smallvolume_consistency.html"},{"text":"public subroutine bc_allocate(bcdataDn, bcdataUp, ndnstreamBC, nupstreamBC, ntimepoint) Arguments Type Intent Optional Attributes Name type(bcType), intent(out), dimension(:), allocatable :: bcdataDn type(bcType), intent(out), dimension(:), allocatable :: bcdataUp integer, intent(in) :: ndnstreamBC integer, intent(in) :: nupstreamBC integer, intent(in) :: ntimepoint Calls proc~~bc_allocate~~CallsGraph proc~bc_allocate bc_allocate proc~utility_check_allocation utility_check_allocation proc~bc_allocate->proc~utility_check_allocation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bc_allocate~~CalledByGraph proc~bc_allocate bc_allocate proc~case_simple_channel_initialize case_simple_channel_initialize proc~case_simple_channel_initialize->proc~bc_allocate proc~case_y_channel_initialize case_y_channel_initialize proc~case_y_channel_initialize->proc~bc_allocate proc~test_case_initiation test_case_initiation proc~test_case_initiation->proc~case_y_channel_initialize program~main main program~main->proc~test_case_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"bc_allocate – SWMMengine","tags":"","loc":"proc/bc_allocate.html"},{"text":"public subroutine bc_applied_onface(faceR, faceI, elem2R, elem2I, bcdataDn, bcdataUp, e2r_Velocity_new, thisTime) Arguments Type Intent Optional Attributes Name real, intent(inout) :: faceR (:,:) integer, intent(inout) :: faceI (:,:) real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) integer, intent(in) :: e2r_Velocity_new real, intent(in) :: thisTime Calls proc~~bc_applied_onface~~CallsGraph proc~bc_applied_onface bc_applied_onface proc~bc_onface bc_onface proc~bc_applied_onface->proc~bc_onface proc~bc_ghost_othervalues bc_ghost_othervalues proc~bc_applied_onface->proc~bc_ghost_othervalues proc~bc_face_othervalues bc_face_othervalues proc~bc_applied_onface->proc~bc_face_othervalues proc~bc_updatevalue bc_updatevalue proc~bc_onface->proc~bc_updatevalue proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bc_applied_onface~~CalledByGraph proc~bc_applied_onface bc_applied_onface proc~face_update face_update proc~face_update->proc~bc_applied_onface proc~explicit_test_advance explicit_test_advance proc~explicit_test_advance->proc~bc_applied_onface proc~explicit_euler_advance explicit_euler_advance proc~explicit_euler_advance->proc~bc_applied_onface proc~time_marching time_marching proc~time_marching->proc~bc_applied_onface proc~rk2 rk2 proc~time_marching->proc~rk2 program~main main program~main->proc~time_marching proc~initial_condition_setup initial_condition_setup program~main->proc~initial_condition_setup proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~face_update proc~initial_condition_setup->proc~face_update proc~rk2->proc~rk2_update_auxiliary_variables var panprocbc_applied_onfaceCalledByGraph = svgPanZoom('#procbc_applied_onfaceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"bc_applied_onface – SWMMengine","tags":"","loc":"proc/bc_applied_onface.html"},{"text":"public subroutine bc_applied_onelement(elem2R, bcdataDn, bcdataUp, thisTime, thiscategory, e2r_VelocityColumn) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) real, intent(in) :: thisTime integer, intent(in) :: thiscategory integer, intent(in) :: e2r_VelocityColumn Calls proc~~bc_applied_onelement~~CallsGraph proc~bc_applied_onelement bc_applied_onelement proc~bc_onelement bc_onelement proc~bc_applied_onelement->proc~bc_onelement proc~bc_updatevalue bc_updatevalue proc~bc_onelement->proc~bc_updatevalue proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bc_applied_onelement~~CalledByGraph proc~bc_applied_onelement bc_applied_onelement proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~bc_applied_onelement proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~bc_applied_onelement proc~explicit_test_advance explicit_test_advance proc~explicit_test_advance->proc~bc_applied_onelement proc~explicit_euler_advance explicit_euler_advance proc~explicit_euler_advance->proc~bc_applied_onelement proc~time_marching time_marching proc~time_marching->proc~bc_applied_onelement proc~rk2 rk2 proc~time_marching->proc~rk2 program~main main program~main->proc~time_marching proc~initial_condition_setup initial_condition_setup program~main->proc~initial_condition_setup proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup->proc~element_dynamics_update proc~initial_condition_setup->proc~element_geometry_update proc~rk2->proc~rk2_update_auxiliary_variables var panprocbc_applied_onelementCalledByGraph = svgPanZoom('#procbc_applied_onelementCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"bc_applied_onelement – SWMMengine","tags":"","loc":"proc/bc_applied_onelement.html"},{"text":"public subroutine bc_checks(bcdataUp, bcdataDn, elem2I, faceI, nodeI) Arguments Type Intent Optional Attributes Name type(bcType), intent(inout) :: bcdataUp (:) type(bcType), intent(inout) :: bcdataDn (:) integer, intent(in) :: elem2I (:,:) integer, intent(in) :: faceI (:,:) integer, intent(in), target :: nodeI (:,:) Calls proc~~bc_checks~~CallsGraph proc~bc_checks bc_checks proc~bc_node_assignment_error_check bc_node_assignment_error_check proc~bc_checks->proc~bc_node_assignment_error_check proc~bc_updatevalue bc_updatevalue proc~bc_checks->proc~bc_updatevalue proc~bc_assign_faceid bc_assign_faceID proc~bc_checks->proc~bc_assign_faceid proc~bc_adequate_coverage bc_adequate_coverage proc~bc_checks->proc~bc_adequate_coverage proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist proc~bc_adequate_coverage_onedir bc_adequate_coverage_onedir proc~bc_adequate_coverage->proc~bc_adequate_coverage_onedir Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bc_checks~~CalledByGraph proc~bc_checks bc_checks program~main main program~main->proc~bc_checks Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"bc_checks – SWMMengine","tags":"","loc":"proc/bc_checks.html"},{"text":"public subroutine bc_timescale_value(elem2R, bcdata) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) type(bcType), intent(in), target :: bcdata (:) Called by proc~~bc_timescale_value~~CalledByGraph proc~bc_timescale_value bc_timescale_value proc~element_timescale element_timescale proc~element_timescale->proc~bc_timescale_value proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~element_timescale proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocbc_timescale_valueCalledByGraph = svgPanZoom('#procbc_timescale_valueCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"bc_timescale_value – SWMMengine","tags":"","loc":"proc/bc_timescale_value.html"},{"text":"public subroutine bc_nullify_ghost_elem(elem2R, bcdata) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) type(bcType), intent(in), target :: bcdata (:) Called by proc~~bc_nullify_ghost_elem~~CalledByGraph proc~bc_nullify_ghost_elem bc_nullify_ghost_elem proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~bc_nullify_ghost_elem program~main main program~main->proc~initial_condition_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"bc_nullify_ghost_elem – SWMMengine","tags":"","loc":"proc/bc_nullify_ghost_elem.html"},{"text":"private subroutine bc_adequate_coverage(bcdataUp, bcdataDn) Arguments Type Intent Optional Attributes Name type(bcType), intent(in) :: bcdataUp (:) type(bcType), intent(in) :: bcdataDn (:) Calls proc~~bc_adequate_coverage~~CallsGraph proc~bc_adequate_coverage bc_adequate_coverage proc~bc_adequate_coverage_onedir bc_adequate_coverage_onedir proc~bc_adequate_coverage->proc~bc_adequate_coverage_onedir Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bc_adequate_coverage~~CalledByGraph proc~bc_adequate_coverage bc_adequate_coverage proc~bc_checks bc_checks proc~bc_checks->proc~bc_adequate_coverage program~main main program~main->proc~bc_checks Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"bc_adequate_coverage – SWMMengine","tags":"","loc":"proc/bc_adequate_coverage.html"},{"text":"private subroutine bc_onface(faceR, faceI, elem2R, bcdata, thisTime) Arguments Type Intent Optional Attributes Name real, intent(inout) :: faceR (:,:) integer, intent(inout) :: faceI (:,:) real, intent(in) :: elem2R (:,:) type(bcType), intent(inout), target :: bcdata (:) real, intent(in) :: thisTime Calls proc~~bc_onface~~CallsGraph proc~bc_onface bc_onface proc~bc_updatevalue bc_updatevalue proc~bc_onface->proc~bc_updatevalue proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bc_onface~~CalledByGraph proc~bc_onface bc_onface proc~bc_applied_onface bc_applied_onface proc~bc_applied_onface->proc~bc_onface proc~face_update face_update proc~face_update->proc~bc_applied_onface proc~explicit_test_advance explicit_test_advance proc~explicit_test_advance->proc~bc_applied_onface proc~explicit_euler_advance explicit_euler_advance proc~explicit_euler_advance->proc~bc_applied_onface proc~time_marching time_marching proc~time_marching->proc~bc_applied_onface proc~rk2 rk2 proc~time_marching->proc~rk2 program~main main program~main->proc~time_marching proc~initial_condition_setup initial_condition_setup program~main->proc~initial_condition_setup proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~face_update proc~initial_condition_setup->proc~face_update proc~rk2->proc~rk2_update_auxiliary_variables var panprocbc_onfaceCalledByGraph = svgPanZoom('#procbc_onfaceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"bc_onface – SWMMengine","tags":"","loc":"proc/bc_onface.html"},{"text":"private subroutine bc_face_othervalues(faceR, faceI, elem2R, bcdata) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: faceR (:,:) integer, intent(in), target :: faceI (:,:) real, intent(in), target :: elem2R (:,:) type(bcType), intent(in), target :: bcdata (:) Called by proc~~bc_face_othervalues~~CalledByGraph proc~bc_face_othervalues bc_face_othervalues proc~bc_applied_onface bc_applied_onface proc~bc_applied_onface->proc~bc_face_othervalues proc~face_update face_update proc~face_update->proc~bc_applied_onface proc~explicit_test_advance explicit_test_advance proc~explicit_test_advance->proc~bc_applied_onface proc~explicit_euler_advance explicit_euler_advance proc~explicit_euler_advance->proc~bc_applied_onface proc~time_marching time_marching proc~time_marching->proc~bc_applied_onface proc~rk2 rk2 proc~time_marching->proc~rk2 program~main main program~main->proc~time_marching proc~initial_condition_setup initial_condition_setup program~main->proc~initial_condition_setup proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~face_update proc~initial_condition_setup->proc~face_update proc~rk2->proc~rk2_update_auxiliary_variables var panprocbc_face_othervaluesCalledByGraph = svgPanZoom('#procbc_face_othervaluesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"bc_face_othervalues – SWMMengine","tags":"","loc":"proc/bc_face_othervalues.html"},{"text":"private subroutine bc_onelement(elem2R, bcdata, thisTime, thiscategory, e2r_VelocityColumn) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) type(bcType), intent(inout), target :: bcdata (:) real, intent(in) :: thisTime integer, intent(in) :: thiscategory integer, intent(in) :: e2r_VelocityColumn Calls proc~~bc_onelement~~CallsGraph proc~bc_onelement bc_onelement proc~bc_updatevalue bc_updatevalue proc~bc_onelement->proc~bc_updatevalue proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bc_onelement~~CalledByGraph proc~bc_onelement bc_onelement proc~bc_applied_onelement bc_applied_onelement proc~bc_applied_onelement->proc~bc_onelement proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~bc_applied_onelement proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~bc_applied_onelement proc~explicit_test_advance explicit_test_advance proc~explicit_test_advance->proc~bc_applied_onelement proc~explicit_euler_advance explicit_euler_advance proc~explicit_euler_advance->proc~bc_applied_onelement proc~time_marching time_marching proc~time_marching->proc~bc_applied_onelement proc~rk2 rk2 proc~time_marching->proc~rk2 program~main main program~main->proc~time_marching proc~initial_condition_setup initial_condition_setup program~main->proc~initial_condition_setup proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup->proc~element_dynamics_update proc~initial_condition_setup->proc~element_geometry_update proc~rk2->proc~rk2_update_auxiliary_variables var panprocbc_onelementCalledByGraph = svgPanZoom('#procbc_onelementCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"bc_onelement – SWMMengine","tags":"","loc":"proc/bc_onelement.html"},{"text":"private subroutine bc_updatevalue(bcdata, thisTime) Arguments Type Intent Optional Attributes Name type(bcType), intent(inout) :: bcdata (:) real, intent(in) :: thisTime Calls proc~~bc_updatevalue~~CallsGraph proc~bc_updatevalue bc_updatevalue proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bc_updatevalue~~CalledByGraph proc~bc_updatevalue bc_updatevalue proc~bc_onface bc_onface proc~bc_onface->proc~bc_updatevalue proc~bc_onelement bc_onelement proc~bc_onelement->proc~bc_updatevalue proc~bc_checks bc_checks proc~bc_checks->proc~bc_updatevalue proc~bc_applied_onelement bc_applied_onelement proc~bc_applied_onelement->proc~bc_onelement proc~bc_applied_onface bc_applied_onface proc~bc_applied_onface->proc~bc_onface program~main main program~main->proc~bc_checks proc~time_marching time_marching program~main->proc~time_marching proc~initial_condition_setup initial_condition_setup program~main->proc~initial_condition_setup proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~bc_applied_onelement proc~explicit_test_advance explicit_test_advance proc~explicit_test_advance->proc~bc_applied_onelement proc~explicit_test_advance->proc~bc_applied_onface proc~explicit_euler_advance explicit_euler_advance proc~explicit_euler_advance->proc~bc_applied_onelement proc~explicit_euler_advance->proc~bc_applied_onface proc~face_update face_update proc~face_update->proc~bc_applied_onface proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~bc_applied_onelement proc~time_marching->proc~bc_applied_onelement proc~time_marching->proc~bc_applied_onface proc~rk2 rk2 proc~time_marching->proc~rk2 proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~rk2_update_auxiliary_variables->proc~face_update proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup->proc~element_dynamics_update proc~initial_condition_setup->proc~face_update proc~initial_condition_setup->proc~element_geometry_update proc~rk2->proc~rk2_update_auxiliary_variables var panprocbc_updatevalueCalledByGraph = svgPanZoom('#procbc_updatevalueCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"bc_updatevalue – SWMMengine","tags":"","loc":"proc/bc_updatevalue.html"},{"text":"private subroutine bc_node_assignment_error_check(nodeI, faceI, nBCdir) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: nodeI (:,:) integer, intent(in) :: faceI (:,:) integer, intent(in) :: nBCdir Called by proc~~bc_node_assignment_error_check~~CalledByGraph proc~bc_node_assignment_error_check bc_node_assignment_error_check proc~bc_checks bc_checks proc~bc_checks->proc~bc_node_assignment_error_check program~main main program~main->proc~bc_checks Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"bc_node_assignment_error_check – SWMMengine","tags":"","loc":"proc/bc_node_assignment_error_check.html"},{"text":"private subroutine bc_assign_faceID(bcdata, faceI) Arguments Type Intent Optional Attributes Name type(bcType), intent(inout), target :: bcdata (:) integer, intent(in) :: faceI (:,:) Called by proc~~bc_assign_faceid~~CalledByGraph proc~bc_assign_faceid bc_assign_faceID proc~bc_checks bc_checks proc~bc_checks->proc~bc_assign_faceid program~main main program~main->proc~bc_checks Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"bc_assign_faceID – SWMMengine","tags":"","loc":"proc/bc_assign_faceid.html"},{"text":"private subroutine bc_adequate_coverage_onedir(bcdata, nBCdir) Arguments Type Intent Optional Attributes Name type(bcType), intent(in) :: bcdata (:) integer, intent(in) :: nBCdir Called by proc~~bc_adequate_coverage_onedir~~CalledByGraph proc~bc_adequate_coverage_onedir bc_adequate_coverage_onedir proc~bc_adequate_coverage bc_adequate_coverage proc~bc_adequate_coverage->proc~bc_adequate_coverage_onedir proc~bc_checks bc_checks proc~bc_checks->proc~bc_adequate_coverage program~main main program~main->proc~bc_checks Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"bc_adequate_coverage_onedir – SWMMengine","tags":"","loc":"proc/bc_adequate_coverage_onedir.html"},{"text":"private subroutine bc_ghost_othervalues(elem2R, elem2I, faceR, faceI, bcdata, e2i_Mface_dir, e2r_Velocity_new, fr_Area_dir, fr_Velocity_dir, fr_HydDepth_dir, fr_Eta_dir) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) real, intent(in) :: faceR (:,:) integer, intent(in), target :: faceI (:,:) type(bcType), intent(in), target :: bcdata (:) integer, intent(in) :: e2i_Mface_dir integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: fr_Area_dir integer, intent(in) :: fr_Velocity_dir integer, intent(in) :: fr_HydDepth_dir integer, intent(in) :: fr_Eta_dir Called by proc~~bc_ghost_othervalues~~CalledByGraph proc~bc_ghost_othervalues bc_ghost_othervalues proc~bc_applied_onface bc_applied_onface proc~bc_applied_onface->proc~bc_ghost_othervalues proc~face_update face_update proc~face_update->proc~bc_applied_onface proc~explicit_test_advance explicit_test_advance proc~explicit_test_advance->proc~bc_applied_onface proc~explicit_euler_advance explicit_euler_advance proc~explicit_euler_advance->proc~bc_applied_onface proc~time_marching time_marching proc~time_marching->proc~bc_applied_onface proc~rk2 rk2 proc~time_marching->proc~rk2 program~main main program~main->proc~time_marching proc~initial_condition_setup initial_condition_setup program~main->proc~initial_condition_setup proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~face_update proc~initial_condition_setup->proc~face_update proc~rk2->proc~rk2_update_auxiliary_variables var panprocbc_ghost_othervaluesCalledByGraph = svgPanZoom('#procbc_ghost_othervaluesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"bc_ghost_othervalues – SWMMengine","tags":"","loc":"proc/bc_ghost_othervalues.html"},{"text":"public subroutine rk2(elem2R, elemMR, elem2I, elemMI, faceR, faceI, elem2YN, elemMYN, faceYN, bcdataDn, bcdataUp, thistime, dt) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(inout), target :: elem2I (:,:) integer, intent(inout), target :: elemMI (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(inout), target :: faceI (:,:) logical, intent(inout), target :: elem2YN (:,:) logical, intent(inout), target :: elemMYN (:,:) logical, intent(inout), target :: faceYN (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) real, intent(in) :: thistime real, intent(in) :: dt Calls proc~~rk2~~CallsGraph proc~rk2 rk2 e2r_temp e2r_temp proc~rk2->e2r_temp proc~diagnostic_element_volume_conservation_fluxes diagnostic_element_volume_conservation_fluxes proc~rk2->proc~diagnostic_element_volume_conservation_fluxes proc~utility_advance_temp_array utility_advance_temp_array proc~rk2->proc~utility_advance_temp_array proc~overwrite_old_values overwrite_old_values proc~rk2->proc~overwrite_old_values proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2->proc~rk2_update_auxiliary_variables proc~diagnostic_element_volume_conservation diagnostic_element_volume_conservation proc~rk2->proc~diagnostic_element_volume_conservation emr_temp emr_temp proc~rk2->emr_temp emi_mfacedn emi_mfacedn proc~diagnostic_element_volume_conservation_fluxes->emi_mfacedn emi_mfaceup emi_mfaceup proc~diagnostic_element_volume_conservation_fluxes->emi_mfaceup proc~element_dynamics_update element_dynamics_update proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~element_geometry_branch_fix element_geometry_branch_fix proc~rk2_update_auxiliary_variables->proc~element_geometry_branch_fix proc~face_update face_update proc~rk2_update_auxiliary_variables->proc~face_update proc~element_geometry_update element_geometry_update proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~adjust_vshaped_flowrate adjust_Vshaped_flowrate proc~rk2_update_auxiliary_variables->proc~adjust_vshaped_flowrate proc~bc_applied_onelement bc_applied_onelement proc~element_dynamics_update->proc~bc_applied_onelement proc~adjust_zero_velocity_at_zero_volume adjust_zero_velocity_at_zero_volume proc~element_dynamics_update->proc~adjust_zero_velocity_at_zero_volume proc~adjust_channel_velocity_limiter adjust_channel_velocity_limiter proc~element_dynamics_update->proc~adjust_channel_velocity_limiter proc~element_flowrate_update element_flowrate_update proc~element_dynamics_update->proc~element_flowrate_update proc~blended_smallvolume_velocity blended_smallvolume_velocity proc~element_dynamics_update->proc~blended_smallvolume_velocity proc~element_timescale element_timescale proc~element_dynamics_update->proc~element_timescale proc~element_geometry_branch_fix->proc~utility_advance_temp_array proc~element_geometry_branch_fix->emr_temp proc~rectangular_junction_leg rectangular_junction_leg proc~element_geometry_branch_fix->proc~rectangular_junction_leg proc~junction_branch_sum_areas_by_direction junction_branch_sum_areas_by_direction proc~element_geometry_branch_fix->proc~junction_branch_sum_areas_by_direction proc~adjust_junction_branch_velocity_limit adjust_junction_branch_velocity_limit proc~element_geometry_branch_fix->proc~adjust_junction_branch_velocity_limit proc~junction_branch_velocity_and_flowrate_proportional_to_area junction_branch_velocity_and_flowrate_proportional_to_area proc~element_geometry_branch_fix->proc~junction_branch_velocity_and_flowrate_proportional_to_area proc~face_hydraulic_jump face_hydraulic_jump proc~face_update->proc~face_hydraulic_jump proc~face_interp_for_upstreamchannel_to_downstreamjunction face_interp_for_upstreamchannel_to_downstreamjunction proc~face_update->proc~face_interp_for_upstreamchannel_to_downstreamjunction proc~face_interp_for_downstreamchannel_to_upstreamjunction face_interp_for_downstreamchannel_to_upstreamjunction proc~face_update->proc~face_interp_for_downstreamchannel_to_upstreamjunction proc~face_surface_elevation_interp face_surface_elevation_interp proc~face_update->proc~face_surface_elevation_interp proc~bc_applied_onface bc_applied_onface proc~face_update->proc~bc_applied_onface proc~face_bc_flowrate_update face_bc_flowrate_update proc~face_update->proc~face_bc_flowrate_update proc~face_interp_for_elem2 face_interp_for_elem2 proc~face_update->proc~face_interp_for_elem2 proc~element_geometry_update->proc~utility_advance_temp_array proc~element_geometry_update->emr_temp proc~element_geometry_update->proc~bc_applied_onelement proc~adjust_for_zero_geometry adjust_for_zero_geometry proc~element_geometry_update->proc~adjust_for_zero_geometry proc~rectangular_geometry_update rectangular_geometry_update proc~element_geometry_update->proc~rectangular_geometry_update proc~adjust_smallvolumes adjust_smallvolumes proc~element_geometry_update->proc~adjust_smallvolumes proc~adjust_vshaped_flowrate->e2r_temp proc~adjust_vshaped_flowrate->proc~utility_advance_temp_array proc~utility_sign_with_ones utility_sign_with_ones proc~adjust_vshaped_flowrate->proc~utility_sign_with_ones e2yn_temp e2yn_temp proc~adjust_vshaped_flowrate->e2yn_temp proc~bc_onelement bc_onelement proc~bc_applied_onelement->proc~bc_onelement proc~reset_juctionbranches_for_zero_values reset_juctionbranches_for_zero_values proc~adjust_for_zero_geometry->proc~reset_juctionbranches_for_zero_values proc~reset_element_for_zero_values reset_element_for_zero_values proc~adjust_for_zero_geometry->proc~reset_element_for_zero_values proc~face_hydraulic_jump->proc~utility_advance_temp_array fr_temp fr_temp proc~face_hydraulic_jump->fr_temp proc~zero_velocity_at_zero_volume zero_velocity_at_zero_volume proc~adjust_zero_velocity_at_zero_volume->proc~zero_velocity_at_zero_volume proc~rectangular_geometry_update->proc~rectangular_junction_leg proc~rectangular_channel_or_junction rectangular_channel_or_junction proc~rectangular_geometry_update->proc~rectangular_channel_or_junction emr_velocitydn emr_velocitydn proc~adjust_junction_branch_velocity_limit->emr_velocitydn emr_areadn emr_areadn proc~adjust_junction_branch_velocity_limit->emr_areadn emr_flowratedn emr_flowratedn proc~adjust_junction_branch_velocity_limit->emr_flowratedn emr_areaup emr_areaup proc~adjust_junction_branch_velocity_limit->emr_areaup emr_flowrateup emr_flowrateup proc~adjust_junction_branch_velocity_limit->emr_flowrateup emr_velocityup emr_velocityup proc~adjust_junction_branch_velocity_limit->emr_velocityup proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~utility_advance_temp_array proc~interp_with_junction_downstream interp_with_junction_downstream proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~interp_with_junction_downstream fyn_temp fyn_temp proc~face_interp_for_upstreamchannel_to_downstreamjunction->fyn_temp emr_timescaleup emr_timescaleup proc~face_interp_for_upstreamchannel_to_downstreamjunction->emr_timescaleup proc~face_interp_for_upstreamchannel_to_downstreamjunction->fr_temp proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~utility_advance_temp_array proc~face_interp_for_downstreamchannel_to_upstreamjunction->fyn_temp proc~face_interp_for_downstreamchannel_to_upstreamjunction->fr_temp emr_timescaledn emr_timescaledn proc~face_interp_for_downstreamchannel_to_upstreamjunction->emr_timescaledn proc~interp_with_junction_upstream interp_with_junction_upstream proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~interp_with_junction_upstream proc~element_flowrate_update->proc~utility_advance_temp_array proc~element_flowrate_update->emr_temp proc~element_flowrate_update->proc~junction_branch_sum_areas_by_direction proc~element_flowrate_update->proc~adjust_junction_branch_velocity_limit proc~element_flowrate_update->proc~junction_branch_velocity_and_flowrate_proportional_to_area proc~flowrate_from_velocity flowrate_from_velocity proc~element_flowrate_update->proc~flowrate_from_velocity proc~face_surface_elevation_interp->proc~utility_advance_temp_array emr_lengthdn emr_lengthdn proc~face_surface_elevation_interp->emr_lengthdn emr_lengthup emr_lengthup proc~face_surface_elevation_interp->emr_lengthup proc~face_surface_elevation_interp->fyn_temp proc~face_surface_elevation_interp->fr_temp proc~bc_onface bc_onface proc~bc_applied_onface->proc~bc_onface proc~bc_ghost_othervalues bc_ghost_othervalues proc~bc_applied_onface->proc~bc_ghost_othervalues proc~bc_face_othervalues bc_face_othervalues proc~bc_applied_onface->proc~bc_face_othervalues proc~face_bc_flowrate_update_onevalue face_bc_flowrate_update_onevalue proc~face_bc_flowrate_update->proc~face_bc_flowrate_update_onevalue proc~face_interp_for_elem2->proc~utility_advance_temp_array proc~face_interp_for_elem2->fyn_temp proc~face_interp_for_elem2->fr_temp proc~blended_smallvolume_velocity->emi_mfacedn proc~blended_smallvolume_velocity->emi_mfaceup proc~blended_smallvolume_velocity->emr_lengthdn proc~blended_smallvolume_velocity->emr_velocitydn proc~blended_smallvolume_velocity->emr_areadn proc~velocity_blend_with_mask velocity_blend_with_mask proc~blended_smallvolume_velocity->proc~velocity_blend_with_mask proc~blended_smallvolume_velocity->emr_lengthup proc~blended_smallvolume_velocity->emr_flowratedn proc~blended_smallvolume_velocity->emr_areaup proc~blended_smallvolume_velocity->emr_flowrateup proc~blended_smallvolume_velocity->emr_velocityup proc~smallvolume_identification smallvolume_identification proc~adjust_smallvolumes->proc~smallvolume_identification proc~smallvolume_geometry smallvolume_geometry proc~adjust_smallvolumes->proc~smallvolume_geometry proc~bc_timescale_value bc_timescale_value proc~element_timescale->proc~bc_timescale_value proc~timescale_value_junction timescale_value_junction proc~element_timescale->proc~timescale_value_junction proc~timescale_value_channel timescale_value_channel proc~element_timescale->proc~timescale_value_channel proc~bc_updatevalue bc_updatevalue proc~bc_onface->proc~bc_updatevalue proc~smallvolume_identification_for_element smallvolume_identification_for_element proc~smallvolume_identification->proc~smallvolume_identification_for_element proc~timescale_value_junction->proc~utility_advance_temp_array proc~timescale_value_junction->emr_temp proc~timescale_limit_junction_one_direction timescale_limit_junction_one_direction proc~timescale_value_junction->proc~timescale_limit_junction_one_direction proc~timescale_junction_one_direction timescale_junction_one_direction proc~timescale_value_junction->proc~timescale_junction_one_direction proc~linear_interpolation linear_interpolation proc~interp_with_junction_downstream->proc~linear_interpolation proc~velocity_blend_with_mask->proc~utility_advance_temp_array proc~velocity_blend velocity_blend proc~velocity_blend_with_mask->proc~velocity_blend proc~smallvolume_manningsn smallvolume_ManningsN proc~velocity_blend_with_mask->proc~smallvolume_manningsn proc~small_chezy_velocity small_chezy_velocity proc~velocity_blend_with_mask->proc~small_chezy_velocity proc~smallvolume_junctionbranch_reset smallvolume_junctionbranch_reset proc~smallvolume_geometry->proc~smallvolume_junctionbranch_reset proc~smallvolume_element_geometry_reset smallvolume_element_geometry_reset proc~smallvolume_geometry->proc~smallvolume_element_geometry_reset proc~bc_onelement->proc~bc_updatevalue proc~timescale_value_channel->e2r_temp proc~timescale_value_channel->proc~utility_advance_temp_array proc~timescale_value_channel->e2yn_temp proc~timescale_limiter timescale_limiter proc~timescale_value_channel->proc~timescale_limiter proc~interp_with_junction_upstream->proc~linear_interpolation proc~timescale_limit_junction_one_direction->proc~utility_advance_temp_array proc~timescale_limit_junction_one_direction->proc~timescale_limiter emyn_temp emyn_temp proc~timescale_limit_junction_one_direction->emyn_temp proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist proc~apply_limiter_with_mask apply_limiter_with_mask proc~timescale_limiter->proc~apply_limiter_with_mask var panprocrk2CallsGraph = svgPanZoom('#procrk2CallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rk2~~CalledByGraph proc~rk2 rk2 proc~time_marching time_marching proc~time_marching->proc~rk2 program~main main program~main->proc~time_marching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"rk2 – SWMMengine","tags":"","loc":"proc/rk2.html"},{"text":"private subroutine sve_rk2_step(e2r_Volume_old, e2r_Velocity_old, eMr_Volume_old, eMr_Velocity_old, e2r_Volume_new, e2r_Velocity_new, eMr_Volume_new, eMr_Velocity_new, elem2R, elemMR, faceR, elem2I, elemMI, elem2YN, elemMYN, thiscoef) Arguments Type Intent Optional Attributes Name integer, intent(in) :: e2r_Volume_old integer, intent(in) :: e2r_Velocity_old integer, intent(in) :: eMr_Volume_old integer, intent(in) :: eMr_Velocity_old integer, intent(in) :: e2r_Volume_new integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: eMr_Volume_new integer, intent(in) :: eMr_Velocity_new real, intent(inout), target :: elem2R (:,:) real, intent(inout), target :: elemMR (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in), target :: elem2I (:,:) integer, intent(in), target :: elemMI (:,:) logical, intent(inout) :: elem2YN (:,:) logical, intent(inout) :: elemMYN (:,:) real, intent(in) :: thiscoef Calls proc~~sve_rk2_step~~CallsGraph proc~sve_rk2_step sve_rk2_step emi_mfacedn emi_mfacedn proc~sve_rk2_step->emi_mfacedn emi_mfaceup emi_mfaceup proc~sve_rk2_step->emi_mfaceup e2r_temp e2r_temp proc~sve_rk2_step->e2r_temp proc~utility_advance_temp_array utility_advance_temp_array proc~sve_rk2_step->proc~utility_advance_temp_array emr_temp emr_temp proc~sve_rk2_step->emr_temp proc~adjust_negative_volume_reset adjust_negative_volume_reset proc~sve_rk2_step->proc~adjust_negative_volume_reset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"sve_rk2_step – SWMMengine","tags":"","loc":"proc/sve_rk2_step.html"},{"text":"private subroutine rk2_update_auxiliary_variables(e2r_Velocity_new, eMr_Velocity_new, e2r_Volume_new, eMr_Volume_new, elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, faceI, faceYN, bcdataDn, bcdataUp, steptime, rkiteration) Arguments Type Intent Optional Attributes Name integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: eMr_Velocity_new integer, intent(in) :: e2r_Volume_new integer, intent(in) :: eMr_Volume_new real, intent(inout) :: elem2R (:,:) integer, intent(inout) :: elem2I (:,:) logical, intent(inout) :: elem2YN (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(inout) :: elemMI (:,:) logical, intent(inout) :: elemMYN (:,:) real, intent(inout) :: faceR (:,:) integer, intent(inout) :: faceI (:,:) logical, intent(inout) :: faceYN (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) real, intent(in) :: steptime integer, intent(in) :: rkiteration Calls proc~~rk2_update_auxiliary_variables~~CallsGraph proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~element_dynamics_update element_dynamics_update proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~adjust_vshaped_flowrate adjust_Vshaped_flowrate proc~rk2_update_auxiliary_variables->proc~adjust_vshaped_flowrate proc~element_geometry_update element_geometry_update proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~face_update face_update proc~rk2_update_auxiliary_variables->proc~face_update proc~element_geometry_branch_fix element_geometry_branch_fix proc~rk2_update_auxiliary_variables->proc~element_geometry_branch_fix proc~bc_applied_onelement bc_applied_onelement proc~element_dynamics_update->proc~bc_applied_onelement proc~adjust_zero_velocity_at_zero_volume adjust_zero_velocity_at_zero_volume proc~element_dynamics_update->proc~adjust_zero_velocity_at_zero_volume proc~adjust_channel_velocity_limiter adjust_channel_velocity_limiter proc~element_dynamics_update->proc~adjust_channel_velocity_limiter proc~element_flowrate_update element_flowrate_update proc~element_dynamics_update->proc~element_flowrate_update proc~blended_smallvolume_velocity blended_smallvolume_velocity proc~element_dynamics_update->proc~blended_smallvolume_velocity proc~element_timescale element_timescale proc~element_dynamics_update->proc~element_timescale proc~utility_sign_with_ones utility_sign_with_ones proc~adjust_vshaped_flowrate->proc~utility_sign_with_ones e2yn_temp e2yn_temp proc~adjust_vshaped_flowrate->e2yn_temp e2r_temp e2r_temp proc~adjust_vshaped_flowrate->e2r_temp proc~utility_advance_temp_array utility_advance_temp_array proc~adjust_vshaped_flowrate->proc~utility_advance_temp_array proc~element_geometry_update->proc~bc_applied_onelement proc~adjust_for_zero_geometry adjust_for_zero_geometry proc~element_geometry_update->proc~adjust_for_zero_geometry proc~rectangular_geometry_update rectangular_geometry_update proc~element_geometry_update->proc~rectangular_geometry_update emr_temp emr_temp proc~element_geometry_update->emr_temp proc~element_geometry_update->proc~utility_advance_temp_array proc~adjust_smallvolumes adjust_smallvolumes proc~element_geometry_update->proc~adjust_smallvolumes proc~face_hydraulic_jump face_hydraulic_jump proc~face_update->proc~face_hydraulic_jump proc~face_interp_for_downstreamchannel_to_upstreamjunction face_interp_for_downstreamchannel_to_upstreamjunction proc~face_update->proc~face_interp_for_downstreamchannel_to_upstreamjunction proc~face_interp_for_upstreamchannel_to_downstreamjunction face_interp_for_upstreamchannel_to_downstreamjunction proc~face_update->proc~face_interp_for_upstreamchannel_to_downstreamjunction proc~face_surface_elevation_interp face_surface_elevation_interp proc~face_update->proc~face_surface_elevation_interp proc~bc_applied_onface bc_applied_onface proc~face_update->proc~bc_applied_onface proc~face_bc_flowrate_update face_bc_flowrate_update proc~face_update->proc~face_bc_flowrate_update proc~face_interp_for_elem2 face_interp_for_elem2 proc~face_update->proc~face_interp_for_elem2 proc~rectangular_junction_leg rectangular_junction_leg proc~element_geometry_branch_fix->proc~rectangular_junction_leg proc~junction_branch_sum_areas_by_direction junction_branch_sum_areas_by_direction proc~element_geometry_branch_fix->proc~junction_branch_sum_areas_by_direction proc~adjust_junction_branch_velocity_limit adjust_junction_branch_velocity_limit proc~element_geometry_branch_fix->proc~adjust_junction_branch_velocity_limit proc~element_geometry_branch_fix->emr_temp proc~junction_branch_velocity_and_flowrate_proportional_to_area junction_branch_velocity_and_flowrate_proportional_to_area proc~element_geometry_branch_fix->proc~junction_branch_velocity_and_flowrate_proportional_to_area proc~element_geometry_branch_fix->proc~utility_advance_temp_array proc~bc_onelement bc_onelement proc~bc_applied_onelement->proc~bc_onelement proc~reset_juctionbranches_for_zero_values reset_juctionbranches_for_zero_values proc~adjust_for_zero_geometry->proc~reset_juctionbranches_for_zero_values proc~reset_element_for_zero_values reset_element_for_zero_values proc~adjust_for_zero_geometry->proc~reset_element_for_zero_values proc~face_hydraulic_jump->proc~utility_advance_temp_array fr_temp fr_temp proc~face_hydraulic_jump->fr_temp proc~zero_velocity_at_zero_volume zero_velocity_at_zero_volume proc~adjust_zero_velocity_at_zero_volume->proc~zero_velocity_at_zero_volume proc~rectangular_geometry_update->proc~rectangular_junction_leg proc~rectangular_channel_or_junction rectangular_channel_or_junction proc~rectangular_geometry_update->proc~rectangular_channel_or_junction emr_velocitydn emr_velocitydn proc~adjust_junction_branch_velocity_limit->emr_velocitydn emr_areadn emr_areadn proc~adjust_junction_branch_velocity_limit->emr_areadn emr_flowratedn emr_flowratedn proc~adjust_junction_branch_velocity_limit->emr_flowratedn emr_areaup emr_areaup proc~adjust_junction_branch_velocity_limit->emr_areaup emr_flowrateup emr_flowrateup proc~adjust_junction_branch_velocity_limit->emr_flowrateup emr_velocityup emr_velocityup proc~adjust_junction_branch_velocity_limit->emr_velocityup proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~utility_advance_temp_array fyn_temp fyn_temp proc~face_interp_for_downstreamchannel_to_upstreamjunction->fyn_temp proc~face_interp_for_downstreamchannel_to_upstreamjunction->fr_temp emr_timescaledn emr_timescaledn proc~face_interp_for_downstreamchannel_to_upstreamjunction->emr_timescaledn proc~interp_with_junction_upstream interp_with_junction_upstream proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~interp_with_junction_upstream proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~utility_advance_temp_array proc~interp_with_junction_downstream interp_with_junction_downstream proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~interp_with_junction_downstream proc~face_interp_for_upstreamchannel_to_downstreamjunction->fyn_temp emr_timescaleup emr_timescaleup proc~face_interp_for_upstreamchannel_to_downstreamjunction->emr_timescaleup proc~face_interp_for_upstreamchannel_to_downstreamjunction->fr_temp proc~element_flowrate_update->proc~junction_branch_sum_areas_by_direction proc~element_flowrate_update->proc~adjust_junction_branch_velocity_limit proc~element_flowrate_update->emr_temp proc~element_flowrate_update->proc~junction_branch_velocity_and_flowrate_proportional_to_area proc~element_flowrate_update->proc~utility_advance_temp_array proc~flowrate_from_velocity flowrate_from_velocity proc~element_flowrate_update->proc~flowrate_from_velocity proc~face_surface_elevation_interp->proc~utility_advance_temp_array emr_lengthdn emr_lengthdn proc~face_surface_elevation_interp->emr_lengthdn emr_lengthup emr_lengthup proc~face_surface_elevation_interp->emr_lengthup proc~face_surface_elevation_interp->fyn_temp proc~face_surface_elevation_interp->fr_temp proc~bc_onface bc_onface proc~bc_applied_onface->proc~bc_onface proc~bc_ghost_othervalues bc_ghost_othervalues proc~bc_applied_onface->proc~bc_ghost_othervalues proc~bc_face_othervalues bc_face_othervalues proc~bc_applied_onface->proc~bc_face_othervalues proc~face_bc_flowrate_update_onevalue face_bc_flowrate_update_onevalue proc~face_bc_flowrate_update->proc~face_bc_flowrate_update_onevalue proc~face_interp_for_elem2->proc~utility_advance_temp_array proc~face_interp_for_elem2->fyn_temp proc~face_interp_for_elem2->fr_temp emi_mfaceup emi_mfaceup proc~blended_smallvolume_velocity->emi_mfaceup proc~blended_smallvolume_velocity->emr_lengthdn proc~blended_smallvolume_velocity->emr_velocitydn proc~blended_smallvolume_velocity->emr_areadn proc~velocity_blend_with_mask velocity_blend_with_mask proc~blended_smallvolume_velocity->proc~velocity_blend_with_mask proc~blended_smallvolume_velocity->emr_lengthup proc~blended_smallvolume_velocity->emr_flowratedn proc~blended_smallvolume_velocity->emr_areaup emi_mfacedn emi_mfacedn proc~blended_smallvolume_velocity->emi_mfacedn proc~blended_smallvolume_velocity->emr_flowrateup proc~blended_smallvolume_velocity->emr_velocityup proc~smallvolume_identification smallvolume_identification proc~adjust_smallvolumes->proc~smallvolume_identification proc~smallvolume_geometry smallvolume_geometry proc~adjust_smallvolumes->proc~smallvolume_geometry proc~bc_timescale_value bc_timescale_value proc~element_timescale->proc~bc_timescale_value proc~timescale_value_junction timescale_value_junction proc~element_timescale->proc~timescale_value_junction proc~timescale_value_channel timescale_value_channel proc~element_timescale->proc~timescale_value_channel proc~bc_updatevalue bc_updatevalue proc~bc_onface->proc~bc_updatevalue proc~smallvolume_identification_for_element smallvolume_identification_for_element proc~smallvolume_identification->proc~smallvolume_identification_for_element proc~timescale_value_junction->emr_temp proc~timescale_value_junction->proc~utility_advance_temp_array proc~timescale_limit_junction_one_direction timescale_limit_junction_one_direction proc~timescale_value_junction->proc~timescale_limit_junction_one_direction proc~timescale_junction_one_direction timescale_junction_one_direction proc~timescale_value_junction->proc~timescale_junction_one_direction proc~linear_interpolation linear_interpolation proc~interp_with_junction_downstream->proc~linear_interpolation proc~velocity_blend_with_mask->proc~utility_advance_temp_array proc~velocity_blend velocity_blend proc~velocity_blend_with_mask->proc~velocity_blend proc~smallvolume_manningsn smallvolume_ManningsN proc~velocity_blend_with_mask->proc~smallvolume_manningsn proc~small_chezy_velocity small_chezy_velocity proc~velocity_blend_with_mask->proc~small_chezy_velocity proc~smallvolume_junctionbranch_reset smallvolume_junctionbranch_reset proc~smallvolume_geometry->proc~smallvolume_junctionbranch_reset proc~smallvolume_element_geometry_reset smallvolume_element_geometry_reset proc~smallvolume_geometry->proc~smallvolume_element_geometry_reset proc~bc_onelement->proc~bc_updatevalue proc~timescale_value_channel->e2yn_temp proc~timescale_value_channel->e2r_temp proc~timescale_value_channel->proc~utility_advance_temp_array proc~timescale_limiter timescale_limiter proc~timescale_value_channel->proc~timescale_limiter proc~interp_with_junction_upstream->proc~linear_interpolation proc~timescale_limit_junction_one_direction->proc~utility_advance_temp_array proc~timescale_limit_junction_one_direction->proc~timescale_limiter emyn_temp emyn_temp proc~timescale_limit_junction_one_direction->emyn_temp proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist proc~apply_limiter_with_mask apply_limiter_with_mask proc~timescale_limiter->proc~apply_limiter_with_mask var panprocrk2_update_auxiliary_variablesCallsGraph = svgPanZoom('#procrk2_update_auxiliary_variablesCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rk2_update_auxiliary_variables~~CalledByGraph proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching time_marching proc~time_marching->proc~rk2 program~main main program~main->proc~time_marching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"rk2_update_auxiliary_variables – SWMMengine","tags":"","loc":"proc/rk2_update_auxiliary_variables.html"},{"text":"private subroutine overwrite_old_values(elemR, elemI, er_Velocity, er_Velocity_new, er_Volume, er_Volume_new, ei_elem_type, ThisElemType, overwriteGhost) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elemR (:,:) integer, intent(in) :: elemI (:,:) integer, intent(in) :: er_Velocity integer, intent(in) :: er_Velocity_new integer, intent(in) :: er_Volume integer, intent(in) :: er_Volume_new integer, intent(in) :: ei_elem_type integer, intent(in) :: ThisElemType logical, intent(in) :: overwriteGhost Called by proc~~overwrite_old_values~~CalledByGraph proc~overwrite_old_values overwrite_old_values proc~rk2 rk2 proc~rk2->proc~overwrite_old_values proc~time_marching time_marching proc~time_marching->proc~rk2 program~main main program~main->proc~time_marching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"overwrite_old_values – SWMMengine","tags":"","loc":"proc/overwrite_old_values.html"},{"text":"public subroutine time_marching(elem2R, elemMR, faceR, elem2I, elemMI, faceI, elem2YN, elemMYN, faceYN, bcdataDn, bcdataUp, linkI, debugfile, diagnostic, threadedfile) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) real, intent(inout), target :: elemMR (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(inout), target :: elem2I (:,:) integer, intent(inout), target :: elemMI (:,:) integer, intent(inout), target :: faceI (:,:) logical, intent(inout), target :: elem2YN (:,:) logical, intent(inout), target :: elemMYN (:,:) logical, intent(inout), target :: faceYN (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) integer, intent(in) :: linkI (:,:) type(debugfileType), intent(in), target :: debugfile (:) type(diagnosticType), intent(inout), target :: diagnostic (:) type(threadedfileType), intent(in) :: threadedfile (:) Calls proc~~time_marching~~CallsGraph proc~time_marching time_marching proc~bc_applied_onelement bc_applied_onelement proc~time_marching->proc~bc_applied_onelement proc~diagnostic_volume_conservation diagnostic_volume_conservation proc~time_marching->proc~diagnostic_volume_conservation proc~diagnostic_cfl diagnostic_CFL proc~time_marching->proc~diagnostic_cfl proc~bc_applied_onface bc_applied_onface proc~time_marching->proc~bc_applied_onface proc~rk2 rk2 proc~time_marching->proc~rk2 proc~debug_output debug_output proc~time_marching->proc~debug_output proc~output_all_threaded_data_by_link output_all_threaded_data_by_link proc~time_marching->proc~output_all_threaded_data_by_link proc~diagnostic_froude_number diagnostic_froude_number proc~time_marching->proc~diagnostic_froude_number proc~bc_onelement bc_onelement proc~bc_applied_onelement->proc~bc_onelement proc~total_inout_flowrate total_inout_flowrate proc~diagnostic_volume_conservation->proc~total_inout_flowrate proc~bc_onface bc_onface proc~bc_applied_onface->proc~bc_onface proc~bc_face_othervalues bc_face_othervalues proc~bc_applied_onface->proc~bc_face_othervalues proc~bc_ghost_othervalues bc_ghost_othervalues proc~bc_applied_onface->proc~bc_ghost_othervalues e2r_temp e2r_temp proc~rk2->e2r_temp proc~diagnostic_element_volume_conservation_fluxes diagnostic_element_volume_conservation_fluxes proc~rk2->proc~diagnostic_element_volume_conservation_fluxes proc~utility_advance_temp_array utility_advance_temp_array proc~rk2->proc~utility_advance_temp_array proc~overwrite_old_values overwrite_old_values proc~rk2->proc~overwrite_old_values proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2->proc~rk2_update_auxiliary_variables proc~diagnostic_element_volume_conservation diagnostic_element_volume_conservation proc~rk2->proc~diagnostic_element_volume_conservation emr_temp emr_temp proc~rk2->emr_temp proc~output_one_threaded_data_by_link output_one_threaded_data_by_link proc~output_all_threaded_data_by_link->proc~output_one_threaded_data_by_link proc~diagnostic_froude_number_one diagnostic_froude_number_one proc~diagnostic_froude_number->proc~diagnostic_froude_number_one emi_mfacedn emi_mfacedn proc~diagnostic_element_volume_conservation_fluxes->emi_mfacedn emi_mfaceup emi_mfaceup proc~diagnostic_element_volume_conservation_fluxes->emi_mfaceup proc~bc_updatevalue bc_updatevalue proc~bc_onface->proc~bc_updatevalue proc~inout_flowrate_from_bcdata inout_flowrate_from_bcdata proc~total_inout_flowrate->proc~inout_flowrate_from_bcdata proc~utility_check_allocation utility_check_allocation proc~output_one_threaded_data_by_link->proc~utility_check_allocation emr_lengthdn emr_lengthdn proc~output_one_threaded_data_by_link->emr_lengthdn emr_lengthup emr_lengthup proc~output_one_threaded_data_by_link->emr_lengthup proc~element_dynamics_update element_dynamics_update proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~element_geometry_branch_fix element_geometry_branch_fix proc~rk2_update_auxiliary_variables->proc~element_geometry_branch_fix proc~face_update face_update proc~rk2_update_auxiliary_variables->proc~face_update proc~element_geometry_update element_geometry_update proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~adjust_vshaped_flowrate adjust_Vshaped_flowrate proc~rk2_update_auxiliary_variables->proc~adjust_vshaped_flowrate proc~bc_onelement->proc~bc_updatevalue proc~element_dynamics_update->proc~bc_applied_onelement proc~adjust_zero_velocity_at_zero_volume adjust_zero_velocity_at_zero_volume proc~element_dynamics_update->proc~adjust_zero_velocity_at_zero_volume proc~adjust_channel_velocity_limiter adjust_channel_velocity_limiter proc~element_dynamics_update->proc~adjust_channel_velocity_limiter proc~blended_smallvolume_velocity blended_smallvolume_velocity proc~element_dynamics_update->proc~blended_smallvolume_velocity proc~element_flowrate_update element_flowrate_update proc~element_dynamics_update->proc~element_flowrate_update proc~element_timescale element_timescale proc~element_dynamics_update->proc~element_timescale proc~element_geometry_branch_fix->proc~utility_advance_temp_array proc~element_geometry_branch_fix->emr_temp proc~rectangular_junction_leg rectangular_junction_leg proc~element_geometry_branch_fix->proc~rectangular_junction_leg proc~adjust_junction_branch_velocity_limit adjust_junction_branch_velocity_limit proc~element_geometry_branch_fix->proc~adjust_junction_branch_velocity_limit proc~junction_branch_sum_areas_by_direction junction_branch_sum_areas_by_direction proc~element_geometry_branch_fix->proc~junction_branch_sum_areas_by_direction proc~junction_branch_velocity_and_flowrate_proportional_to_area junction_branch_velocity_and_flowrate_proportional_to_area proc~element_geometry_branch_fix->proc~junction_branch_velocity_and_flowrate_proportional_to_area proc~face_update->proc~bc_applied_onface proc~face_surface_elevation_interp face_surface_elevation_interp proc~face_update->proc~face_surface_elevation_interp proc~face_hydraulic_jump face_hydraulic_jump proc~face_update->proc~face_hydraulic_jump proc~face_bc_flowrate_update face_bc_flowrate_update proc~face_update->proc~face_bc_flowrate_update proc~face_interp_for_elem2 face_interp_for_elem2 proc~face_update->proc~face_interp_for_elem2 proc~face_interp_for_upstreamchannel_to_downstreamjunction face_interp_for_upstreamchannel_to_downstreamjunction proc~face_update->proc~face_interp_for_upstreamchannel_to_downstreamjunction proc~face_interp_for_downstreamchannel_to_upstreamjunction face_interp_for_downstreamchannel_to_upstreamjunction proc~face_update->proc~face_interp_for_downstreamchannel_to_upstreamjunction proc~element_geometry_update->proc~bc_applied_onelement proc~element_geometry_update->proc~utility_advance_temp_array proc~element_geometry_update->emr_temp proc~adjust_for_zero_geometry adjust_for_zero_geometry proc~element_geometry_update->proc~adjust_for_zero_geometry proc~adjust_smallvolumes adjust_smallvolumes proc~element_geometry_update->proc~adjust_smallvolumes proc~rectangular_geometry_update rectangular_geometry_update proc~element_geometry_update->proc~rectangular_geometry_update proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist proc~adjust_vshaped_flowrate->e2r_temp proc~adjust_vshaped_flowrate->proc~utility_advance_temp_array e2yn_temp e2yn_temp proc~adjust_vshaped_flowrate->e2yn_temp proc~utility_sign_with_ones utility_sign_with_ones proc~adjust_vshaped_flowrate->proc~utility_sign_with_ones proc~reset_juctionbranches_for_zero_values reset_juctionbranches_for_zero_values proc~adjust_for_zero_geometry->proc~reset_juctionbranches_for_zero_values proc~reset_element_for_zero_values reset_element_for_zero_values proc~adjust_for_zero_geometry->proc~reset_element_for_zero_values proc~zero_velocity_at_zero_volume zero_velocity_at_zero_volume proc~adjust_zero_velocity_at_zero_volume->proc~zero_velocity_at_zero_volume proc~face_surface_elevation_interp->proc~utility_advance_temp_array proc~face_surface_elevation_interp->emr_lengthdn proc~face_surface_elevation_interp->emr_lengthup fyn_temp fyn_temp proc~face_surface_elevation_interp->fyn_temp fr_temp fr_temp proc~face_surface_elevation_interp->fr_temp proc~face_hydraulic_jump->proc~utility_advance_temp_array proc~face_hydraulic_jump->fr_temp proc~smallvolume_identification smallvolume_identification proc~adjust_smallvolumes->proc~smallvolume_identification proc~smallvolume_geometry smallvolume_geometry proc~adjust_smallvolumes->proc~smallvolume_geometry proc~rectangular_geometry_update->proc~rectangular_junction_leg proc~rectangular_channel_or_junction rectangular_channel_or_junction proc~rectangular_geometry_update->proc~rectangular_channel_or_junction proc~face_bc_flowrate_update_onevalue face_bc_flowrate_update_onevalue proc~face_bc_flowrate_update->proc~face_bc_flowrate_update_onevalue emr_velocitydn emr_velocitydn proc~adjust_junction_branch_velocity_limit->emr_velocitydn emr_areadn emr_areadn proc~adjust_junction_branch_velocity_limit->emr_areadn emr_flowratedn emr_flowratedn proc~adjust_junction_branch_velocity_limit->emr_flowratedn emr_areaup emr_areaup proc~adjust_junction_branch_velocity_limit->emr_areaup emr_flowrateup emr_flowrateup proc~adjust_junction_branch_velocity_limit->emr_flowrateup emr_velocityup emr_velocityup proc~adjust_junction_branch_velocity_limit->emr_velocityup proc~face_interp_for_elem2->proc~utility_advance_temp_array proc~face_interp_for_elem2->fyn_temp proc~face_interp_for_elem2->fr_temp proc~blended_smallvolume_velocity->emi_mfacedn proc~blended_smallvolume_velocity->emi_mfaceup proc~blended_smallvolume_velocity->emr_lengthdn proc~blended_smallvolume_velocity->emr_lengthup proc~blended_smallvolume_velocity->emr_velocitydn proc~blended_smallvolume_velocity->emr_areadn proc~velocity_blend_with_mask velocity_blend_with_mask proc~blended_smallvolume_velocity->proc~velocity_blend_with_mask proc~blended_smallvolume_velocity->emr_flowratedn proc~blended_smallvolume_velocity->emr_areaup proc~blended_smallvolume_velocity->emr_flowrateup proc~blended_smallvolume_velocity->emr_velocityup proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~utility_advance_temp_array proc~interp_with_junction_downstream interp_with_junction_downstream proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~interp_with_junction_downstream proc~face_interp_for_upstreamchannel_to_downstreamjunction->fyn_temp emr_timescaleup emr_timescaleup proc~face_interp_for_upstreamchannel_to_downstreamjunction->emr_timescaleup proc~face_interp_for_upstreamchannel_to_downstreamjunction->fr_temp proc~element_flowrate_update->proc~utility_advance_temp_array proc~element_flowrate_update->emr_temp proc~element_flowrate_update->proc~adjust_junction_branch_velocity_limit proc~element_flowrate_update->proc~junction_branch_sum_areas_by_direction proc~element_flowrate_update->proc~junction_branch_velocity_and_flowrate_proportional_to_area proc~flowrate_from_velocity flowrate_from_velocity proc~element_flowrate_update->proc~flowrate_from_velocity proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~utility_advance_temp_array proc~face_interp_for_downstreamchannel_to_upstreamjunction->fyn_temp proc~face_interp_for_downstreamchannel_to_upstreamjunction->fr_temp emr_timescaledn emr_timescaledn proc~face_interp_for_downstreamchannel_to_upstreamjunction->emr_timescaledn proc~interp_with_junction_upstream interp_with_junction_upstream proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~interp_with_junction_upstream proc~bc_timescale_value bc_timescale_value proc~element_timescale->proc~bc_timescale_value proc~timescale_value_junction timescale_value_junction proc~element_timescale->proc~timescale_value_junction proc~timescale_value_channel timescale_value_channel proc~element_timescale->proc~timescale_value_channel proc~smallvolume_identification_for_element smallvolume_identification_for_element proc~smallvolume_identification->proc~smallvolume_identification_for_element proc~timescale_value_junction->proc~utility_advance_temp_array proc~timescale_value_junction->emr_temp proc~timescale_limit_junction_one_direction timescale_limit_junction_one_direction proc~timescale_value_junction->proc~timescale_limit_junction_one_direction proc~timescale_junction_one_direction timescale_junction_one_direction proc~timescale_value_junction->proc~timescale_junction_one_direction proc~linear_interpolation linear_interpolation proc~interp_with_junction_downstream->proc~linear_interpolation proc~velocity_blend_with_mask->proc~utility_advance_temp_array proc~velocity_blend velocity_blend proc~velocity_blend_with_mask->proc~velocity_blend proc~smallvolume_manningsn smallvolume_ManningsN proc~velocity_blend_with_mask->proc~smallvolume_manningsn proc~small_chezy_velocity small_chezy_velocity proc~velocity_blend_with_mask->proc~small_chezy_velocity proc~smallvolume_junctionbranch_reset smallvolume_junctionbranch_reset proc~smallvolume_geometry->proc~smallvolume_junctionbranch_reset proc~smallvolume_element_geometry_reset smallvolume_element_geometry_reset proc~smallvolume_geometry->proc~smallvolume_element_geometry_reset proc~timescale_value_channel->e2r_temp proc~timescale_value_channel->proc~utility_advance_temp_array proc~timescale_value_channel->e2yn_temp proc~timescale_limiter timescale_limiter proc~timescale_value_channel->proc~timescale_limiter proc~interp_with_junction_upstream->proc~linear_interpolation proc~timescale_limit_junction_one_direction->proc~utility_advance_temp_array proc~timescale_limit_junction_one_direction->proc~timescale_limiter emyn_temp emyn_temp proc~timescale_limit_junction_one_direction->emyn_temp proc~apply_limiter_with_mask apply_limiter_with_mask proc~timescale_limiter->proc~apply_limiter_with_mask var panproctime_marchingCallsGraph = svgPanZoom('#proctime_marchingCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~time_marching~~CalledByGraph proc~time_marching time_marching program~main main program~main->proc~time_marching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"time_marching – SWMMengine","tags":"","loc":"proc/time_marching.html"},{"text":"public subroutine debug_initialize(debugfile) Arguments Type Intent Optional Attributes Name type(debugfileType), intent(out), dimension(:), allocatable :: debugfile Calls proc~~debug_initialize~~CallsGraph proc~debug_initialize debug_initialize proc~utility_check_allocation utility_check_allocation proc~debug_initialize->proc~utility_check_allocation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~debug_initialize~~CalledByGraph proc~debug_initialize debug_initialize program~main main program~main->proc~debug_initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"debug_initialize – SWMMengine","tags":"","loc":"proc/debug_initialize.html"},{"text":"public subroutine debug_output(debugfile, elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, faceI, faceYN, bcdataUp, bcdataDn, thisstep) Arguments Type Intent Optional Attributes Name type(debugfileType), intent(in), target :: debugfile (:) real, intent(in), target :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) logical, intent(in), target :: elem2YN (:,:) real, intent(in), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) logical, intent(in), target :: elemMYN (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in), target :: faceI (:,:) logical, intent(in), target :: faceYN (:,:) type(bcType), intent(in) :: bcdataUp (:) type(bcType), intent(in) :: bcdataDn (:) integer, intent(in) :: thisstep Called by proc~~debug_output~~CalledByGraph proc~debug_output debug_output proc~time_marching time_marching proc~time_marching->proc~debug_output program~main main program~main->proc~time_marching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"debug_output – SWMMengine","tags":"","loc":"proc/debug_output.html"},{"text":"public subroutine debug_finalize(debugfile) Arguments Type Intent Optional Attributes Name type(debugfileType), intent(inout) :: debugfile (:) Called by proc~~debug_finalize~~CalledByGraph proc~debug_finalize debug_finalize program~main main program~main->proc~debug_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"debug_finalize – SWMMengine","tags":"","loc":"proc/debug_finalize.html"},{"text":"private subroutine debug_singlefile_open(debugfile, ArrayName, DataName, ColumnIndex) Arguments Type Intent Optional Attributes Name type(debugfileType), intent(inout) :: debugfile character(len=*), intent(in) :: ArrayName character(len=*), intent(in) :: DataName integer, intent(in) :: ColumnIndex Calls proc~~debug_singlefile_open~~CallsGraph proc~debug_singlefile_open debug_singlefile_open proc~utility_check_fileopen utility_check_fileopen proc~debug_singlefile_open->proc~utility_check_fileopen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"debug_singlefile_open – SWMMengine","tags":"","loc":"proc/debug_singlefile_open.html"},{"text":"private subroutine x() Arguments None Contents None","title":"x – SWMMengine","tags":"","loc":"proc/x.html"},{"text":"public subroutine adjust_channel_velocity_limiter(elemR, elemYN, elemI, ei_elem_type, elemType, eYN_IsAdhocFlowrate, er_Velocity_new) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) logical, intent(inout) :: elemYN (:,:) integer, intent(in) :: elemI (:,:) integer, intent(in) :: ei_elem_type integer, intent(in) :: elemType integer, intent(in) :: eYN_IsAdhocFlowrate integer, intent(in) :: er_Velocity_new Called by proc~~adjust_channel_velocity_limiter~~CalledByGraph proc~adjust_channel_velocity_limiter adjust_channel_velocity_limiter proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~adjust_channel_velocity_limiter proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocadjust_channel_velocity_limiterCalledByGraph = svgPanZoom('#procadjust_channel_velocity_limiterCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"adjust_channel_velocity_limiter – SWMMengine","tags":"","loc":"proc/adjust_channel_velocity_limiter.html"},{"text":"public subroutine adjust_junction_branch_velocity_limit(elemMR, elemMI) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) Calls proc~~adjust_junction_branch_velocity_limit~~CallsGraph proc~adjust_junction_branch_velocity_limit adjust_junction_branch_velocity_limit emr_flowratedn emr_flowratedn proc~adjust_junction_branch_velocity_limit->emr_flowratedn emr_flowrateup emr_flowrateup proc~adjust_junction_branch_velocity_limit->emr_flowrateup emr_velocityup emr_velocityup proc~adjust_junction_branch_velocity_limit->emr_velocityup emr_velocitydn emr_velocitydn proc~adjust_junction_branch_velocity_limit->emr_velocitydn emr_areadn emr_areadn proc~adjust_junction_branch_velocity_limit->emr_areadn emr_areaup emr_areaup proc~adjust_junction_branch_velocity_limit->emr_areaup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~adjust_junction_branch_velocity_limit~~CalledByGraph proc~adjust_junction_branch_velocity_limit adjust_junction_branch_velocity_limit proc~element_flowrate_update element_flowrate_update proc~element_flowrate_update->proc~adjust_junction_branch_velocity_limit proc~element_geometry_branch_fix element_geometry_branch_fix proc~element_geometry_branch_fix->proc~adjust_junction_branch_velocity_limit proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~element_flowrate_update proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_branch_fix proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~time_marching->proc~rk2 var panprocadjust_junction_branch_velocity_limitCalledByGraph = svgPanZoom('#procadjust_junction_branch_velocity_limitCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"adjust_junction_branch_velocity_limit – SWMMengine","tags":"","loc":"proc/adjust_junction_branch_velocity_limit.html"},{"text":"public subroutine adjust_face_dynamic_limits(faceR, faceI, volumeUp, volumeDn, facemask, Ltemp) Arguments Type Intent Optional Attributes Name real, intent(inout) :: faceR (:,:) integer, intent(in), target :: faceI (:,:) real, intent(in) :: volumeUp (:) real, intent(in) :: volumeDn (:) logical, intent(in) :: facemask (:) logical, intent(in) :: Ltemp Contents None","title":"adjust_face_dynamic_limits – SWMMengine","tags":"","loc":"proc/adjust_face_dynamic_limits.html"},{"text":"public subroutine adjust_for_zero_geometry(elem2R, elem2YN, elemMR, elemMI, elemMYN) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) logical, intent(in) :: elem2YN (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) logical, intent(in) :: elemMYN (:,:) Calls proc~~adjust_for_zero_geometry~~CallsGraph proc~adjust_for_zero_geometry adjust_for_zero_geometry proc~reset_element_for_zero_values reset_element_for_zero_values proc~adjust_for_zero_geometry->proc~reset_element_for_zero_values proc~reset_juctionbranches_for_zero_values reset_juctionbranches_for_zero_values proc~adjust_for_zero_geometry->proc~reset_juctionbranches_for_zero_values Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~adjust_for_zero_geometry~~CalledByGraph proc~adjust_for_zero_geometry adjust_for_zero_geometry proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~adjust_for_zero_geometry proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_geometry_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocadjust_for_zero_geometryCalledByGraph = svgPanZoom('#procadjust_for_zero_geometryCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"adjust_for_zero_geometry – SWMMengine","tags":"","loc":"proc/adjust_for_zero_geometry.html"},{"text":"public subroutine adjust_negative_volume_reset(volume) Arguments Type Intent Optional Attributes Name real, intent(inout) :: volume (:) Called by proc~~adjust_negative_volume_reset~~CalledByGraph proc~adjust_negative_volume_reset adjust_negative_volume_reset proc~sve_rk2_step sve_rk2_step proc~sve_rk2_step->proc~adjust_negative_volume_reset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"adjust_negative_volume_reset – SWMMengine","tags":"","loc":"proc/adjust_negative_volume_reset.html"},{"text":"public subroutine adjust_smallvolumes(elem2R, elem2I, elem2YN, e2r_VolumeColumn, elemMR, elemMI, elemMYN, eMr_VolumeColumn) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) logical, intent(inout) :: elem2YN (:,:) integer, intent(in) :: e2r_VolumeColumn real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) logical, intent(inout) :: elemMYN (:,:) integer, intent(in) :: eMr_VolumeColumn Calls proc~~adjust_smallvolumes~~CallsGraph proc~adjust_smallvolumes adjust_smallvolumes proc~smallvolume_geometry smallvolume_geometry proc~adjust_smallvolumes->proc~smallvolume_geometry proc~smallvolume_identification smallvolume_identification proc~adjust_smallvolumes->proc~smallvolume_identification proc~smallvolume_junctionbranch_reset smallvolume_junctionbranch_reset proc~smallvolume_geometry->proc~smallvolume_junctionbranch_reset proc~smallvolume_element_geometry_reset smallvolume_element_geometry_reset proc~smallvolume_geometry->proc~smallvolume_element_geometry_reset proc~smallvolume_identification_for_element smallvolume_identification_for_element proc~smallvolume_identification->proc~smallvolume_identification_for_element Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~adjust_smallvolumes~~CalledByGraph proc~adjust_smallvolumes adjust_smallvolumes proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~adjust_smallvolumes proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_geometry_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocadjust_smallvolumesCalledByGraph = svgPanZoom('#procadjust_smallvolumesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"adjust_smallvolumes – SWMMengine","tags":"","loc":"proc/adjust_smallvolumes.html"},{"text":"public subroutine adjust_Vshaped_flowrate(elem2R, faceR, elem2I, elem2YN) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in), target :: elem2I (:,:) logical, intent(inout), target :: elem2YN (:,:) Calls proc~~adjust_vshaped_flowrate~~CallsGraph proc~adjust_vshaped_flowrate adjust_Vshaped_flowrate proc~utility_advance_temp_array utility_advance_temp_array proc~adjust_vshaped_flowrate->proc~utility_advance_temp_array e2yn_temp e2yn_temp proc~adjust_vshaped_flowrate->e2yn_temp e2r_temp e2r_temp proc~adjust_vshaped_flowrate->e2r_temp proc~utility_sign_with_ones utility_sign_with_ones proc~adjust_vshaped_flowrate->proc~utility_sign_with_ones Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~adjust_vshaped_flowrate~~CalledByGraph proc~adjust_vshaped_flowrate adjust_Vshaped_flowrate proc~explicit_test_advance explicit_test_advance proc~explicit_test_advance->proc~adjust_vshaped_flowrate proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~adjust_vshaped_flowrate proc~explicit_euler_advance explicit_euler_advance proc~explicit_euler_advance->proc~adjust_vshaped_flowrate proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching time_marching proc~time_marching->proc~rk2 program~main main program~main->proc~time_marching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"adjust_Vshaped_flowrate – SWMMengine","tags":"","loc":"proc/adjust_vshaped_flowrate.html"},{"text":"public subroutine adjust_zero_velocity_at_zero_volume(elem2R, elem2YN, e2r_VelocityColumn, e2r_VolumeColumn, elemMR, elemMYN, eMr_VelocityColumn, eMr_VolumeColumn) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) logical, intent(inout) :: elem2YN (:,:) integer, intent(in) :: e2r_VelocityColumn integer, intent(in) :: e2r_VolumeColumn real, intent(inout) :: elemMR (:,:) logical, intent(inout) :: elemMYN (:,:) integer, intent(in) :: eMr_VelocityColumn integer, intent(in) :: eMr_VolumeColumn Calls proc~~adjust_zero_velocity_at_zero_volume~~CallsGraph proc~adjust_zero_velocity_at_zero_volume adjust_zero_velocity_at_zero_volume proc~zero_velocity_at_zero_volume zero_velocity_at_zero_volume proc~adjust_zero_velocity_at_zero_volume->proc~zero_velocity_at_zero_volume Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~adjust_zero_velocity_at_zero_volume~~CalledByGraph proc~adjust_zero_velocity_at_zero_volume adjust_zero_velocity_at_zero_volume proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~adjust_zero_velocity_at_zero_volume proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocadjust_zero_velocity_at_zero_volumeCalledByGraph = svgPanZoom('#procadjust_zero_velocity_at_zero_volumeCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"adjust_zero_velocity_at_zero_volume – SWMMengine","tags":"","loc":"proc/adjust_zero_velocity_at_zero_volume.html"},{"text":"private subroutine smallvolume_identification(elem2R, elem2I, elem2YN, eTr_Volume2, elemMR, elemMI, elemMYN, eTr_VolumeM) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) logical, intent(inout), target :: elem2YN (:,:) integer, intent(in) :: eTr_Volume2 real, intent(inout), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) logical, intent(inout), target :: elemMYN (:,:) integer, intent(in) :: eTr_VolumeM Calls proc~~smallvolume_identification~~CallsGraph proc~smallvolume_identification smallvolume_identification proc~smallvolume_identification_for_element smallvolume_identification_for_element proc~smallvolume_identification->proc~smallvolume_identification_for_element Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~smallvolume_identification~~CalledByGraph proc~smallvolume_identification smallvolume_identification proc~adjust_smallvolumes adjust_smallvolumes proc~adjust_smallvolumes->proc~smallvolume_identification proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~adjust_smallvolumes proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_geometry_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocsmallvolume_identificationCalledByGraph = svgPanZoom('#procsmallvolume_identificationCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"smallvolume_identification – SWMMengine","tags":"","loc":"proc/smallvolume_identification.html"},{"text":"private subroutine smallvolume_identification_for_element(volume, smallvolumeratio, smallvolume, issmallvolume, elemtype, thiselementtype) Arguments Type Intent Optional Attributes Name real, intent(inout) :: volume (:) real, intent(inout) :: smallvolumeratio (:) real, intent(in) :: smallvolume (:) logical, intent(inout) :: issmallvolume (:) integer, intent(in) :: elemtype (:) integer, intent(in) :: thiselementtype Called by proc~~smallvolume_identification_for_element~~CalledByGraph proc~smallvolume_identification_for_element smallvolume_identification_for_element proc~smallvolume_identification smallvolume_identification proc~smallvolume_identification->proc~smallvolume_identification_for_element proc~adjust_smallvolumes adjust_smallvolumes proc~adjust_smallvolumes->proc~smallvolume_identification proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~adjust_smallvolumes proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_geometry_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocsmallvolume_identification_for_elementCalledByGraph = svgPanZoom('#procsmallvolume_identification_for_elementCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"smallvolume_identification_for_element – SWMMengine","tags":"","loc":"proc/smallvolume_identification_for_element.html"},{"text":"private subroutine smallvolume_geometry(elem2R, elem2YN, elemMR, elemMYN) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) logical, intent(in) :: elem2YN (:,:) real, intent(inout), target :: elemMR (:,:) logical, intent(in) :: elemMYN (:,:) Calls proc~~smallvolume_geometry~~CallsGraph proc~smallvolume_geometry smallvolume_geometry proc~smallvolume_junctionbranch_reset smallvolume_junctionbranch_reset proc~smallvolume_geometry->proc~smallvolume_junctionbranch_reset proc~smallvolume_element_geometry_reset smallvolume_element_geometry_reset proc~smallvolume_geometry->proc~smallvolume_element_geometry_reset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~smallvolume_geometry~~CalledByGraph proc~smallvolume_geometry smallvolume_geometry proc~adjust_smallvolumes adjust_smallvolumes proc~adjust_smallvolumes->proc~smallvolume_geometry proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~adjust_smallvolumes proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_geometry_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocsmallvolume_geometryCalledByGraph = svgPanZoom('#procsmallvolume_geometryCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"smallvolume_geometry – SWMMengine","tags":"","loc":"proc/smallvolume_geometry.html"},{"text":"private subroutine smallvolume_element_geometry_reset(elemR, elemYN, er_Area, er_Eta, er_Perimeter, er_Zbottom, er_HydDepth, er_HydRadius, er_Topwidth, eYN_IsSmallVolume) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) logical, intent(in) :: elemYN (:,:) integer, intent(in) :: er_Area integer, intent(in) :: er_Eta integer, intent(in) :: er_Perimeter integer, intent(in) :: er_Zbottom integer, intent(in) :: er_HydDepth integer, intent(in) :: er_HydRadius integer, intent(in) :: er_Topwidth integer, intent(in) :: eYN_IsSmallVolume Called by proc~~smallvolume_element_geometry_reset~~CalledByGraph proc~smallvolume_element_geometry_reset smallvolume_element_geometry_reset proc~smallvolume_geometry smallvolume_geometry proc~smallvolume_geometry->proc~smallvolume_element_geometry_reset proc~adjust_smallvolumes adjust_smallvolumes proc~adjust_smallvolumes->proc~smallvolume_geometry proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~adjust_smallvolumes proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_geometry_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocsmallvolume_element_geometry_resetCalledByGraph = svgPanZoom('#procsmallvolume_element_geometry_resetCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"smallvolume_element_geometry_reset – SWMMengine","tags":"","loc":"proc/smallvolume_element_geometry_reset.html"},{"text":"private subroutine smallvolume_junctionbranch_reset(elemMR, elemMYN, eMr_AreaDir, eMr_TopwidthDir, Dir_face_per_elem) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) logical, intent(in) :: elemMYN (:,:) integer, intent(in) :: eMr_AreaDir (:) integer, intent(in) :: eMr_TopwidthDir (:) integer, intent(in) :: Dir_face_per_elem Called by proc~~smallvolume_junctionbranch_reset~~CalledByGraph proc~smallvolume_junctionbranch_reset smallvolume_junctionbranch_reset proc~smallvolume_geometry smallvolume_geometry proc~smallvolume_geometry->proc~smallvolume_junctionbranch_reset proc~adjust_smallvolumes adjust_smallvolumes proc~adjust_smallvolumes->proc~smallvolume_geometry proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~adjust_smallvolumes proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_geometry_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocsmallvolume_junctionbranch_resetCalledByGraph = svgPanZoom('#procsmallvolume_junctionbranch_resetCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"smallvolume_junctionbranch_reset – SWMMengine","tags":"","loc":"proc/smallvolume_junctionbranch_reset.html"},{"text":"private subroutine reset_element_for_zero_values(elemR, elemYN, er_Area, er_Eta, er_Zbottom, er_Topwidth, er_Perimeter, er_HydDepth, er_HydRadius, eYN_IsSmallVolume) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) logical, intent(in) :: elemYN (:,:) integer, intent(in) :: er_Area integer, intent(in) :: er_Eta integer, intent(in) :: er_Zbottom integer, intent(in) :: er_Topwidth integer, intent(in) :: er_Perimeter integer, intent(in) :: er_HydDepth integer, intent(in) :: er_HydRadius integer, intent(in) :: eYN_IsSmallVolume Called by proc~~reset_element_for_zero_values~~CalledByGraph proc~reset_element_for_zero_values reset_element_for_zero_values proc~adjust_for_zero_geometry adjust_for_zero_geometry proc~adjust_for_zero_geometry->proc~reset_element_for_zero_values proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~adjust_for_zero_geometry proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_geometry_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocreset_element_for_zero_valuesCalledByGraph = svgPanZoom('#procreset_element_for_zero_valuesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"reset_element_for_zero_values – SWMMengine","tags":"","loc":"proc/reset_element_for_zero_values.html"},{"text":"private subroutine reset_juctionbranches_for_zero_values(elemMR, elemMI, elemMYN, eMr_AreaDir, eMr_TopwidthDir, eMr_nfaces_Dir, Dir_face_per_elemM) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) logical, intent(in) :: elemMYN (:,:) integer, intent(in) :: eMr_AreaDir (:) integer, intent(in) :: eMr_TopwidthDir (:) integer, intent(in) :: eMr_nfaces_Dir integer, intent(in) :: Dir_face_per_elemM Called by proc~~reset_juctionbranches_for_zero_values~~CalledByGraph proc~reset_juctionbranches_for_zero_values reset_juctionbranches_for_zero_values proc~adjust_for_zero_geometry adjust_for_zero_geometry proc~adjust_for_zero_geometry->proc~reset_juctionbranches_for_zero_values proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~adjust_for_zero_geometry proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_geometry_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocreset_juctionbranches_for_zero_valuesCalledByGraph = svgPanZoom('#procreset_juctionbranches_for_zero_valuesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"reset_juctionbranches_for_zero_values – SWMMengine","tags":"","loc":"proc/reset_juctionbranches_for_zero_values.html"},{"text":"private subroutine zero_velocity_at_zero_volume(elemR, elemYN, er_Velocity, er_Volume, eYN_IsAdhocFlowrate) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) logical, intent(inout) :: elemYN (:,:) integer, intent(in) :: er_Velocity integer, intent(in) :: er_Volume integer, intent(in) :: eYN_IsAdhocFlowrate Called by proc~~zero_velocity_at_zero_volume~~CalledByGraph proc~zero_velocity_at_zero_volume zero_velocity_at_zero_volume proc~adjust_zero_velocity_at_zero_volume adjust_zero_velocity_at_zero_volume proc~adjust_zero_velocity_at_zero_volume->proc~zero_velocity_at_zero_volume proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~adjust_zero_velocity_at_zero_volume proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panproczero_velocity_at_zero_volumeCalledByGraph = svgPanZoom('#proczero_velocity_at_zero_volumeCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"zero_velocity_at_zero_volume – SWMMengine","tags":"","loc":"proc/zero_velocity_at_zero_volume.html"},{"text":"public function utility_advance_temp_array(next_temparray, temparraysize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: next_temparray integer, intent(in) :: temparraysize Return Value integer Called by proc~~utility_advance_temp_array~~CalledByGraph proc~utility_advance_temp_array utility_advance_temp_array proc~face_hydraulic_jump face_hydraulic_jump proc~face_hydraulic_jump->proc~utility_advance_temp_array proc~sve_rk2_step sve_rk2_step proc~sve_rk2_step->proc~utility_advance_temp_array proc~test_face_update test_face_update proc~test_face_update->proc~utility_advance_temp_array proc~junction_branch_summation_and_updown_average junction_branch_summation_and_updown_average proc~junction_branch_summation_and_updown_average->proc~utility_advance_temp_array proc~timescale_value_junction timescale_value_junction proc~timescale_value_junction->proc~utility_advance_temp_array proc~timescale_limit_junction_one_direction timescale_limit_junction_one_direction proc~timescale_value_junction->proc~timescale_limit_junction_one_direction proc~junction_adjacent_element_average junction_adjacent_element_average proc~junction_adjacent_element_average->proc~utility_advance_temp_array proc~velocity_blend_with_mask velocity_blend_with_mask proc~velocity_blend_with_mask->proc~utility_advance_temp_array proc~face_interp_for_upstreamchannel_to_downstreamjunction face_interp_for_upstreamchannel_to_downstreamjunction proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~utility_advance_temp_array proc~face_interp_for_downstreamchannel_to_upstreamjunction face_interp_for_downstreamchannel_to_upstreamjunction proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~utility_advance_temp_array proc~junction_branch_average_for_directions_then_sum junction_branch_average_for_directions_then_sum proc~junction_branch_average_for_directions_then_sum->proc~utility_advance_temp_array proc~explicit_euler_advance explicit_euler_advance proc~explicit_euler_advance->proc~utility_advance_temp_array proc~adjust_vshaped_flowrate adjust_Vshaped_flowrate proc~explicit_euler_advance->proc~adjust_vshaped_flowrate proc~rk2 rk2 proc~rk2->proc~utility_advance_temp_array proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2->proc~rk2_update_auxiliary_variables proc~element_flowrate_update element_flowrate_update proc~element_flowrate_update->proc~utility_advance_temp_array proc~adjust_vshaped_flowrate->proc~utility_advance_temp_array proc~timescale_limit_junction_one_direction->proc~utility_advance_temp_array proc~timescale_value_channel timescale_value_channel proc~timescale_value_channel->proc~utility_advance_temp_array proc~explicit_test_advance explicit_test_advance proc~explicit_test_advance->proc~utility_advance_temp_array proc~explicit_test_advance->proc~test_face_update proc~explicit_test_advance->proc~adjust_vshaped_flowrate proc~face_surface_elevation_interp face_surface_elevation_interp proc~face_surface_elevation_interp->proc~utility_advance_temp_array proc~element_geometry_branch_fix element_geometry_branch_fix proc~element_geometry_branch_fix->proc~utility_advance_temp_array proc~junction_branch_average_of_inflows_and_outflows junction_branch_average_of_inflows_and_outflows proc~junction_branch_average_of_inflows_and_outflows->proc~utility_advance_temp_array proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~utility_advance_temp_array proc~face_interp_for_elem2 face_interp_for_elem2 proc~face_interp_for_elem2->proc~utility_advance_temp_array proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~element_flowrate_update proc~blended_smallvolume_velocity blended_smallvolume_velocity proc~element_dynamics_update->proc~blended_smallvolume_velocity proc~element_timescale element_timescale proc~element_dynamics_update->proc~element_timescale proc~junction_geometry_setup junction_geometry_setup proc~junction_geometry_setup->proc~junction_branch_summation_and_updown_average proc~junction_geometry_setup->proc~junction_branch_average_for_directions_then_sum proc~face_update face_update proc~face_update->proc~face_hydraulic_jump proc~face_update->proc~face_interp_for_upstreamchannel_to_downstreamjunction proc~face_update->proc~face_interp_for_downstreamchannel_to_upstreamjunction proc~face_update->proc~face_surface_elevation_interp proc~face_update->proc~face_interp_for_elem2 proc~initial_junction_conditions initial_junction_conditions proc~initial_junction_conditions->proc~junction_adjacent_element_average proc~initial_junction_conditions->proc~junction_branch_average_of_inflows_and_outflows proc~rk2_update_auxiliary_variables->proc~adjust_vshaped_flowrate proc~rk2_update_auxiliary_variables->proc~element_geometry_branch_fix proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~rk2_update_auxiliary_variables->proc~face_update proc~blended_smallvolume_velocity->proc~velocity_blend_with_mask proc~time_marching time_marching proc~time_marching->proc~rk2 proc~element_timescale->proc~timescale_value_junction proc~element_timescale->proc~timescale_value_channel proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_geometry_update proc~initial_condition_setup->proc~element_dynamics_update proc~initial_condition_setup->proc~face_update proc~initial_condition_setup->proc~initial_junction_conditions program~main main program~main->proc~time_marching program~main->proc~initial_condition_setup proc~network_initiation network_initiation program~main->proc~network_initiation proc~network_initiation->proc~junction_geometry_setup var panprocutility_advance_temp_arrayCalledByGraph = svgPanZoom('#procutility_advance_temp_arrayCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"utility_advance_temp_array – SWMMengine","tags":"","loc":"proc/utility_advance_temp_array.html"},{"text":"public pure function utility_average(inarray) result(outscalar) Arguments Type Intent Optional Attributes Name real, intent(in) :: inarray (:) Return Value real Contents None","title":"utility_average – SWMMengine","tags":"","loc":"proc/utility_average.html"},{"text":"public function utility_linear_interpolate_within_indexlist(thisIndex, IndexArray, ValueArray) result(thisValue) Arguments Type Intent Optional Attributes Name real, intent(in) :: thisIndex real, intent(in) :: IndexArray (:) real, intent(in) :: ValueArray (:) Return Value real Called by proc~~utility_linear_interpolate_within_indexlist~~CalledByGraph proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue bc_updatevalue proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist proc~bc_onface bc_onface proc~bc_onface->proc~bc_updatevalue proc~bc_onelement bc_onelement proc~bc_onelement->proc~bc_updatevalue proc~bc_checks bc_checks proc~bc_checks->proc~bc_updatevalue proc~bc_applied_onelement bc_applied_onelement proc~bc_applied_onelement->proc~bc_onelement proc~bc_applied_onface bc_applied_onface proc~bc_applied_onface->proc~bc_onface program~main main program~main->proc~bc_checks proc~time_marching time_marching program~main->proc~time_marching proc~initial_condition_setup initial_condition_setup program~main->proc~initial_condition_setup proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~bc_applied_onelement proc~explicit_test_advance explicit_test_advance proc~explicit_test_advance->proc~bc_applied_onelement proc~explicit_test_advance->proc~bc_applied_onface proc~explicit_euler_advance explicit_euler_advance proc~explicit_euler_advance->proc~bc_applied_onelement proc~explicit_euler_advance->proc~bc_applied_onface proc~face_update face_update proc~face_update->proc~bc_applied_onface proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~bc_applied_onelement proc~time_marching->proc~bc_applied_onelement proc~time_marching->proc~bc_applied_onface proc~rk2 rk2 proc~time_marching->proc~rk2 proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~rk2_update_auxiliary_variables->proc~face_update proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup->proc~element_dynamics_update proc~initial_condition_setup->proc~face_update proc~initial_condition_setup->proc~element_geometry_update proc~rk2->proc~rk2_update_auxiliary_variables var panprocutility_linear_interpolate_within_indexlistCalledByGraph = svgPanZoom('#procutility_linear_interpolate_within_indexlistCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"utility_linear_interpolate_within_indexlist – SWMMengine","tags":"","loc":"proc/utility_linear_interpolate_within_indexlist.html"},{"text":"public pure elemental function utility_round_to_significant_digits(inarray, idigits) result(outarray) Arguments Type Intent Optional Attributes Name real, intent(in) :: inarray integer, intent(in) :: idigits Return Value real Calls proc~~utility_round_to_significant_digits~~CallsGraph proc~utility_round_to_significant_digits utility_round_to_significant_digits proc~utility_scale_of_number utility_scale_of_number proc~utility_round_to_significant_digits->proc~utility_scale_of_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~utility_round_to_significant_digits~~CalledByGraph proc~utility_round_to_significant_digits utility_round_to_significant_digits proc~this_setting_for_time_and_steps this_setting_for_time_and_steps proc~this_setting_for_time_and_steps->proc~utility_round_to_significant_digits proc~test_case_initiation test_case_initiation proc~test_case_initiation->proc~this_setting_for_time_and_steps program~main main program~main->proc~test_case_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"utility_round_to_significant_digits – SWMMengine","tags":"","loc":"proc/utility_round_to_significant_digits.html"},{"text":"public pure elemental function utility_scale_of_number(inarray) result(outarray) Arguments Type Intent Optional Attributes Name real, intent(in) :: inarray Return Value integer Called by proc~~utility_scale_of_number~~CalledByGraph proc~utility_scale_of_number utility_scale_of_number proc~this_setting_for_time_and_steps this_setting_for_time_and_steps proc~this_setting_for_time_and_steps->proc~utility_scale_of_number proc~utility_round_to_significant_digits utility_round_to_significant_digits proc~this_setting_for_time_and_steps->proc~utility_round_to_significant_digits proc~utility_round_to_significant_digits->proc~utility_scale_of_number proc~test_case_initiation test_case_initiation proc~test_case_initiation->proc~this_setting_for_time_and_steps program~main main program~main->proc~test_case_initiation var panprocutility_scale_of_numberCalledByGraph = svgPanZoom('#procutility_scale_of_numberCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"utility_scale_of_number – SWMMengine","tags":"","loc":"proc/utility_scale_of_number.html"},{"text":"public pure elemental function utility_sign_with_ones(inarray) result(outarray) Arguments Type Intent Optional Attributes Name real, intent(in) :: inarray Return Value real Called by proc~~utility_sign_with_ones~~CalledByGraph proc~utility_sign_with_ones utility_sign_with_ones proc~adjust_vshaped_flowrate adjust_Vshaped_flowrate proc~adjust_vshaped_flowrate->proc~utility_sign_with_ones proc~explicit_test_advance explicit_test_advance proc~explicit_test_advance->proc~adjust_vshaped_flowrate proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~adjust_vshaped_flowrate proc~explicit_euler_advance explicit_euler_advance proc~explicit_euler_advance->proc~adjust_vshaped_flowrate proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching time_marching proc~time_marching->proc~rk2 program~main main program~main->proc~time_marching var panprocutility_sign_with_onesCalledByGraph = svgPanZoom('#procutility_sign_with_onesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"utility_sign_with_ones – SWMMengine","tags":"","loc":"proc/utility_sign_with_ones.html"},{"text":"public subroutine utility_print_values_by_link(elem2R, elem2I, elemMR, elemMI, faceR, faceI, ilink, fcolDn, fcolUp, e2col, eMcolC, eMcolDn, eMcolUp) Arguments Type Intent Optional Attributes Name real, intent(in) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) real, intent(in) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) real, intent(in) :: faceR (:,:) integer, intent(in) :: faceI (:,:) integer, intent(in) :: ilink integer, intent(in) :: fcolDn integer, intent(in) :: fcolUp integer, intent(in) :: e2col integer, intent(in) :: eMcolC integer, intent(in) :: eMcolDn (:) integer, intent(in) :: eMcolUp (:) Contents None","title":"utility_print_values_by_link – SWMMengine","tags":"","loc":"proc/utility_print_values_by_link.html"},{"text":"public subroutine utility_check_fileopen(open_status, emsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: open_status character(len=*), intent(in) :: emsg Called by proc~~utility_check_fileopen~~CalledByGraph proc~utility_check_fileopen utility_check_fileopen proc~debug_singlefile_open debug_singlefile_open proc~debug_singlefile_open->proc~utility_check_fileopen proc~output_singlethreadedfile_open output_singlethreadedfile_open proc~output_singlethreadedfile_open->proc~utility_check_fileopen proc~write_testcase_setup_file write_testcase_setup_file proc~write_testcase_setup_file->proc~utility_check_fileopen proc~test_case_initiation test_case_initiation proc~test_case_initiation->proc~write_testcase_setup_file program~main main program~main->proc~test_case_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"utility_check_fileopen – SWMMengine","tags":"","loc":"proc/utility_check_fileopen.html"},{"text":"public subroutine utility_check_allocation(allocation_status, emsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: allocation_status character(len=*), intent(in) :: emsg Called by proc~~utility_check_allocation~~CalledByGraph proc~utility_check_allocation utility_check_allocation proc~allocate_data_storage allocate_data_storage proc~allocate_data_storage->proc~utility_check_allocation proc~output_threaded_by_link_initialize output_threaded_by_link_initialize proc~output_threaded_by_link_initialize->proc~utility_check_allocation proc~output_one_threaded_data_by_link output_one_threaded_data_by_link proc~output_one_threaded_data_by_link->proc~utility_check_allocation proc~diagnostic_initialize diagnostic_initialize proc~diagnostic_initialize->proc~utility_check_allocation proc~bc_allocate bc_allocate proc~bc_allocate->proc~utility_check_allocation proc~allocate_linknode_storage allocate_linknode_storage proc~allocate_linknode_storage->proc~utility_check_allocation proc~debug_initialize debug_initialize proc~debug_initialize->proc~utility_check_allocation proc~case_simple_channel_links_and_nodes case_simple_channel_links_and_nodes proc~case_simple_channel_links_and_nodes->proc~allocate_linknode_storage program~main main program~main->proc~output_threaded_by_link_initialize program~main->proc~diagnostic_initialize program~main->proc~debug_initialize proc~network_initiation network_initiation program~main->proc~network_initiation proc~test_case_initiation test_case_initiation program~main->proc~test_case_initiation proc~time_marching time_marching program~main->proc~time_marching proc~case_y_channel_links_and_nodes case_y_channel_links_and_nodes proc~case_y_channel_links_and_nodes->proc~allocate_linknode_storage proc~case_y_channel_initialize case_y_channel_initialize proc~case_y_channel_initialize->proc~bc_allocate proc~case_y_channel_initialize->proc~case_y_channel_links_and_nodes proc~output_all_threaded_data_by_link output_all_threaded_data_by_link proc~output_all_threaded_data_by_link->proc~output_one_threaded_data_by_link proc~case_simple_channel_initialize case_simple_channel_initialize proc~case_simple_channel_initialize->proc~bc_allocate proc~case_simple_channel_initialize->proc~case_simple_channel_links_and_nodes proc~network_initiation->proc~allocate_data_storage proc~test_case_initiation->proc~case_y_channel_initialize proc~time_marching->proc~output_all_threaded_data_by_link var panprocutility_check_allocationCalledByGraph = svgPanZoom('#procutility_check_allocationCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"utility_check_allocation – SWMMengine","tags":"","loc":"proc/utility_check_allocation.html"},{"text":"public subroutine utility_get_datetime_stamp(datetimestamp) Arguments Type Intent Optional Attributes Name character(len=14), intent(out) :: datetimestamp Called by proc~~utility_get_datetime_stamp~~CalledByGraph proc~utility_get_datetime_stamp utility_get_datetime_stamp program~main main program~main->proc~utility_get_datetime_stamp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"utility_get_datetime_stamp – SWMMengine","tags":"","loc":"proc/utility_get_datetime_stamp.html"},{"text":"public subroutine case_y_channel_initialize(channel_length, channel_breadth, subdivide_length, lowerZ, upperZ, initial_flowrate, depth_upstream, depth_dnstream, ManningsN, roughness_type, idepth_type, linkR, nodeR, linkI, nodeI, linkYN, nodeYN, linkName, nodeName, bcdataDn, bcdataUp) Arguments Type Intent Optional Attributes Name real, intent(in) :: channel_length (:) real, intent(in) :: channel_breadth (:) real, intent(in) :: subdivide_length (:) real, intent(in) :: lowerZ (:) real, intent(in) :: upperZ (:) real, intent(in) :: initial_flowrate (:) real, intent(in) :: depth_upstream (:) real, intent(in) :: depth_dnstream (:) real, intent(in) :: ManningsN (:) integer, intent(in) :: roughness_type integer, intent(in) :: idepth_type (:) real, intent(out), dimension(:,:), allocatable, target :: linkR real, intent(out), dimension(:,:), allocatable, target :: nodeR integer, intent(out), dimension(:,:), allocatable, target :: linkI integer, intent(out), dimension(:,:), allocatable, target :: nodeI logical, intent(out), dimension(:,:), allocatable, target :: linkYN logical, intent(out), dimension(:,:), allocatable, target :: nodeYN type(string), intent(out), dimension(:), allocatable, target :: linkName type(string), intent(out), dimension(:), allocatable, target :: nodeName type(bcType), intent(out), dimension(:), allocatable :: bcdataDn type(bcType), intent(out), dimension(:), allocatable :: bcdataUp Calls proc~~case_y_channel_initialize~~CallsGraph proc~case_y_channel_initialize case_y_channel_initialize proc~case_y_channel_links_and_nodes case_y_channel_links_and_nodes proc~case_y_channel_initialize->proc~case_y_channel_links_and_nodes proc~bc_allocate bc_allocate proc~case_y_channel_initialize->proc~bc_allocate proc~allocate_linknode_storage allocate_linknode_storage proc~case_y_channel_links_and_nodes->proc~allocate_linknode_storage proc~utility_check_allocation utility_check_allocation proc~bc_allocate->proc~utility_check_allocation proc~allocate_linknode_storage->proc~utility_check_allocation var panproccase_y_channel_initializeCallsGraph = svgPanZoom('#proccase_y_channel_initializeCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~case_y_channel_initialize~~CalledByGraph proc~case_y_channel_initialize case_y_channel_initialize proc~test_case_initiation test_case_initiation proc~test_case_initiation->proc~case_y_channel_initialize program~main main program~main->proc~test_case_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"case_y_channel_initialize – SWMMengine","tags":"","loc":"proc/case_y_channel_initialize.html"},{"text":"private subroutine case_y_channel_links_and_nodes(channel_length, channel_breadth, subdivide_length, lowerZ, upperZ, initial_flowrate, depth_upstream, depth_dnstream, ManningsN, roughness_type, idepth_type, linkR, nodeR, linkI, nodeI, linkYN, nodeYN, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(in) :: channel_length (:) real, intent(in) :: channel_breadth (:) real, intent(in) :: subdivide_length (:) real, intent(in) :: lowerZ (:) real, intent(in) :: upperZ (:) real, intent(in) :: initial_flowrate (:) real, intent(in) :: depth_upstream (:) real, intent(in) :: depth_dnstream (:) real, intent(in) :: ManningsN (:) integer, intent(in) :: roughness_type integer, intent(in) :: idepth_type (:) real, intent(out), dimension(:,:), allocatable, target :: linkR real, intent(out), dimension(:,:), allocatable, target :: nodeR integer, intent(out), dimension(:,:), allocatable, target :: linkI integer, intent(out), dimension(:,:), allocatable, target :: nodeI logical, intent(out), dimension(:,:), allocatable, target :: linkYN logical, intent(out), dimension(:,:), allocatable, target :: nodeYN type(string), intent(out), dimension(:), allocatable, target :: linkName type(string), intent(out), dimension(:), allocatable, target :: nodeName Calls proc~~case_y_channel_links_and_nodes~~CallsGraph proc~case_y_channel_links_and_nodes case_y_channel_links_and_nodes proc~allocate_linknode_storage allocate_linknode_storage proc~case_y_channel_links_and_nodes->proc~allocate_linknode_storage proc~utility_check_allocation utility_check_allocation proc~allocate_linknode_storage->proc~utility_check_allocation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~case_y_channel_links_and_nodes~~CalledByGraph proc~case_y_channel_links_and_nodes case_y_channel_links_and_nodes proc~case_y_channel_initialize case_y_channel_initialize proc~case_y_channel_initialize->proc~case_y_channel_links_and_nodes proc~test_case_initiation test_case_initiation proc~test_case_initiation->proc~case_y_channel_initialize program~main main program~main->proc~test_case_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"case_y_channel_links_and_nodes – SWMMengine","tags":"","loc":"proc/case_y_channel_links_and_nodes.html"},{"text":"public subroutine output_threaded_by_link_initialize(threadedfile) Arguments Type Intent Optional Attributes Name type(threadedfileType), intent(out), dimension(:), allocatable :: threadedfile Calls proc~~output_threaded_by_link_initialize~~CallsGraph proc~output_threaded_by_link_initialize output_threaded_by_link_initialize proc~utility_check_allocation utility_check_allocation proc~output_threaded_by_link_initialize->proc~utility_check_allocation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~output_threaded_by_link_initialize~~CalledByGraph proc~output_threaded_by_link_initialize output_threaded_by_link_initialize program~main main program~main->proc~output_threaded_by_link_initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"output_threaded_by_link_initialize – SWMMengine","tags":"","loc":"proc/output_threaded_by_link_initialize.html"},{"text":"public subroutine output_all_threaded_data_by_link(threadedfile, elem2R, elem2I, elemMR, elemMI, faceR, faceI, linkI, bcdataUp, bcdataDn, thisstep) Arguments Type Intent Optional Attributes Name type(threadedfileType), intent(in) :: threadedfile (:) real, intent(in), target :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) real, intent(in), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in), target :: faceI (:,:) integer, intent(in), target :: linkI (:,:) type(bcType), intent(in) :: bcdataUp (:) type(bcType), intent(in) :: bcdataDn (:) integer, intent(in) :: thisstep Calls proc~~output_all_threaded_data_by_link~~CallsGraph proc~output_all_threaded_data_by_link output_all_threaded_data_by_link proc~output_one_threaded_data_by_link output_one_threaded_data_by_link proc~output_all_threaded_data_by_link->proc~output_one_threaded_data_by_link emr_lengthdn emr_lengthdn proc~output_one_threaded_data_by_link->emr_lengthdn proc~utility_check_allocation utility_check_allocation proc~output_one_threaded_data_by_link->proc~utility_check_allocation emr_lengthup emr_lengthup proc~output_one_threaded_data_by_link->emr_lengthup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~output_all_threaded_data_by_link~~CalledByGraph proc~output_all_threaded_data_by_link output_all_threaded_data_by_link proc~time_marching time_marching proc~time_marching->proc~output_all_threaded_data_by_link program~main main program~main->proc~time_marching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"output_all_threaded_data_by_link – SWMMengine","tags":"","loc":"proc/output_all_threaded_data_by_link.html"},{"text":"public subroutine output_one_threaded_data_by_link(outdataName, thisUnit, thisstep, elem2R, elem2I, elemMR, elemMI, faceR, faceI, linkI, bcdataUp, bcdataDn, itemp) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: outdataName integer, intent(in) :: thisUnit integer, intent(in) :: thisstep real, intent(in), target :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) real, intent(in), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in), target :: faceI (:,:) integer, intent(in), target :: linkI (:,:) type(bcType), intent(in) :: bcdataUp (:) type(bcType), intent(in) :: bcdataDn (:) integer, intent(in) :: itemp Calls proc~~output_one_threaded_data_by_link~~CallsGraph proc~output_one_threaded_data_by_link output_one_threaded_data_by_link emr_lengthdn emr_lengthdn proc~output_one_threaded_data_by_link->emr_lengthdn proc~utility_check_allocation utility_check_allocation proc~output_one_threaded_data_by_link->proc~utility_check_allocation emr_lengthup emr_lengthup proc~output_one_threaded_data_by_link->emr_lengthup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~output_one_threaded_data_by_link~~CalledByGraph proc~output_one_threaded_data_by_link output_one_threaded_data_by_link proc~output_all_threaded_data_by_link output_all_threaded_data_by_link proc~output_all_threaded_data_by_link->proc~output_one_threaded_data_by_link proc~time_marching time_marching proc~time_marching->proc~output_all_threaded_data_by_link program~main main program~main->proc~time_marching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"output_one_threaded_data_by_link – SWMMengine","tags":"","loc":"proc/output_one_threaded_data_by_link.html"},{"text":"private subroutine output_singlethreadedfile_open(threadedfile) Arguments Type Intent Optional Attributes Name type(threadedfileType), intent(inout) :: threadedfile Calls proc~~output_singlethreadedfile_open~~CallsGraph proc~output_singlethreadedfile_open output_singlethreadedfile_open proc~utility_check_fileopen utility_check_fileopen proc~output_singlethreadedfile_open->proc~utility_check_fileopen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"output_singlethreadedfile_open – SWMMengine","tags":"","loc":"proc/output_singlethreadedfile_open.html"},{"text":"private function setAssigned(thisX, assigned_idx, unassignedValue, assignedValue, arrayI) result(f_result) Arguments Type Intent Optional Attributes Name integer, intent(in) :: thisX integer, intent(in) :: assigned_idx integer, intent(in) :: unassignedValue integer, intent(in) :: assignedValue integer, intent(in) :: arrayI (:,:) Return Value integer Called by proc~~setassigned~~CalledByGraph proc~setassigned setAssigned proc~network_data_create network_data_create proc~network_data_create->proc~setassigned proc~handle_thisnode handle_thisnode proc~network_data_create->proc~handle_thisnode proc~handle_thisnode->proc~setassigned proc~handle_thisnode->proc~handle_thisnode proc~network_initiation network_initiation proc~network_initiation->proc~network_data_create program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"setAssigned – SWMMengine","tags":"","loc":"proc/setassigned.html"},{"text":"private function setFaceType(up_elem_type, dn_elem_type) result(f_result) Arguments Type Intent Optional Attributes Name integer, intent(in) :: up_elem_type integer, intent(in) :: dn_elem_type Return Value integer Called by proc~~setfacetype~~CalledByGraph proc~setfacetype setFaceType proc~handle_thisnode handle_thisnode proc~handle_thisnode->proc~setfacetype proc~handle_thisnode->proc~handle_thisnode proc~subdivide_link_going_upstream subdivide_link_going_upstream proc~handle_thisnode->proc~subdivide_link_going_upstream proc~subdivide_link_going_upstream->proc~setfacetype proc~network_data_create network_data_create proc~network_data_create->proc~handle_thisnode proc~network_data_create->proc~subdivide_link_going_upstream proc~network_initiation network_initiation proc~network_initiation->proc~network_data_create program~main main program~main->proc~network_initiation var panprocsetfacetypeCalledByGraph = svgPanZoom('#procsetfacetypeCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"setFaceType – SWMMengine","tags":"","loc":"proc/setfacetype.html"},{"text":"public subroutine network_initiation(linkI, linkR, linkYN, linkName, nodeI, nodeR, nodeYN, nodeName, elem2R, elem2I, elem2YN, elem2Name, elemMR, elemMI, elemMYN, elemMName, faceR, faceI, faceYN, faceName) Arguments Type Intent Optional Attributes Name integer, intent(inout), target :: linkI (:,:) real, intent(inout) :: linkR (:,:) logical, intent(inout) :: linkYN (:,:) type(string), intent(inout) :: linkName (:) integer, intent(inout), target :: nodeI (:,:) real, intent(inout), target :: nodeR (:,:) logical, intent(out) :: nodeYN (:,:) type(string), intent(inout) :: nodeName (:) real, dimension(:,:), allocatable, target :: elem2R integer, dimension(:,:), allocatable, target :: elem2I logical, dimension(:,:), allocatable, target :: elem2YN type(string), dimension(:), allocatable, target :: elem2Name real, dimension(:,:), allocatable, target :: elemMR integer, dimension(:,:), allocatable, target :: elemMI logical, dimension(:,:), allocatable, target :: elemMYN type(string), dimension(:), allocatable, target :: elemMName real, dimension(:,:), allocatable, target :: faceR integer, dimension(:,:), allocatable, target :: faceI logical, dimension(:,:), allocatable, target :: faceYN type(string), dimension(:), allocatable, target :: faceName Calls proc~~network_initiation~~CallsGraph proc~network_initiation network_initiation proc~network_data_create network_data_create proc~network_initiation->proc~network_data_create proc~network_node_assignment network_node_assignment proc~network_initiation->proc~network_node_assignment proc~junction_geometry_setup junction_geometry_setup proc~network_initiation->proc~junction_geometry_setup proc~allocate_data_storage allocate_data_storage proc~network_initiation->proc~allocate_data_storage proc~network_check_bc network_check_BC proc~network_initiation->proc~network_check_bc proc~network_adjust_link_length network_adjust_link_length proc~network_initiation->proc~network_adjust_link_length proc~network_check_node_link_match network_check_node_link_match proc~network_initiation->proc~network_check_node_link_match proc~initialize_array_zerovalues initialize_array_zerovalues proc~network_initiation->proc~initialize_array_zerovalues proc~initialize_dummy_values initialize_dummy_values proc~network_initiation->proc~initialize_dummy_values proc~junction_branch_assigned_to_faces junction_branch_assigned_to_faces proc~network_initiation->proc~junction_branch_assigned_to_faces proc~network_get_link_slope network_get_link_slope proc~network_initiation->proc~network_get_link_slope proc~network_count_elements_and_faces network_count_elements_and_faces proc~network_initiation->proc~network_count_elements_and_faces proc~handle_thisnode handle_thisnode proc~network_data_create->proc~handle_thisnode proc~subdivide_link_going_upstream subdivide_link_going_upstream proc~network_data_create->proc~subdivide_link_going_upstream proc~setassigned setAssigned proc~network_data_create->proc~setassigned proc~junction_branch_summation_and_updown_average junction_branch_summation_and_updown_average proc~junction_geometry_setup->proc~junction_branch_summation_and_updown_average proc~junction_branch_average_for_directions_then_sum junction_branch_average_for_directions_then_sum proc~junction_geometry_setup->proc~junction_branch_average_for_directions_then_sum proc~utility_check_allocation utility_check_allocation proc~allocate_data_storage->proc~utility_check_allocation proc~link_shortening link_shortening proc~network_adjust_link_length->proc~link_shortening ni_mlinkup ni_mlinkup proc~network_check_node_link_match->ni_mlinkup ni_mlinkdn ni_mlinkdn proc~network_check_node_link_match->ni_mlinkdn emr_topwidthdn emr_topwidthdn proc~initialize_array_zerovalues->emr_topwidthdn emr_topwidthup emr_topwidthup proc~initialize_array_zerovalues->emr_topwidthup emr_hyddepthup emr_hyddepthup proc~initialize_array_zerovalues->emr_hyddepthup emr_lengthdn emr_lengthdn proc~initialize_array_zerovalues->emr_lengthdn emr_areadn emr_areadn proc~initialize_array_zerovalues->emr_areadn emr_areaup emr_areaup proc~initialize_array_zerovalues->emr_areaup emr_hyddepthdn emr_hyddepthdn proc~initialize_array_zerovalues->emr_hyddepthdn emr_lengthup emr_lengthup proc~initialize_array_zerovalues->emr_lengthup emi_mfacedn emi_mfacedn proc~initialize_dummy_values->emi_mfacedn emi_mfaceup emi_mfaceup proc~initialize_dummy_values->emi_mfaceup proc~junction_branch_assigned_to_faces->emi_mfacedn proc~junction_branch_assigned_to_faces->emi_mfaceup proc~handle_thisnode->emr_topwidthdn proc~handle_thisnode->emi_mfacedn proc~handle_thisnode->emr_topwidthup proc~handle_thisnode->emi_mfaceup proc~handle_thisnode->proc~handle_thisnode proc~handle_thisnode->proc~subdivide_link_going_upstream proc~handle_thisnode->ni_mlinkup proc~handle_thisnode->proc~setassigned proc~handle_thisnode->ni_mlinkdn proc~handle_thisnode->emr_lengthdn proc~handle_thisnode->emr_lengthup nr_elementlengthdn nr_elementlengthdn proc~handle_thisnode->nr_elementlengthdn emr_zbottomup emr_zbottomup proc~handle_thisnode->emr_zbottomup emr_breadthscaledn emr_breadthscaledn proc~handle_thisnode->emr_breadthscaledn emr_breadthscaleup emr_breadthscaleup proc~handle_thisnode->emr_breadthscaleup proc~setfacetype setFaceType proc~handle_thisnode->proc~setfacetype nr_elementlengthup nr_elementlengthup proc~handle_thisnode->nr_elementlengthup emr_zbottomdn emr_zbottomdn proc~handle_thisnode->emr_zbottomdn proc~subdivide_link_going_upstream->proc~setfacetype proc~utility_advance_temp_array utility_advance_temp_array proc~junction_branch_summation_and_updown_average->proc~utility_advance_temp_array proc~junction_branch_summation_one_direction junction_branch_summation_one_direction proc~junction_branch_summation_and_updown_average->proc~junction_branch_summation_one_direction emr_temp emr_temp proc~junction_branch_summation_and_updown_average->emr_temp proc~junction_branch_average_for_directions_then_sum->proc~utility_advance_temp_array proc~junction_branch_average_for_directions_then_sum->proc~junction_branch_summation_one_direction proc~junction_branch_average_for_directions_then_sum->emr_temp var panprocnetwork_initiationCallsGraph = svgPanZoom('#procnetwork_initiationCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~network_initiation~~CalledByGraph proc~network_initiation network_initiation program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"network_initiation – SWMMengine","tags":"","loc":"proc/network_initiation.html"},{"text":"private subroutine network_node_assignment(nodeI, linkI) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: nodeI (:,:) integer, intent(in) :: linkI (:,:) Called by proc~~network_node_assignment~~CalledByGraph proc~network_node_assignment network_node_assignment proc~network_initiation network_initiation proc~network_initiation->proc~network_node_assignment program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"network_node_assignment – SWMMengine","tags":"","loc":"proc/network_node_assignment.html"},{"text":"private subroutine network_check_node_link_match(linkI, nodeI) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: linkI (:,:) integer, intent(in) :: nodeI (:,:) Calls proc~~network_check_node_link_match~~CallsGraph proc~network_check_node_link_match network_check_node_link_match ni_mlinkup ni_mlinkup proc~network_check_node_link_match->ni_mlinkup ni_mlinkdn ni_mlinkdn proc~network_check_node_link_match->ni_mlinkdn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~network_check_node_link_match~~CalledByGraph proc~network_check_node_link_match network_check_node_link_match proc~network_initiation network_initiation proc~network_initiation->proc~network_check_node_link_match program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"network_check_node_link_match – SWMMengine","tags":"","loc":"proc/network_check_node_link_match.html"},{"text":"private subroutine network_check_BC(nodeI, N_node) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodeI (:,:) integer, intent(in) :: N_node Called by proc~~network_check_bc~~CalledByGraph proc~network_check_bc network_check_BC proc~network_initiation network_initiation proc~network_initiation->proc~network_check_bc program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"network_check_BC – SWMMengine","tags":"","loc":"proc/network_check_bc.html"},{"text":"private subroutine network_get_link_slope(linkR, nodeR, linkI, nodeI) Arguments Type Intent Optional Attributes Name real, intent(inout) :: linkR (:,:) real, intent(in), target :: nodeR (:,:) integer, intent(in), target :: linkI (:,:) integer, intent(in), target :: nodeI (:,:) Called by proc~~network_get_link_slope~~CalledByGraph proc~network_get_link_slope network_get_link_slope proc~network_initiation network_initiation proc~network_initiation->proc~network_get_link_slope program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"network_get_link_slope – SWMMengine","tags":"","loc":"proc/network_get_link_slope.html"},{"text":"private subroutine network_adjust_link_length(linkR, nodeR, linkI, nodeI) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: linkR (:,:) real, intent(inout), target :: nodeR (:,:) integer, intent(inout), target :: linkI (:,:) integer, intent(in) :: nodeI (:,:) Calls proc~~network_adjust_link_length~~CallsGraph proc~network_adjust_link_length network_adjust_link_length proc~link_shortening link_shortening proc~network_adjust_link_length->proc~link_shortening Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~network_adjust_link_length~~CalledByGraph proc~network_adjust_link_length network_adjust_link_length proc~network_initiation network_initiation proc~network_initiation->proc~network_adjust_link_length program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"network_adjust_link_length – SWMMengine","tags":"","loc":"proc/network_adjust_link_length.html"},{"text":"private subroutine network_count_elements_and_faces(nodeR, linkI, nodeI) Arguments Type Intent Optional Attributes Name real, intent(in) :: nodeR (:,:) integer, intent(in) :: linkI (:,:) integer, intent(in) :: nodeI (:,:) Called by proc~~network_count_elements_and_faces~~CalledByGraph proc~network_count_elements_and_faces network_count_elements_and_faces proc~network_initiation network_initiation proc~network_initiation->proc~network_count_elements_and_faces program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"network_count_elements_and_faces – SWMMengine","tags":"","loc":"proc/network_count_elements_and_faces.html"},{"text":"private subroutine network_data_create(elem2R, elemMR, faceR, linkR, nodeR, elem2I, elemMI, faceI, linkI, nodeI, nodeYN, elem2Name, elemMName, faceName, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) real, intent(inout) :: elemMR (:,:) real, intent(inout) :: faceR (:,:) real, intent(in), target :: linkR (:,:) real, intent(in), target :: nodeR (:,:) integer, intent(inout) :: elem2I (:,:) integer, intent(inout) :: elemMI (:,:) integer, intent(inout) :: faceI (:,:) integer, intent(inout) :: linkI (:,:) integer, intent(inout), target :: nodeI (:,:) logical, intent(in), target :: nodeYN (:,:) type(string), intent(inout) :: elem2Name (:) type(string), intent(inout) :: elemMName (:) type(string), intent(inout) :: faceName (:) type(string), intent(in) :: linkName (:) type(string), intent(in) :: nodeName (:) Calls proc~~network_data_create~~CallsGraph proc~network_data_create network_data_create proc~setassigned setAssigned proc~network_data_create->proc~setassigned proc~handle_thisnode handle_thisnode proc~network_data_create->proc~handle_thisnode proc~subdivide_link_going_upstream subdivide_link_going_upstream proc~network_data_create->proc~subdivide_link_going_upstream proc~handle_thisnode->proc~setassigned proc~handle_thisnode->proc~handle_thisnode proc~handle_thisnode->proc~subdivide_link_going_upstream emr_topwidthdn emr_topwidthdn proc~handle_thisnode->emr_topwidthdn emi_mfacedn emi_mfacedn proc~handle_thisnode->emi_mfacedn emr_topwidthup emr_topwidthup proc~handle_thisnode->emr_topwidthup emi_mfaceup emi_mfaceup proc~handle_thisnode->emi_mfaceup nr_elementlengthdn nr_elementlengthdn proc~handle_thisnode->nr_elementlengthdn emr_zbottomup emr_zbottomup proc~handle_thisnode->emr_zbottomup ni_mlinkup ni_mlinkup proc~handle_thisnode->ni_mlinkup emr_breadthscaledn emr_breadthscaledn proc~handle_thisnode->emr_breadthscaledn emr_breadthscaleup emr_breadthscaleup proc~handle_thisnode->emr_breadthscaleup proc~setfacetype setFaceType proc~handle_thisnode->proc~setfacetype emr_lengthdn emr_lengthdn proc~handle_thisnode->emr_lengthdn emr_zbottomdn emr_zbottomdn proc~handle_thisnode->emr_zbottomdn ni_mlinkdn ni_mlinkdn proc~handle_thisnode->ni_mlinkdn nr_elementlengthup nr_elementlengthup proc~handle_thisnode->nr_elementlengthup emr_lengthup emr_lengthup proc~handle_thisnode->emr_lengthup proc~subdivide_link_going_upstream->proc~setfacetype Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~network_data_create~~CalledByGraph proc~network_data_create network_data_create proc~network_initiation network_initiation proc~network_initiation->proc~network_data_create program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"network_data_create – SWMMengine","tags":"","loc":"proc/network_data_create.html"},{"text":"private recursive subroutine handle_thisnode(lastElem2, thisElem2, lastElemM, thisElemM, lastFace, thisFace, thisNode, thisLink, elem2I, elemMI, faceI, linkI, nodeI, elem2R, elemMR, faceR, linkR, nodeR, elem2Name, elemMName, faceName, linkName, nodeName) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: lastElem2 integer, intent(inout) :: thisElem2 integer, intent(inout) :: lastElemM integer, intent(inout) :: thisElemM integer, intent(inout) :: lastFace integer, intent(inout) :: thisFace integer, intent(inout) :: thisNode integer, intent(inout) :: thisLink integer, intent(inout) :: elem2I (:,:) integer, intent(inout) :: elemMI (:,:) integer, intent(inout) :: faceI (:,:) integer, intent(inout) :: linkI (:,:) integer, intent(inout), target :: nodeI (:,:) real, intent(inout) :: elem2R (:,:) real, intent(inout) :: elemMR (:,:) real, intent(inout) :: faceR (:,:) real, intent(in), target :: linkR (:,:) real, intent(in), target :: nodeR (:,:) type(string), intent(inout) :: elem2Name (:) type(string), intent(inout) :: elemMName (:) type(string), intent(inout) :: faceName (:) type(string), intent(in) :: linkName (:) type(string), intent(in) :: nodeName (:) Calls proc~~handle_thisnode~~CallsGraph proc~handle_thisnode handle_thisnode proc~handle_thisnode->proc~handle_thisnode emr_topwidthdn emr_topwidthdn proc~handle_thisnode->emr_topwidthdn emi_mfacedn emi_mfacedn proc~handle_thisnode->emi_mfacedn emr_topwidthup emr_topwidthup proc~handle_thisnode->emr_topwidthup emi_mfaceup emi_mfaceup proc~handle_thisnode->emi_mfaceup nr_elementlengthdn nr_elementlengthdn proc~handle_thisnode->nr_elementlengthdn proc~subdivide_link_going_upstream subdivide_link_going_upstream proc~handle_thisnode->proc~subdivide_link_going_upstream ni_mlinkup ni_mlinkup proc~handle_thisnode->ni_mlinkup emr_breadthscaledn emr_breadthscaledn proc~handle_thisnode->emr_breadthscaledn emr_zbottomup emr_zbottomup proc~handle_thisnode->emr_zbottomup emr_breadthscaleup emr_breadthscaleup proc~handle_thisnode->emr_breadthscaleup proc~setfacetype setFaceType proc~handle_thisnode->proc~setfacetype proc~setassigned setAssigned proc~handle_thisnode->proc~setassigned emr_lengthdn emr_lengthdn proc~handle_thisnode->emr_lengthdn emr_zbottomdn emr_zbottomdn proc~handle_thisnode->emr_zbottomdn ni_mlinkdn ni_mlinkdn proc~handle_thisnode->ni_mlinkdn nr_elementlengthup nr_elementlengthup proc~handle_thisnode->nr_elementlengthup emr_lengthup emr_lengthup proc~handle_thisnode->emr_lengthup proc~subdivide_link_going_upstream->proc~setfacetype Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~handle_thisnode~~CalledByGraph proc~handle_thisnode handle_thisnode proc~handle_thisnode->proc~handle_thisnode proc~network_data_create network_data_create proc~network_data_create->proc~handle_thisnode proc~network_initiation network_initiation proc~network_initiation->proc~network_data_create program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"handle_thisnode – SWMMengine","tags":"","loc":"proc/handle_thisnode.html"},{"text":"private subroutine subdivide_link_going_upstream(lastElem2, thisElem2, lastFace, thisFace, thisLink, elem2I, faceI, linkI, elem2R, faceR, linkR, nodeR, zDownstream) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: lastElem2 integer, intent(inout) :: thisElem2 integer, intent(inout) :: lastFace integer, intent(inout) :: thisFace integer, intent(in) :: thisLink integer, intent(inout) :: elem2I (:,:) integer, intent(inout) :: faceI (:,:) integer, intent(inout) :: linkI (:,:) real, intent(inout) :: elem2R (:,:) real, intent(inout) :: faceR (:,:) real, intent(in) :: linkR (:,:) real, intent(in) :: nodeR (:,:) real, intent(in) :: zDownstream Calls proc~~subdivide_link_going_upstream~~CallsGraph proc~subdivide_link_going_upstream subdivide_link_going_upstream proc~setfacetype setFaceType proc~subdivide_link_going_upstream->proc~setfacetype Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~subdivide_link_going_upstream~~CalledByGraph proc~subdivide_link_going_upstream subdivide_link_going_upstream proc~network_data_create network_data_create proc~network_data_create->proc~subdivide_link_going_upstream proc~handle_thisnode handle_thisnode proc~network_data_create->proc~handle_thisnode proc~handle_thisnode->proc~subdivide_link_going_upstream proc~handle_thisnode->proc~handle_thisnode proc~network_initiation network_initiation proc~network_initiation->proc~network_data_create program~main main program~main->proc~network_initiation var panprocsubdivide_link_going_upstreamCalledByGraph = svgPanZoom('#procsubdivide_link_going_upstreamCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"subdivide_link_going_upstream – SWMMengine","tags":"","loc":"proc/subdivide_link_going_upstream.html"},{"text":"private subroutine link_shortening(linkLength, nodeR, nodeI, thisNode, niNlinkX, niMlinkX, nrElementLengthX, element_nominal_length) Arguments Type Intent Optional Attributes Name real, intent(inout) :: linkLength (:) real, intent(inout), target :: nodeR (:,:) integer, intent(in), target :: nodeI (:,:) integer, intent(in) :: thisNode integer, intent(in) :: niNlinkX integer, intent(in) :: niMlinkX (:) integer, intent(in) :: nrElementLengthX (:) real, intent(in) :: element_nominal_length (:) Called by proc~~link_shortening~~CalledByGraph proc~link_shortening link_shortening proc~network_adjust_link_length network_adjust_link_length proc~network_adjust_link_length->proc~link_shortening proc~network_initiation network_initiation proc~network_initiation->proc~network_adjust_link_length program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"link_shortening – SWMMengine","tags":"","loc":"proc/link_shortening.html"},{"text":"public subroutine allocate_linknode_storage(linkR, nodeR, linkI, nodeI, linkYN, nodeYN, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:,:), allocatable, target :: linkR real, intent(out), dimension(:,:), allocatable, target :: nodeR integer, intent(out), dimension(:,:), allocatable, target :: linkI integer, intent(out), dimension(:,:), allocatable, target :: nodeI logical, intent(out), dimension(:,:), allocatable, target :: linkYN logical, intent(out), dimension(:,:), allocatable, target :: nodeYN type(string), intent(out), dimension(:), allocatable, target :: linkName type(string), intent(out), dimension(:), allocatable, target :: nodeName Calls proc~~allocate_linknode_storage~~CallsGraph proc~allocate_linknode_storage allocate_linknode_storage proc~utility_check_allocation utility_check_allocation proc~allocate_linknode_storage->proc~utility_check_allocation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~allocate_linknode_storage~~CalledByGraph proc~allocate_linknode_storage allocate_linknode_storage proc~case_y_channel_links_and_nodes case_y_channel_links_and_nodes proc~case_y_channel_links_and_nodes->proc~allocate_linknode_storage proc~case_simple_channel_links_and_nodes case_simple_channel_links_and_nodes proc~case_simple_channel_links_and_nodes->proc~allocate_linknode_storage proc~case_simple_channel_initialize case_simple_channel_initialize proc~case_simple_channel_initialize->proc~case_simple_channel_links_and_nodes proc~case_y_channel_initialize case_y_channel_initialize proc~case_y_channel_initialize->proc~case_y_channel_links_and_nodes proc~test_case_initiation test_case_initiation proc~test_case_initiation->proc~case_y_channel_initialize program~main main program~main->proc~test_case_initiation var panprocallocate_linknode_storageCalledByGraph = svgPanZoom('#procallocate_linknode_storageCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"allocate_linknode_storage – SWMMengine","tags":"","loc":"proc/allocate_linknode_storage.html"},{"text":"public subroutine allocate_data_storage(elem2R, elemMR, faceR, elem2I, elemMI, faceI, elem2YN, elemMYN, faceYN, elem2Name, elemMName, faceName) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:,:), allocatable, target :: elem2R real, intent(out), dimension(:,:), allocatable, target :: elemMR real, intent(out), dimension(:,:), allocatable, target :: faceR integer, intent(out), dimension(:,:), allocatable, target :: elem2I integer, intent(out), dimension(:,:), allocatable, target :: elemMI integer, intent(out), dimension(:,:), allocatable, target :: faceI logical, intent(out), dimension(:,:), allocatable, target :: elem2YN logical, intent(out), dimension(:,:), allocatable, target :: elemMYN logical, intent(out), dimension(:,:), allocatable, target :: faceYN type(string), intent(out), dimension(:), allocatable, target :: elem2Name type(string), intent(out), dimension(:), allocatable, target :: elemMName type(string), intent(out), dimension(:), allocatable, target :: faceName Calls proc~~allocate_data_storage~~CallsGraph proc~allocate_data_storage allocate_data_storage proc~utility_check_allocation utility_check_allocation proc~allocate_data_storage->proc~utility_check_allocation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~allocate_data_storage~~CalledByGraph proc~allocate_data_storage allocate_data_storage proc~network_initiation network_initiation proc~network_initiation->proc~allocate_data_storage program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"allocate_data_storage – SWMMengine","tags":"","loc":"proc/allocate_data_storage.html"},{"text":"public subroutine explicit_test_advance(elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, faceI, faceYN, bcdataDn, bcdataUp, thistime, dt) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(inout), target :: elem2I (:,:) logical, intent(inout), target :: elem2YN (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(inout), target :: elemMI (:,:) logical, intent(inout), target :: elemMYN (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(inout), target :: faceI (:,:) logical, intent(inout), target :: faceYN (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) real, intent(in) :: thistime real, intent(in) :: dt Calls proc~~explicit_test_advance~~CallsGraph proc~explicit_test_advance explicit_test_advance proc~bc_applied_onelement bc_applied_onelement proc~explicit_test_advance->proc~bc_applied_onelement e2r_temp e2r_temp proc~explicit_test_advance->e2r_temp proc~utility_advance_temp_array utility_advance_temp_array proc~explicit_test_advance->proc~utility_advance_temp_array proc~bc_applied_onface bc_applied_onface proc~explicit_test_advance->proc~bc_applied_onface fi_temp fi_temp proc~explicit_test_advance->fi_temp proc~test_face_update test_face_update proc~explicit_test_advance->proc~test_face_update proc~adjust_vshaped_flowrate adjust_Vshaped_flowrate proc~explicit_test_advance->proc~adjust_vshaped_flowrate proc~bc_onelement bc_onelement proc~bc_applied_onelement->proc~bc_onelement proc~bc_onface bc_onface proc~bc_applied_onface->proc~bc_onface proc~bc_face_othervalues bc_face_othervalues proc~bc_applied_onface->proc~bc_face_othervalues proc~bc_ghost_othervalues bc_ghost_othervalues proc~bc_applied_onface->proc~bc_ghost_othervalues proc~test_face_update->e2r_temp proc~test_face_update->proc~utility_advance_temp_array proc~adjust_vshaped_flowrate->e2r_temp proc~adjust_vshaped_flowrate->proc~utility_advance_temp_array e2yn_temp e2yn_temp proc~adjust_vshaped_flowrate->e2yn_temp proc~utility_sign_with_ones utility_sign_with_ones proc~adjust_vshaped_flowrate->proc~utility_sign_with_ones proc~bc_updatevalue bc_updatevalue proc~bc_onface->proc~bc_updatevalue proc~bc_onelement->proc~bc_updatevalue proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist var panprocexplicit_test_advanceCallsGraph = svgPanZoom('#procexplicit_test_advanceCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"explicit_test_advance – SWMMengine","tags":"","loc":"proc/explicit_test_advance.html"},{"text":"private subroutine test_face_update(elem2R, elem2I, faceR, faceI, elemUp2) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(inout), target :: elem2I (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(inout), target :: faceI (:,:) integer, intent(inout) :: elemUp2 (:) Calls proc~~test_face_update~~CallsGraph proc~test_face_update test_face_update proc~utility_advance_temp_array utility_advance_temp_array proc~test_face_update->proc~utility_advance_temp_array e2r_temp e2r_temp proc~test_face_update->e2r_temp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~test_face_update~~CalledByGraph proc~test_face_update test_face_update proc~explicit_test_advance explicit_test_advance proc~explicit_test_advance->proc~test_face_update Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"test_face_update – SWMMengine","tags":"","loc":"proc/test_face_update.html"},{"text":"private subroutine quadratic_face_update(elem2R, elem2I, faceR, faceI, elemUp2) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(inout), target :: elem2I (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(inout), target :: faceI (:,:) integer, intent(inout) :: elemUp2 (:) Contents None","title":"quadratic_face_update – SWMMengine","tags":"","loc":"proc/quadratic_face_update.html"},{"text":"public subroutine explicit_euler_advance(elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, faceI, faceYN, bcdataDn, bcdataUp, thistime, dt) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(inout), target :: elem2I (:,:) logical, intent(inout), target :: elem2YN (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(inout), target :: elemMI (:,:) logical, intent(inout), target :: elemMYN (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(inout), target :: faceI (:,:) logical, intent(inout), target :: faceYN (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) real, intent(in) :: thistime real, intent(in) :: dt Calls proc~~explicit_euler_advance~~CallsGraph proc~explicit_euler_advance explicit_euler_advance proc~bc_applied_onelement bc_applied_onelement proc~explicit_euler_advance->proc~bc_applied_onelement e2r_temp e2r_temp proc~explicit_euler_advance->e2r_temp proc~utility_advance_temp_array utility_advance_temp_array proc~explicit_euler_advance->proc~utility_advance_temp_array proc~bc_applied_onface bc_applied_onface proc~explicit_euler_advance->proc~bc_applied_onface fi_temp fi_temp proc~explicit_euler_advance->fi_temp proc~adjust_vshaped_flowrate adjust_Vshaped_flowrate proc~explicit_euler_advance->proc~adjust_vshaped_flowrate proc~bc_onelement bc_onelement proc~bc_applied_onelement->proc~bc_onelement proc~bc_onface bc_onface proc~bc_applied_onface->proc~bc_onface proc~bc_face_othervalues bc_face_othervalues proc~bc_applied_onface->proc~bc_face_othervalues proc~bc_ghost_othervalues bc_ghost_othervalues proc~bc_applied_onface->proc~bc_ghost_othervalues proc~adjust_vshaped_flowrate->e2r_temp proc~adjust_vshaped_flowrate->proc~utility_advance_temp_array e2yn_temp e2yn_temp proc~adjust_vshaped_flowrate->e2yn_temp proc~utility_sign_with_ones utility_sign_with_ones proc~adjust_vshaped_flowrate->proc~utility_sign_with_ones proc~bc_updatevalue bc_updatevalue proc~bc_onface->proc~bc_updatevalue proc~bc_onelement->proc~bc_updatevalue proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist var panprocexplicit_euler_advanceCallsGraph = svgPanZoom('#procexplicit_euler_advanceCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"explicit_euler_advance – SWMMengine","tags":"","loc":"proc/explicit_euler_advance.html"},{"text":"public subroutine junction_adjacent_element_average(elem2R, elemMR, elemMI, faceI, e2r_data, eMr_out) Arguments Type Intent Optional Attributes Name real, intent(in) :: elem2R (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: faceI (:,:) integer, intent(in) :: e2r_data integer, intent(in) :: eMr_out Calls proc~~junction_adjacent_element_average~~CallsGraph proc~junction_adjacent_element_average junction_adjacent_element_average proc~utility_advance_temp_array utility_advance_temp_array proc~junction_adjacent_element_average->proc~utility_advance_temp_array emr_temp emr_temp proc~junction_adjacent_element_average->emr_temp proc~junction_summation_from_adjacent_elements_one_direction junction_summation_from_adjacent_elements_one_direction proc~junction_adjacent_element_average->proc~junction_summation_from_adjacent_elements_one_direction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~junction_adjacent_element_average~~CalledByGraph proc~junction_adjacent_element_average junction_adjacent_element_average proc~initial_junction_conditions initial_junction_conditions proc~initial_junction_conditions->proc~junction_adjacent_element_average proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~initial_junction_conditions program~main main program~main->proc~initial_condition_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_adjacent_element_average – SWMMengine","tags":"","loc":"proc/junction_adjacent_element_average.html"},{"text":"public subroutine junction_adjacent_element_values_to_branches(elem2R, elemMR, elemMI, faceI, e2r_data, eMr_outUp, eMr_outDn) Arguments Type Intent Optional Attributes Name real, intent(in) :: elem2R (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: faceI (:,:) integer, intent(in) :: e2r_data integer, intent(in) :: eMr_outUp (:) integer, intent(in) :: eMr_outDn (:) Calls proc~~junction_adjacent_element_values_to_branches~~CallsGraph proc~junction_adjacent_element_values_to_branches junction_adjacent_element_values_to_branches proc~junction_adjacent_element_values_one_direction junction_adjacent_element_values_one_direction proc~junction_adjacent_element_values_to_branches->proc~junction_adjacent_element_values_one_direction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~junction_adjacent_element_values_to_branches~~CalledByGraph proc~junction_adjacent_element_values_to_branches junction_adjacent_element_values_to_branches proc~initial_junction_conditions initial_junction_conditions proc~initial_junction_conditions->proc~junction_adjacent_element_values_to_branches proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~initial_junction_conditions program~main main program~main->proc~initial_condition_setup var panprocjunction_adjacent_element_values_to_branchesCalledByGraph = svgPanZoom('#procjunction_adjacent_element_values_to_branchesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_adjacent_element_values_to_branches – SWMMengine","tags":"","loc":"proc/junction_adjacent_element_values_to_branches.html"},{"text":"public subroutine junction_branch_assigned_to_faces(faceI, elemMI) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: faceI (:,:) integer, intent(in) :: elemMI (:,:) Calls proc~~junction_branch_assigned_to_faces~~CallsGraph proc~junction_branch_assigned_to_faces junction_branch_assigned_to_faces emi_mfacedn emi_mfacedn proc~junction_branch_assigned_to_faces->emi_mfacedn emi_mfaceup emi_mfaceup proc~junction_branch_assigned_to_faces->emi_mfaceup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~junction_branch_assigned_to_faces~~CalledByGraph proc~junction_branch_assigned_to_faces junction_branch_assigned_to_faces proc~network_initiation network_initiation proc~network_initiation->proc~junction_branch_assigned_to_faces program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_branch_assigned_to_faces – SWMMengine","tags":"","loc":"proc/junction_branch_assigned_to_faces.html"},{"text":"public subroutine junction_branch_average_of_inflows_and_outflows(elemMR, elemMI) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) Calls proc~~junction_branch_average_of_inflows_and_outflows~~CallsGraph proc~junction_branch_average_of_inflows_and_outflows junction_branch_average_of_inflows_and_outflows proc~utility_advance_temp_array utility_advance_temp_array proc~junction_branch_average_of_inflows_and_outflows->proc~utility_advance_temp_array proc~junction_net_inflow_and_outflow junction_net_inflow_and_outflow proc~junction_branch_average_of_inflows_and_outflows->proc~junction_net_inflow_and_outflow emr_temp emr_temp proc~junction_branch_average_of_inflows_and_outflows->emr_temp proc~junction_net_flow_in_or_out junction_net_flow_in_or_out proc~junction_net_inflow_and_outflow->proc~junction_net_flow_in_or_out var panprocjunction_branch_average_of_inflows_and_outflowsCallsGraph = svgPanZoom('#procjunction_branch_average_of_inflows_and_outflowsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~junction_branch_average_of_inflows_and_outflows~~CalledByGraph proc~junction_branch_average_of_inflows_and_outflows junction_branch_average_of_inflows_and_outflows proc~initial_junction_conditions initial_junction_conditions proc~initial_junction_conditions->proc~junction_branch_average_of_inflows_and_outflows proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~initial_junction_conditions program~main main program~main->proc~initial_condition_setup var panprocjunction_branch_average_of_inflows_and_outflowsCalledByGraph = svgPanZoom('#procjunction_branch_average_of_inflows_and_outflowsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_branch_average_of_inflows_and_outflows – SWMMengine","tags":"","loc":"proc/junction_branch_average_of_inflows_and_outflows.html"},{"text":"public subroutine junction_branch_velocity_and_flowrate_proportional_to_area(eMR_totalarea, eMR_totalflowrate, this_face_per_elem, eMr_AreaThis, eMi_MfaceThis, eMi_nfaces_This, eMr_FlowrateThis, eMr_VelocityThis, rdir_face_per_elem, eMr_AreaRdir, eMi_MfaceRdir, eMi_nfaces_Rdir, eMr_FlowrateRdir, eMr_VelocityRdir, elemMR, elemMI, faceR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMR_totalarea integer, intent(in) :: eMR_totalflowrate integer, intent(in) :: this_face_per_elem integer, intent(in) :: eMr_AreaThis (:) integer, intent(in) :: eMi_MfaceThis (:) integer, intent(in) :: eMi_nfaces_This integer, intent(in) :: eMr_FlowrateThis (:) integer, intent(in) :: eMr_VelocityThis (:) integer, intent(in) :: rdir_face_per_elem integer, intent(in) :: eMr_AreaRdir (:) integer, intent(in) :: eMi_MfaceRdir (:) integer, intent(in) :: eMi_nfaces_Rdir integer, intent(in) :: eMr_FlowrateRdir (:) integer, intent(in) :: eMr_VelocityRdir (:) real, intent(inout), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(in) :: faceR (:,:) Called by proc~~junction_branch_velocity_and_flowrate_proportional_to_area~~CalledByGraph proc~junction_branch_velocity_and_flowrate_proportional_to_area junction_branch_velocity_and_flowrate_proportional_to_area proc~element_flowrate_update element_flowrate_update proc~element_flowrate_update->proc~junction_branch_velocity_and_flowrate_proportional_to_area proc~element_geometry_branch_fix element_geometry_branch_fix proc~element_geometry_branch_fix->proc~junction_branch_velocity_and_flowrate_proportional_to_area proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~element_flowrate_update proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_branch_fix proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~time_marching->proc~rk2 var panprocjunction_branch_velocity_and_flowrate_proportional_to_areaCalledByGraph = svgPanZoom('#procjunction_branch_velocity_and_flowrate_proportional_to_areaCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_branch_velocity_and_flowrate_proportional_to_area – SWMMengine","tags":"","loc":"proc/junction_branch_velocity_and_flowrate_proportional_to_area.html"},{"text":"public subroutine junction_branch_sum_areas_by_direction(eMR_totalarea, this_face_per_element, eMr_AreaThis, eMi_MfaceThis, eMi_nfaces_This, rdir_face_per_element, eMr_AreaRdir, eMi_MfaceRdir, eMi_nfaces_Rdir, elemMR, elemMI, faceR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMR_totalarea integer, intent(in) :: this_face_per_element integer, intent(in) :: eMr_AreaThis (:) integer, intent(in) :: eMi_MfaceThis (:) integer, intent(in) :: eMi_nfaces_This integer, intent(in) :: rdir_face_per_element integer, intent(in) :: eMr_AreaRdir (:) integer, intent(in) :: eMi_MfaceRdir (:) integer, intent(in) :: eMi_nfaces_Rdir real, intent(inout), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(in) :: faceR (:,:) Called by proc~~junction_branch_sum_areas_by_direction~~CalledByGraph proc~junction_branch_sum_areas_by_direction junction_branch_sum_areas_by_direction proc~element_flowrate_update element_flowrate_update proc~element_flowrate_update->proc~junction_branch_sum_areas_by_direction proc~element_geometry_branch_fix element_geometry_branch_fix proc~element_geometry_branch_fix->proc~junction_branch_sum_areas_by_direction proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~element_flowrate_update proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_branch_fix proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~time_marching->proc~rk2 var panprocjunction_branch_sum_areas_by_directionCalledByGraph = svgPanZoom('#procjunction_branch_sum_areas_by_directionCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_branch_sum_areas_by_direction – SWMMengine","tags":"","loc":"proc/junction_branch_sum_areas_by_direction.html"},{"text":"public subroutine junction_branch_velocities(elemMR, elemMI) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) Calls proc~~junction_branch_velocities~~CallsGraph proc~junction_branch_velocities junction_branch_velocities proc~junction_branch_velocities_one_direction junction_branch_velocities_one_direction proc~junction_branch_velocities->proc~junction_branch_velocities_one_direction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~junction_branch_velocities~~CalledByGraph proc~junction_branch_velocities junction_branch_velocities proc~initial_junction_conditions initial_junction_conditions proc~initial_junction_conditions->proc~junction_branch_velocities proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~initial_junction_conditions program~main main program~main->proc~initial_condition_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_branch_velocities – SWMMengine","tags":"","loc":"proc/junction_branch_velocities.html"},{"text":"public subroutine junction_geometry_setup(elemMR, elemMI) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) Calls proc~~junction_geometry_setup~~CallsGraph proc~junction_geometry_setup junction_geometry_setup proc~junction_branch_summation_and_updown_average junction_branch_summation_and_updown_average proc~junction_geometry_setup->proc~junction_branch_summation_and_updown_average proc~junction_branch_average_for_directions_then_sum junction_branch_average_for_directions_then_sum proc~junction_geometry_setup->proc~junction_branch_average_for_directions_then_sum proc~utility_advance_temp_array utility_advance_temp_array proc~junction_branch_summation_and_updown_average->proc~utility_advance_temp_array proc~junction_branch_summation_one_direction junction_branch_summation_one_direction proc~junction_branch_summation_and_updown_average->proc~junction_branch_summation_one_direction emr_temp emr_temp proc~junction_branch_summation_and_updown_average->emr_temp proc~junction_branch_average_for_directions_then_sum->proc~utility_advance_temp_array proc~junction_branch_average_for_directions_then_sum->proc~junction_branch_summation_one_direction proc~junction_branch_average_for_directions_then_sum->emr_temp var panprocjunction_geometry_setupCallsGraph = svgPanZoom('#procjunction_geometry_setupCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~junction_geometry_setup~~CalledByGraph proc~junction_geometry_setup junction_geometry_setup proc~network_initiation network_initiation proc~network_initiation->proc~junction_geometry_setup program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_geometry_setup – SWMMengine","tags":"","loc":"proc/junction_geometry_setup.html"},{"text":"private subroutine junction_adjacent_element_values_one_direction(elem2R, elemMR, elemMI, faceI, dir_face_per_elemM, eMi_nfaces_dir, eMi_MfaceDir, fi_Melem_dir, e2r_data, eMr_outDir) Arguments Type Intent Optional Attributes Name real, intent(in) :: elem2R (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) integer, intent(in), target :: faceI (:,:) integer, intent(in) :: dir_face_per_elemM integer, intent(in) :: eMi_nfaces_dir integer, intent(in) :: eMi_MfaceDir (:) integer, intent(in) :: fi_Melem_dir integer, intent(in) :: e2r_data integer, intent(in) :: eMr_outDir (:) Called by proc~~junction_adjacent_element_values_one_direction~~CalledByGraph proc~junction_adjacent_element_values_one_direction junction_adjacent_element_values_one_direction proc~junction_adjacent_element_values_to_branches junction_adjacent_element_values_to_branches proc~junction_adjacent_element_values_to_branches->proc~junction_adjacent_element_values_one_direction proc~initial_junction_conditions initial_junction_conditions proc~initial_junction_conditions->proc~junction_adjacent_element_values_to_branches proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~initial_junction_conditions program~main main program~main->proc~initial_condition_setup var panprocjunction_adjacent_element_values_one_directionCalledByGraph = svgPanZoom('#procjunction_adjacent_element_values_one_directionCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_adjacent_element_values_one_direction – SWMMengine","tags":"","loc":"proc/junction_adjacent_element_values_one_direction.html"},{"text":"private subroutine junction_branch_average(eMr_avgvalue, elemMR, elemMI, eMr_column_up, eMr_column_dn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMr_avgvalue real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: eMr_column_up (:) integer, intent(in) :: eMr_column_dn (:) Calls proc~~junction_branch_average~~CallsGraph proc~junction_branch_average junction_branch_average proc~junction_branch_summation junction_branch_summation proc~junction_branch_average->proc~junction_branch_summation proc~junction_branch_summation_one_direction junction_branch_summation_one_direction proc~junction_branch_summation->proc~junction_branch_summation_one_direction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_branch_average – SWMMengine","tags":"","loc":"proc/junction_branch_average.html"},{"text":"private subroutine junction_branch_average_for_directions_then_sum(elemMR, elemMI, eMr_columnUp, eMr_columnDn, eMr_out) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: eMr_columnUp (:) integer, intent(in) :: eMr_columnDn (:) integer, intent(in) :: eMr_out Calls proc~~junction_branch_average_for_directions_then_sum~~CallsGraph proc~junction_branch_average_for_directions_then_sum junction_branch_average_for_directions_then_sum proc~utility_advance_temp_array utility_advance_temp_array proc~junction_branch_average_for_directions_then_sum->proc~utility_advance_temp_array proc~junction_branch_summation_one_direction junction_branch_summation_one_direction proc~junction_branch_average_for_directions_then_sum->proc~junction_branch_summation_one_direction emr_temp emr_temp proc~junction_branch_average_for_directions_then_sum->emr_temp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~junction_branch_average_for_directions_then_sum~~CalledByGraph proc~junction_branch_average_for_directions_then_sum junction_branch_average_for_directions_then_sum proc~junction_geometry_setup junction_geometry_setup proc~junction_geometry_setup->proc~junction_branch_average_for_directions_then_sum proc~network_initiation network_initiation proc~network_initiation->proc~junction_geometry_setup program~main main program~main->proc~network_initiation var panprocjunction_branch_average_for_directions_then_sumCalledByGraph = svgPanZoom('#procjunction_branch_average_for_directions_then_sumCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_branch_average_for_directions_then_sum – SWMMengine","tags":"","loc":"proc/junction_branch_average_for_directions_then_sum.html"},{"text":"private subroutine junction_branch_summation(eMr_sumvalue, elemMR, elemMI, eMr_column_up, eMr_column_dn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMr_sumvalue real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: eMr_column_up (:) integer, intent(in) :: eMr_column_dn (:) Calls proc~~junction_branch_summation~~CallsGraph proc~junction_branch_summation junction_branch_summation proc~junction_branch_summation_one_direction junction_branch_summation_one_direction proc~junction_branch_summation->proc~junction_branch_summation_one_direction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~junction_branch_summation~~CalledByGraph proc~junction_branch_summation junction_branch_summation proc~junction_branch_average junction_branch_average proc~junction_branch_average->proc~junction_branch_summation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_branch_summation – SWMMengine","tags":"","loc":"proc/junction_branch_summation.html"},{"text":"private subroutine junction_branch_summation_and_updown_average(elemMR, elemMI, eMr_columnUp, eMr_columnDn, eMr_out) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: eMr_columnUp (:) integer, intent(in) :: eMr_columnDn (:) integer, intent(in) :: eMr_out Calls proc~~junction_branch_summation_and_updown_average~~CallsGraph proc~junction_branch_summation_and_updown_average junction_branch_summation_and_updown_average proc~utility_advance_temp_array utility_advance_temp_array proc~junction_branch_summation_and_updown_average->proc~utility_advance_temp_array proc~junction_branch_summation_one_direction junction_branch_summation_one_direction proc~junction_branch_summation_and_updown_average->proc~junction_branch_summation_one_direction emr_temp emr_temp proc~junction_branch_summation_and_updown_average->emr_temp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~junction_branch_summation_and_updown_average~~CalledByGraph proc~junction_branch_summation_and_updown_average junction_branch_summation_and_updown_average proc~junction_geometry_setup junction_geometry_setup proc~junction_geometry_setup->proc~junction_branch_summation_and_updown_average proc~network_initiation network_initiation proc~network_initiation->proc~junction_geometry_setup program~main main program~main->proc~network_initiation var panprocjunction_branch_summation_and_updown_averageCalledByGraph = svgPanZoom('#procjunction_branch_summation_and_updown_averageCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_branch_summation_and_updown_average – SWMMengine","tags":"","loc":"proc/junction_branch_summation_and_updown_average.html"},{"text":"private subroutine junction_branch_summation_one_direction(eMr_sumvalue, elemMR, elemMI, face_per_elemM, eMi_nfaces_dir, eMr_columnDir) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMr_sumvalue real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: face_per_elemM integer, intent(in) :: eMi_nfaces_dir integer, intent(in) :: eMr_columnDir (:) Called by proc~~junction_branch_summation_one_direction~~CalledByGraph proc~junction_branch_summation_one_direction junction_branch_summation_one_direction proc~junction_branch_summation_and_updown_average junction_branch_summation_and_updown_average proc~junction_branch_summation_and_updown_average->proc~junction_branch_summation_one_direction proc~junction_branch_average_for_directions_then_sum junction_branch_average_for_directions_then_sum proc~junction_branch_average_for_directions_then_sum->proc~junction_branch_summation_one_direction proc~junction_branch_summation junction_branch_summation proc~junction_branch_summation->proc~junction_branch_summation_one_direction proc~junction_geometry_setup junction_geometry_setup proc~junction_geometry_setup->proc~junction_branch_summation_and_updown_average proc~junction_geometry_setup->proc~junction_branch_average_for_directions_then_sum proc~junction_branch_average junction_branch_average proc~junction_branch_average->proc~junction_branch_summation proc~network_initiation network_initiation proc~network_initiation->proc~junction_geometry_setup program~main main program~main->proc~network_initiation var panprocjunction_branch_summation_one_directionCalledByGraph = svgPanZoom('#procjunction_branch_summation_one_directionCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_branch_summation_one_direction – SWMMengine","tags":"","loc":"proc/junction_branch_summation_one_direction.html"},{"text":"private subroutine junction_branch_velocities_one_direction(elemMR, elemMI, dir_face_per_elemM, eMi_nfaces_dir, eMr_FlowrateDir, eMr_AreaDir, eMr_VelocityDir) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: dir_face_per_elemM integer, intent(in) :: eMi_nfaces_dir integer, intent(in) :: eMr_FlowrateDir (:) integer, intent(in) :: eMr_AreaDir (:) integer, intent(in) :: eMr_VelocityDir (:) Called by proc~~junction_branch_velocities_one_direction~~CalledByGraph proc~junction_branch_velocities_one_direction junction_branch_velocities_one_direction proc~junction_branch_velocities junction_branch_velocities proc~junction_branch_velocities->proc~junction_branch_velocities_one_direction proc~initial_junction_conditions initial_junction_conditions proc~initial_junction_conditions->proc~junction_branch_velocities proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~initial_junction_conditions program~main main program~main->proc~initial_condition_setup var panprocjunction_branch_velocities_one_directionCalledByGraph = svgPanZoom('#procjunction_branch_velocities_one_directionCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_branch_velocities_one_direction – SWMMengine","tags":"","loc":"proc/junction_branch_velocities_one_direction.html"},{"text":"private subroutine junction_net_flow_in_or_out(eMr_flow, elemMR, elemMI, dir_face_per_elemM, eMi_nfaces_dir, eMr_FlowrateDir1, eMr_flowrateDir2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMr_flow real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: dir_face_per_elemM integer, intent(in) :: eMi_nfaces_dir integer, intent(in) :: eMr_FlowrateDir1 (:) integer, intent(in) :: eMr_flowrateDir2 (:) Called by proc~~junction_net_flow_in_or_out~~CalledByGraph proc~junction_net_flow_in_or_out junction_net_flow_in_or_out proc~junction_net_inflow_and_outflow junction_net_inflow_and_outflow proc~junction_net_inflow_and_outflow->proc~junction_net_flow_in_or_out proc~junction_branch_average_of_inflows_and_outflows junction_branch_average_of_inflows_and_outflows proc~junction_branch_average_of_inflows_and_outflows->proc~junction_net_inflow_and_outflow proc~initial_junction_conditions initial_junction_conditions proc~initial_junction_conditions->proc~junction_branch_average_of_inflows_and_outflows proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~initial_junction_conditions program~main main program~main->proc~initial_condition_setup var panprocjunction_net_flow_in_or_outCalledByGraph = svgPanZoom('#procjunction_net_flow_in_or_outCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_net_flow_in_or_out – SWMMengine","tags":"","loc":"proc/junction_net_flow_in_or_out.html"},{"text":"private subroutine junction_net_inflow_and_outflow(eMr_inflow, eMr_outflow, elemMR, elemMI) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMr_inflow integer, intent(in) :: eMr_outflow real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) Calls proc~~junction_net_inflow_and_outflow~~CallsGraph proc~junction_net_inflow_and_outflow junction_net_inflow_and_outflow proc~junction_net_flow_in_or_out junction_net_flow_in_or_out proc~junction_net_inflow_and_outflow->proc~junction_net_flow_in_or_out Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~junction_net_inflow_and_outflow~~CalledByGraph proc~junction_net_inflow_and_outflow junction_net_inflow_and_outflow proc~junction_branch_average_of_inflows_and_outflows junction_branch_average_of_inflows_and_outflows proc~junction_branch_average_of_inflows_and_outflows->proc~junction_net_inflow_and_outflow proc~initial_junction_conditions initial_junction_conditions proc~initial_junction_conditions->proc~junction_branch_average_of_inflows_and_outflows proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~initial_junction_conditions program~main main program~main->proc~initial_condition_setup var panprocjunction_net_inflow_and_outflowCalledByGraph = svgPanZoom('#procjunction_net_inflow_and_outflowCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_net_inflow_and_outflow – SWMMengine","tags":"","loc":"proc/junction_net_inflow_and_outflow.html"},{"text":"private subroutine junction_summation_from_adjacent_elements_one_direction(eMr_sumvalue, elem2R, elemMR, elemMI, faceI, dir_face_per_elemM, eMi_nfaces_dir, eMi_MfaceDir, fi_Melem_dir, e2r_data) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMr_sumvalue real, intent(in) :: elem2R (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) integer, intent(in), target :: faceI (:,:) integer, intent(in) :: dir_face_per_elemM integer, intent(in) :: eMi_nfaces_dir integer, intent(in) :: eMi_MfaceDir (:) integer, intent(in) :: fi_Melem_dir integer, intent(in) :: e2r_data Called by proc~~junction_summation_from_adjacent_elements_one_direction~~CalledByGraph proc~junction_summation_from_adjacent_elements_one_direction junction_summation_from_adjacent_elements_one_direction proc~junction_adjacent_element_average junction_adjacent_element_average proc~junction_adjacent_element_average->proc~junction_summation_from_adjacent_elements_one_direction proc~initial_junction_conditions initial_junction_conditions proc~initial_junction_conditions->proc~junction_adjacent_element_average proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~initial_junction_conditions program~main main program~main->proc~initial_condition_setup var panprocjunction_summation_from_adjacent_elements_one_directionCalledByGraph = svgPanZoom('#procjunction_summation_from_adjacent_elements_one_directionCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"junction_summation_from_adjacent_elements_one_direction – SWMMengine","tags":"","loc":"proc/junction_summation_from_adjacent_elements_one_direction.html"},{"text":"public subroutine initialize_arrayindex() Arguments None Calls proc~~initialize_arrayindex~~CallsGraph proc~initialize_arrayindex initialize_arrayindex emr_timescaleall emr_timescaleall proc~initialize_arrayindex->emr_timescaleall emi_temp emi_temp proc~initialize_arrayindex->emi_temp emi_mfaceup emi_mfaceup proc~initialize_arrayindex->emi_mfaceup emr_breadthscaleup emr_breadthscaleup proc~initialize_arrayindex->emr_breadthscaleup emr_lengthdn emr_lengthdn proc~initialize_arrayindex->emr_lengthdn emr_zbottomall emr_zbottomall proc~initialize_arrayindex->emr_zbottomall emr_velocitydn emr_velocitydn proc~initialize_arrayindex->emr_velocitydn emr_areadn emr_areadn proc~initialize_arrayindex->emr_areadn emr_etaup emr_etaup proc~initialize_arrayindex->emr_etaup emr_etaall emr_etaall proc~initialize_arrayindex->emr_etaall nr_elementlengthdn nr_elementlengthdn proc~initialize_arrayindex->nr_elementlengthdn fi_temp fi_temp proc~initialize_arrayindex->fi_temp emr_etadn emr_etadn proc~initialize_arrayindex->emr_etadn emr_lengthup emr_lengthup proc~initialize_arrayindex->emr_lengthup fyn_temp fyn_temp proc~initialize_arrayindex->fyn_temp emr_timescaleup emr_timescaleup proc~initialize_arrayindex->emr_timescaleup emr_breadthscaleall emr_breadthscaleall proc~initialize_arrayindex->emr_breadthscaleall emr_temp emr_temp proc~initialize_arrayindex->emr_temp fr_temp fr_temp proc~initialize_arrayindex->fr_temp emr_flowrateall emr_flowrateall proc~initialize_arrayindex->emr_flowrateall emr_flowratedn emr_flowratedn proc~initialize_arrayindex->emr_flowratedn emr_topwidthup emr_topwidthup proc~initialize_arrayindex->emr_topwidthup emr_topwidthall emr_topwidthall proc~initialize_arrayindex->emr_topwidthall e2i_temp e2i_temp proc~initialize_arrayindex->e2i_temp emr_timescaledn emr_timescaledn proc~initialize_arrayindex->emr_timescaledn emr_velocityall emr_velocityall proc~initialize_arrayindex->emr_velocityall ni_mlinkdn ni_mlinkdn proc~initialize_arrayindex->ni_mlinkdn emr_areaup emr_areaup proc~initialize_arrayindex->emr_areaup nr_elementlengthup nr_elementlengthup proc~initialize_arrayindex->nr_elementlengthup emr_zbottomdn emr_zbottomdn proc~initialize_arrayindex->emr_zbottomdn emr_topwidthdn emr_topwidthdn proc~initialize_arrayindex->emr_topwidthdn emi_mfacedn emi_mfacedn proc~initialize_arrayindex->emi_mfacedn emi_mfaceall emi_mfaceall proc~initialize_arrayindex->emi_mfaceall e2yn_temp e2yn_temp proc~initialize_arrayindex->e2yn_temp e2r_temp e2r_temp proc~initialize_arrayindex->e2r_temp emr_flowrateup emr_flowrateup proc~initialize_arrayindex->emr_flowrateup emr_velocityup emr_velocityup proc~initialize_arrayindex->emr_velocityup ni_mlinkup ni_mlinkup proc~initialize_arrayindex->ni_mlinkup emr_zbottomup emr_zbottomup proc~initialize_arrayindex->emr_zbottomup emr_breadthscaledn emr_breadthscaledn proc~initialize_arrayindex->emr_breadthscaledn emr_areaall emr_areaall proc~initialize_arrayindex->emr_areaall emr_lengthall emr_lengthall proc~initialize_arrayindex->emr_lengthall emr_hyddepthup emr_hyddepthup proc~initialize_arrayindex->emr_hyddepthup emyn_temp emyn_temp proc~initialize_arrayindex->emyn_temp emr_hyddepthdn emr_hyddepthdn proc~initialize_arrayindex->emr_hyddepthdn emr_hyddepthall emr_hyddepthall proc~initialize_arrayindex->emr_hyddepthall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialize_arrayindex~~CalledByGraph proc~initialize_arrayindex initialize_arrayindex program~main main program~main->proc~initialize_arrayindex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"initialize_arrayindex – SWMMengine","tags":"","loc":"proc/initialize_arrayindex.html"},{"text":"public subroutine initialize_arrayindex_status() Arguments None Calls proc~~initialize_arrayindex_status~~CallsGraph proc~initialize_arrayindex_status initialize_arrayindex_status emi_mfaceup emi_mfaceup proc~initialize_arrayindex_status->emi_mfaceup emr_breadthscaleup emr_breadthscaleup proc~initialize_arrayindex_status->emr_breadthscaleup emr_lengthdn emr_lengthdn proc~initialize_arrayindex_status->emr_lengthdn emr_velocitydn emr_velocitydn proc~initialize_arrayindex_status->emr_velocitydn emr_areadn emr_areadn proc~initialize_arrayindex_status->emr_areadn emr_etaup emr_etaup proc~initialize_arrayindex_status->emr_etaup nr_elementlengthdn nr_elementlengthdn proc~initialize_arrayindex_status->nr_elementlengthdn emr_etadn emr_etadn proc~initialize_arrayindex_status->emr_etadn emr_lengthup emr_lengthup proc~initialize_arrayindex_status->emr_lengthup emr_timescaleup emr_timescaleup proc~initialize_arrayindex_status->emr_timescaleup emr_temp emr_temp proc~initialize_arrayindex_status->emr_temp emr_flowratedn emr_flowratedn proc~initialize_arrayindex_status->emr_flowratedn emr_topwidthup emr_topwidthup proc~initialize_arrayindex_status->emr_topwidthup emr_timescaledn emr_timescaledn proc~initialize_arrayindex_status->emr_timescaledn ni_mlinkdn ni_mlinkdn proc~initialize_arrayindex_status->ni_mlinkdn emr_areaup emr_areaup proc~initialize_arrayindex_status->emr_areaup nr_elementlengthup nr_elementlengthup proc~initialize_arrayindex_status->nr_elementlengthup emr_zbottomdn emr_zbottomdn proc~initialize_arrayindex_status->emr_zbottomdn emr_topwidthdn emr_topwidthdn proc~initialize_arrayindex_status->emr_topwidthdn emi_mfacedn emi_mfacedn proc~initialize_arrayindex_status->emi_mfacedn e2r_temp e2r_temp proc~initialize_arrayindex_status->e2r_temp emr_flowrateup emr_flowrateup proc~initialize_arrayindex_status->emr_flowrateup emr_velocityup emr_velocityup proc~initialize_arrayindex_status->emr_velocityup ni_mlinkup ni_mlinkup proc~initialize_arrayindex_status->ni_mlinkup emr_zbottomup emr_zbottomup proc~initialize_arrayindex_status->emr_zbottomup emr_breadthscaledn emr_breadthscaledn proc~initialize_arrayindex_status->emr_breadthscaledn emr_hyddepthup emr_hyddepthup proc~initialize_arrayindex_status->emr_hyddepthup emr_hyddepthdn emr_hyddepthdn proc~initialize_arrayindex_status->emr_hyddepthdn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialize_arrayindex_status~~CalledByGraph proc~initialize_arrayindex_status initialize_arrayindex_status program~main main program~main->proc~initialize_arrayindex_status Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"initialize_arrayindex_status – SWMMengine","tags":"","loc":"proc/initialize_arrayindex_status.html"},{"text":"public subroutine initialize_array_zerovalues(elemMR) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elemMR (:,:) Calls proc~~initialize_array_zerovalues~~CallsGraph proc~initialize_array_zerovalues initialize_array_zerovalues emr_topwidthdn emr_topwidthdn proc~initialize_array_zerovalues->emr_topwidthdn emr_topwidthup emr_topwidthup proc~initialize_array_zerovalues->emr_topwidthup emr_lengthdn emr_lengthdn proc~initialize_array_zerovalues->emr_lengthdn emr_hyddepthup emr_hyddepthup proc~initialize_array_zerovalues->emr_hyddepthup emr_areadn emr_areadn proc~initialize_array_zerovalues->emr_areadn emr_areaup emr_areaup proc~initialize_array_zerovalues->emr_areaup emr_hyddepthdn emr_hyddepthdn proc~initialize_array_zerovalues->emr_hyddepthdn emr_lengthup emr_lengthup proc~initialize_array_zerovalues->emr_lengthup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialize_array_zerovalues~~CalledByGraph proc~initialize_array_zerovalues initialize_array_zerovalues proc~network_initiation network_initiation proc~network_initiation->proc~initialize_array_zerovalues program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"initialize_array_zerovalues – SWMMengine","tags":"","loc":"proc/initialize_array_zerovalues.html"},{"text":"public subroutine initialize_dummy_values(elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, faceI, faceYN) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(inout) :: elem2I (:,:) logical, intent(inout) :: elem2YN (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(inout) :: elemMI (:,:) logical, intent(inout) :: elemMYN (:,:) real, intent(inout) :: faceR (:,:) integer, intent(inout) :: faceI (:,:) logical, intent(inout) :: faceYN (:,:) Calls proc~~initialize_dummy_values~~CallsGraph proc~initialize_dummy_values initialize_dummy_values emi_mfacedn emi_mfacedn proc~initialize_dummy_values->emi_mfacedn emi_mfaceup emi_mfaceup proc~initialize_dummy_values->emi_mfaceup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialize_dummy_values~~CalledByGraph proc~initialize_dummy_values initialize_dummy_values proc~network_initiation network_initiation proc~network_initiation->proc~initialize_dummy_values program~main main program~main->proc~network_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"initialize_dummy_values – SWMMengine","tags":"","loc":"proc/initialize_dummy_values.html"},{"text":"public pure function diagnostic_CFL(elemR, er_Timescale_u, er_Timescale_d) result(cflmax) Arguments Type Intent Optional Attributes Name real, intent(in) :: elemR (:,:) integer, intent(in) :: er_Timescale_u integer, intent(in) :: er_Timescale_d Return Value real Called by proc~~diagnostic_cfl~~CalledByGraph proc~diagnostic_cfl diagnostic_CFL proc~time_marching time_marching proc~time_marching->proc~diagnostic_cfl program~main main program~main->proc~time_marching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"diagnostic_CFL – SWMMengine","tags":"","loc":"proc/diagnostic_cfl.html"},{"text":"public subroutine diagnostic_element_volume_conservation_fluxes(elem2R, elem2I, elemMR, elemMI, faceR) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(in) :: faceR (:,:) Calls proc~~diagnostic_element_volume_conservation_fluxes~~CallsGraph proc~diagnostic_element_volume_conservation_fluxes diagnostic_element_volume_conservation_fluxes emi_mfacedn emi_mfacedn proc~diagnostic_element_volume_conservation_fluxes->emi_mfacedn emi_mfaceup emi_mfaceup proc~diagnostic_element_volume_conservation_fluxes->emi_mfaceup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~diagnostic_element_volume_conservation_fluxes~~CalledByGraph proc~diagnostic_element_volume_conservation_fluxes diagnostic_element_volume_conservation_fluxes proc~rk2 rk2 proc~rk2->proc~diagnostic_element_volume_conservation_fluxes proc~time_marching time_marching proc~time_marching->proc~rk2 program~main main program~main->proc~time_marching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"diagnostic_element_volume_conservation_fluxes – SWMMengine","tags":"","loc":"proc/diagnostic_element_volume_conservation_fluxes.html"},{"text":"public subroutine diagnostic_element_volume_conservation(elem2R, elem2I, elemMR, elemMI, e2r_Volume_new, eMr_Volume_new) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: e2r_Volume_new integer, intent(in) :: eMr_Volume_new Called by proc~~diagnostic_element_volume_conservation~~CalledByGraph proc~diagnostic_element_volume_conservation diagnostic_element_volume_conservation proc~rk2 rk2 proc~rk2->proc~diagnostic_element_volume_conservation proc~time_marching time_marching proc~time_marching->proc~rk2 program~main main program~main->proc~time_marching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"diagnostic_element_volume_conservation – SWMMengine","tags":"","loc":"proc/diagnostic_element_volume_conservation.html"},{"text":"public subroutine diagnostic_froude_number(elem2R, elem2I, elemMR, elemMI) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) Calls proc~~diagnostic_froude_number~~CallsGraph proc~diagnostic_froude_number diagnostic_froude_number proc~diagnostic_froude_number_one diagnostic_froude_number_one proc~diagnostic_froude_number->proc~diagnostic_froude_number_one Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~diagnostic_froude_number~~CalledByGraph proc~diagnostic_froude_number diagnostic_froude_number proc~time_marching time_marching proc~time_marching->proc~diagnostic_froude_number program~main main program~main->proc~time_marching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"diagnostic_froude_number – SWMMengine","tags":"","loc":"proc/diagnostic_froude_number.html"},{"text":"public subroutine diagnostic_initialize(diagnostic, elem2R, elem2I, elemMR, elemMI, faceR, bcdataUp, bcdataDn) Arguments Type Intent Optional Attributes Name type(diagnosticType), intent(out), allocatable, dimension(:) :: diagnostic real, intent(inout) :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(inout) :: faceR (:,:) type(bcType), intent(in) :: bcdataUp (:) type(bcType), intent(in) :: bcdataDn (:) Calls proc~~diagnostic_initialize~~CallsGraph proc~diagnostic_initialize diagnostic_initialize proc~diagnostic_volume_conservation diagnostic_volume_conservation proc~diagnostic_initialize->proc~diagnostic_volume_conservation proc~utility_check_allocation utility_check_allocation proc~diagnostic_initialize->proc~utility_check_allocation proc~total_inout_flowrate total_inout_flowrate proc~diagnostic_volume_conservation->proc~total_inout_flowrate proc~inout_flowrate_from_bcdata inout_flowrate_from_bcdata proc~total_inout_flowrate->proc~inout_flowrate_from_bcdata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~diagnostic_initialize~~CalledByGraph proc~diagnostic_initialize diagnostic_initialize program~main main program~main->proc~diagnostic_initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"diagnostic_initialize – SWMMengine","tags":"","loc":"proc/diagnostic_initialize.html"},{"text":"public subroutine diagnostic_volume_conservation(diagnostic, elem2R, elem2I, elemMR, elemMI, faceR, bcdataUp, bcdataDn, thisStep, diagnosticTask) Arguments Type Intent Optional Attributes Name type(diagnosticType), intent(inout) :: diagnostic (:) real, intent(inout) :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(inout) :: faceR (:,:) type(bcType), intent(in) :: bcdataUp (:) type(bcType), intent(in) :: bcdataDn (:) integer, intent(in) :: thisStep integer, intent(in) :: diagnosticTask Calls proc~~diagnostic_volume_conservation~~CallsGraph proc~diagnostic_volume_conservation diagnostic_volume_conservation proc~total_inout_flowrate total_inout_flowrate proc~diagnostic_volume_conservation->proc~total_inout_flowrate proc~inout_flowrate_from_bcdata inout_flowrate_from_bcdata proc~total_inout_flowrate->proc~inout_flowrate_from_bcdata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~diagnostic_volume_conservation~~CalledByGraph proc~diagnostic_volume_conservation diagnostic_volume_conservation proc~diagnostic_initialize diagnostic_initialize proc~diagnostic_initialize->proc~diagnostic_volume_conservation proc~time_marching time_marching proc~time_marching->proc~diagnostic_volume_conservation program~main main program~main->proc~diagnostic_initialize program~main->proc~time_marching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"diagnostic_volume_conservation – SWMMengine","tags":"","loc":"proc/diagnostic_volume_conservation.html"},{"text":"private subroutine diagnostic_froude_number_one(elemR, elemI, er_FroudeNumber, er_Velocity, er_HydDepth, ei_elem_type, thisType) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elemR (:,:) integer, intent(in) :: elemI (:,:) integer, intent(in) :: er_FroudeNumber integer, intent(in) :: er_Velocity integer, intent(in) :: er_HydDepth integer, intent(in) :: ei_elem_type integer, intent(in) :: thisType Called by proc~~diagnostic_froude_number_one~~CalledByGraph proc~diagnostic_froude_number_one diagnostic_froude_number_one proc~diagnostic_froude_number diagnostic_froude_number proc~diagnostic_froude_number->proc~diagnostic_froude_number_one proc~time_marching time_marching proc~time_marching->proc~diagnostic_froude_number program~main main program~main->proc~time_marching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"diagnostic_froude_number_one – SWMMengine","tags":"","loc":"proc/diagnostic_froude_number_one.html"},{"text":"private subroutine total_inout_flowrate(inflowRate, outflowRate, faceR, bcdataUp, bcdataDn) Arguments Type Intent Optional Attributes Name real, intent(out) :: inflowRate real, intent(out) :: outflowRate real, intent(in), target :: faceR (:,:) type(bcType), intent(in), target :: bcdataUp (:) type(bcType), intent(in), target :: bcdataDn (:) Calls proc~~total_inout_flowrate~~CallsGraph proc~total_inout_flowrate total_inout_flowrate proc~inout_flowrate_from_bcdata inout_flowrate_from_bcdata proc~total_inout_flowrate->proc~inout_flowrate_from_bcdata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~total_inout_flowrate~~CalledByGraph proc~total_inout_flowrate total_inout_flowrate proc~diagnostic_volume_conservation diagnostic_volume_conservation proc~diagnostic_volume_conservation->proc~total_inout_flowrate proc~diagnostic_initialize diagnostic_initialize proc~diagnostic_initialize->proc~diagnostic_volume_conservation proc~time_marching time_marching proc~time_marching->proc~diagnostic_volume_conservation program~main main program~main->proc~diagnostic_initialize program~main->proc~time_marching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"total_inout_flowrate – SWMMengine","tags":"","loc":"proc/total_inout_flowrate.html"},{"text":"private subroutine inout_flowrate_from_bcdata(inflowRate, outflowRate, faceR, bcdata) Arguments Type Intent Optional Attributes Name real, intent(inout) :: inflowRate real, intent(inout) :: outflowRate real, intent(in), target :: faceR (:,:) type(bcType), intent(in), target :: bcdata (:) Called by proc~~inout_flowrate_from_bcdata~~CalledByGraph proc~inout_flowrate_from_bcdata inout_flowrate_from_bcdata proc~total_inout_flowrate total_inout_flowrate proc~total_inout_flowrate->proc~inout_flowrate_from_bcdata proc~diagnostic_volume_conservation diagnostic_volume_conservation proc~diagnostic_volume_conservation->proc~total_inout_flowrate proc~diagnostic_initialize diagnostic_initialize proc~diagnostic_initialize->proc~diagnostic_volume_conservation proc~time_marching time_marching proc~time_marching->proc~diagnostic_volume_conservation program~main main program~main->proc~diagnostic_initialize program~main->proc~time_marching var panprocinout_flowrate_from_bcdataCalledByGraph = svgPanZoom('#procinout_flowrate_from_bcdataCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"inout_flowrate_from_bcdata – SWMMengine","tags":"","loc":"proc/inout_flowrate_from_bcdata.html"},{"text":"public subroutine friction_on_element(elemR, elemI, er_Friction, er_Velocity, er_Volume, er_Roughness, er_HydRadius, ei_elem_type, ei_roughness_type, ThisElemType) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) integer, intent(in) :: elemI (:,:) integer, intent(in) :: er_Friction integer, intent(in) :: er_Velocity integer, intent(in) :: er_Volume integer, intent(in) :: er_Roughness integer, intent(in) :: er_HydRadius integer, intent(in) :: ei_elem_type integer, intent(in) :: ei_roughness_type integer, intent(in) :: ThisElemType Contents None","title":"friction_on_element – SWMMengine","tags":"","loc":"proc/friction_on_element.html"},{"text":"private elemental function get_dt_from_CFL(CFL, velocity, depth, element_length) result(dt) Arguments Type Intent Optional Attributes Name real, intent(in) :: CFL real, intent(in) :: velocity real, intent(in) :: depth real, intent(in) :: element_length Return Value real Called by proc~~get_dt_from_cfl~~CalledByGraph proc~get_dt_from_cfl get_dt_from_CFL proc~this_setting_for_time_and_steps this_setting_for_time_and_steps proc~this_setting_for_time_and_steps->proc~get_dt_from_cfl proc~test_case_initiation test_case_initiation proc~test_case_initiation->proc~this_setting_for_time_and_steps program~main main program~main->proc~test_case_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"get_dt_from_CFL – SWMMengine","tags":"","loc":"proc/get_dt_from_cfl.html"},{"text":"public subroutine test_case_initiation(linkR, nodeR, linkI, nodeI, linkYN, nodeYN, linkName, nodeName, bcdataDn, bcdataUp) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:,:), allocatable :: linkR real, intent(out), dimension(:,:), allocatable :: nodeR integer, intent(out), dimension(:,:), allocatable :: linkI integer, intent(out), dimension(:,:), allocatable :: nodeI logical, intent(out), dimension(:,:), allocatable :: linkYN logical, intent(out), dimension(:,:), allocatable :: nodeYN type(string), intent(out), dimension(:), allocatable :: linkName type(string), intent(out), dimension(:), allocatable :: nodeName type(bcType), intent(out), dimension(:), allocatable :: bcdataDn type(bcType), intent(out), dimension(:), allocatable :: bcdataUp Calls proc~~test_case_initiation~~CallsGraph proc~test_case_initiation test_case_initiation proc~this_setting_for_time_and_steps this_setting_for_time_and_steps proc~test_case_initiation->proc~this_setting_for_time_and_steps proc~control_variable_allocation control_variable_allocation proc~test_case_initiation->proc~control_variable_allocation proc~case_y_channel_initialize case_y_channel_initialize proc~test_case_initiation->proc~case_y_channel_initialize proc~write_testcase_setup_file write_testcase_setup_file proc~test_case_initiation->proc~write_testcase_setup_file proc~utility_scale_of_number utility_scale_of_number proc~this_setting_for_time_and_steps->proc~utility_scale_of_number proc~utility_round_to_significant_digits utility_round_to_significant_digits proc~this_setting_for_time_and_steps->proc~utility_round_to_significant_digits proc~get_dt_from_cfl get_dt_from_CFL proc~this_setting_for_time_and_steps->proc~get_dt_from_cfl proc~case_y_channel_links_and_nodes case_y_channel_links_and_nodes proc~case_y_channel_initialize->proc~case_y_channel_links_and_nodes proc~bc_allocate bc_allocate proc~case_y_channel_initialize->proc~bc_allocate proc~utility_check_fileopen utility_check_fileopen proc~write_testcase_setup_file->proc~utility_check_fileopen proc~allocate_linknode_storage allocate_linknode_storage proc~case_y_channel_links_and_nodes->proc~allocate_linknode_storage proc~utility_round_to_significant_digits->proc~utility_scale_of_number proc~utility_check_allocation utility_check_allocation proc~bc_allocate->proc~utility_check_allocation proc~allocate_linknode_storage->proc~utility_check_allocation var panproctest_case_initiationCallsGraph = svgPanZoom('#proctest_case_initiationCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~test_case_initiation~~CalledByGraph proc~test_case_initiation test_case_initiation program~main main program~main->proc~test_case_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"test_case_initiation – SWMMengine","tags":"","loc":"proc/test_case_initiation.html"},{"text":"private subroutine control_variable_allocation(depth_dnstream, depth_upstream, lowerZ, upperZ, channel_length, channel_breadth, subdivide_length, flowrate, area, velocity, Froude, ManningsN, idepth_type) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:), allocatable :: depth_dnstream real, intent(out), dimension(:), allocatable :: depth_upstream real, intent(out), dimension(:), allocatable :: lowerZ real, intent(out), dimension(:), allocatable :: upperZ real, intent(out), dimension(:), allocatable :: channel_length real, intent(out), dimension(:), allocatable :: channel_breadth real, intent(out), dimension(:), allocatable :: subdivide_length real, intent(out), dimension(:), allocatable :: flowrate real, intent(out), dimension(:), allocatable :: area real, intent(out), dimension(:), allocatable :: velocity real, intent(out), dimension(:), allocatable :: Froude real, intent(out), dimension(:), allocatable :: ManningsN integer, intent(out), dimension(:), allocatable :: idepth_type Called by proc~~control_variable_allocation~~CalledByGraph proc~control_variable_allocation control_variable_allocation proc~test_case_initiation test_case_initiation proc~test_case_initiation->proc~control_variable_allocation program~main main program~main->proc~test_case_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"control_variable_allocation – SWMMengine","tags":"","loc":"proc/control_variable_allocation.html"},{"text":"private subroutine this_setting_for_time_and_steps(CFL, velocity, depth, subdivide_length, first_step, last_step, display_interval, dt_significant_digits) Arguments Type Intent Optional Attributes Name real, intent(in) :: CFL real, intent(in) :: velocity (:) real, intent(in) :: depth (:) real, intent(in) :: subdivide_length (:) integer, intent(in) :: first_step integer, intent(in) :: last_step integer, intent(in) :: display_interval integer, intent(in) :: dt_significant_digits Calls proc~~this_setting_for_time_and_steps~~CallsGraph proc~this_setting_for_time_and_steps this_setting_for_time_and_steps proc~utility_scale_of_number utility_scale_of_number proc~this_setting_for_time_and_steps->proc~utility_scale_of_number proc~utility_round_to_significant_digits utility_round_to_significant_digits proc~this_setting_for_time_and_steps->proc~utility_round_to_significant_digits proc~get_dt_from_cfl get_dt_from_CFL proc~this_setting_for_time_and_steps->proc~get_dt_from_cfl proc~utility_round_to_significant_digits->proc~utility_scale_of_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~this_setting_for_time_and_steps~~CalledByGraph proc~this_setting_for_time_and_steps this_setting_for_time_and_steps proc~test_case_initiation test_case_initiation proc~test_case_initiation->proc~this_setting_for_time_and_steps program~main main program~main->proc~test_case_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"this_setting_for_time_and_steps – SWMMengine","tags":"","loc":"proc/this_setting_for_time_and_steps.html"},{"text":"private subroutine froude_driven_setup(upperZ, area, flowrate, velocity, Froude, breadth, ManningsN, total_length, lowerZ, depth) Arguments Type Intent Optional Attributes Name real, intent(out) :: upperZ real, intent(out) :: area real, intent(out) :: flowrate real, intent(out) :: velocity real, intent(in) :: Froude real, intent(in) :: breadth real, intent(in) :: ManningsN real, intent(in) :: total_length real, intent(in) :: lowerZ real, intent(in) :: depth Contents None","title":"froude_driven_setup – SWMMengine","tags":"","loc":"proc/froude_driven_setup.html"},{"text":"private subroutine write_testcase_setup_file(Froude, CFL, flowrate, velocity, depth_upstream, depth_dnstream, breadth, area, total_length, subdivide_length, lowerZ, upperZ, ManningsN) Arguments Type Intent Optional Attributes Name real, intent(in) :: Froude (:) real, intent(in) :: CFL real, intent(in) :: flowrate (:) real, intent(in) :: velocity (:) real, intent(in) :: depth_upstream (:) real, intent(in) :: depth_dnstream (:) real, intent(in) :: breadth (:) real, intent(in) :: area (:) real, intent(in) :: total_length (:) real, intent(in) :: subdivide_length (:) real, intent(in) :: lowerZ (:) real, intent(in) :: upperZ (:) real, intent(in) :: ManningsN (:) Calls proc~~write_testcase_setup_file~~CallsGraph proc~write_testcase_setup_file write_testcase_setup_file proc~utility_check_fileopen utility_check_fileopen proc~write_testcase_setup_file->proc~utility_check_fileopen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_testcase_setup_file~~CalledByGraph proc~write_testcase_setup_file write_testcase_setup_file proc~test_case_initiation test_case_initiation proc~test_case_initiation->proc~write_testcase_setup_file program~main main program~main->proc~test_case_initiation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"write_testcase_setup_file – SWMMengine","tags":"","loc":"proc/write_testcase_setup_file.html"},{"text":"public subroutine element_geometry_update(elem2R, elem2I, elem2YN, e2r_VolumeColumn, elemMR, elemMI, elemMYN, eMr_VolumeColumn, faceR, faceI, bcdataDn, bcdataUp, thisTime, method_EtaM) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(inout), target :: elem2I (:,:) logical, intent(inout), target :: elem2YN (:,:) integer, intent(in) :: e2r_VolumeColumn real, intent(inout), target :: elemMR (:,:) integer, intent(inout), target :: elemMI (:,:) logical, intent(inout), target :: elemMYN (:,:) integer, intent(in) :: eMr_VolumeColumn real, intent(in) :: faceR (:,:) integer, intent(in) :: faceI (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) real, intent(in) :: thisTime integer, intent(in) :: method_EtaM Calls proc~~element_geometry_update~~CallsGraph proc~element_geometry_update element_geometry_update proc~bc_applied_onelement bc_applied_onelement proc~element_geometry_update->proc~bc_applied_onelement proc~adjust_for_zero_geometry adjust_for_zero_geometry proc~element_geometry_update->proc~adjust_for_zero_geometry proc~utility_advance_temp_array utility_advance_temp_array proc~element_geometry_update->proc~utility_advance_temp_array proc~rectangular_geometry_update rectangular_geometry_update proc~element_geometry_update->proc~rectangular_geometry_update proc~adjust_smallvolumes adjust_smallvolumes proc~element_geometry_update->proc~adjust_smallvolumes emr_temp emr_temp proc~element_geometry_update->emr_temp proc~bc_onelement bc_onelement proc~bc_applied_onelement->proc~bc_onelement proc~reset_juctionbranches_for_zero_values reset_juctionbranches_for_zero_values proc~adjust_for_zero_geometry->proc~reset_juctionbranches_for_zero_values proc~reset_element_for_zero_values reset_element_for_zero_values proc~adjust_for_zero_geometry->proc~reset_element_for_zero_values proc~rectangular_junction_leg rectangular_junction_leg proc~rectangular_geometry_update->proc~rectangular_junction_leg proc~rectangular_channel_or_junction rectangular_channel_or_junction proc~rectangular_geometry_update->proc~rectangular_channel_or_junction proc~smallvolume_geometry smallvolume_geometry proc~adjust_smallvolumes->proc~smallvolume_geometry proc~smallvolume_identification smallvolume_identification proc~adjust_smallvolumes->proc~smallvolume_identification proc~smallvolume_junctionbranch_reset smallvolume_junctionbranch_reset proc~smallvolume_geometry->proc~smallvolume_junctionbranch_reset proc~smallvolume_element_geometry_reset smallvolume_element_geometry_reset proc~smallvolume_geometry->proc~smallvolume_element_geometry_reset proc~smallvolume_identification_for_element smallvolume_identification_for_element proc~smallvolume_identification->proc~smallvolume_identification_for_element proc~bc_updatevalue bc_updatevalue proc~bc_onelement->proc~bc_updatevalue proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist var panprocelement_geometry_updateCallsGraph = svgPanZoom('#procelement_geometry_updateCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~element_geometry_update~~CalledByGraph proc~element_geometry_update element_geometry_update proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_geometry_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocelement_geometry_updateCalledByGraph = svgPanZoom('#procelement_geometry_updateCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"element_geometry_update – SWMMengine","tags":"","loc":"proc/element_geometry_update.html"},{"text":"public subroutine element_geometry_branch_fix(elemMR, elemMI, faceR, faceI) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) real, intent(in) :: faceR (:,:) integer, intent(in) :: faceI (:,:) Calls proc~~element_geometry_branch_fix~~CallsGraph proc~element_geometry_branch_fix element_geometry_branch_fix proc~rectangular_junction_leg rectangular_junction_leg proc~element_geometry_branch_fix->proc~rectangular_junction_leg proc~utility_advance_temp_array utility_advance_temp_array proc~element_geometry_branch_fix->proc~utility_advance_temp_array proc~junction_branch_velocity_and_flowrate_proportional_to_area junction_branch_velocity_and_flowrate_proportional_to_area proc~element_geometry_branch_fix->proc~junction_branch_velocity_and_flowrate_proportional_to_area proc~junction_branch_sum_areas_by_direction junction_branch_sum_areas_by_direction proc~element_geometry_branch_fix->proc~junction_branch_sum_areas_by_direction proc~adjust_junction_branch_velocity_limit adjust_junction_branch_velocity_limit proc~element_geometry_branch_fix->proc~adjust_junction_branch_velocity_limit emr_temp emr_temp proc~element_geometry_branch_fix->emr_temp emr_flowratedn emr_flowratedn proc~adjust_junction_branch_velocity_limit->emr_flowratedn emr_flowrateup emr_flowrateup proc~adjust_junction_branch_velocity_limit->emr_flowrateup emr_velocityup emr_velocityup proc~adjust_junction_branch_velocity_limit->emr_velocityup emr_velocitydn emr_velocitydn proc~adjust_junction_branch_velocity_limit->emr_velocitydn emr_areadn emr_areadn proc~adjust_junction_branch_velocity_limit->emr_areadn emr_areaup emr_areaup proc~adjust_junction_branch_velocity_limit->emr_areaup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~element_geometry_branch_fix~~CalledByGraph proc~element_geometry_branch_fix element_geometry_branch_fix proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_branch_fix proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching time_marching proc~time_marching->proc~rk2 program~main main program~main->proc~time_marching var panprocelement_geometry_branch_fixCalledByGraph = svgPanZoom('#procelement_geometry_branch_fixCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"element_geometry_branch_fix – SWMMengine","tags":"","loc":"proc/element_geometry_branch_fix.html"},{"text":"private subroutine rectangular_geometry_update(elem2R, elem2I, e2r_Volume_new, elemMR, elemMI, eMr_Volume_new, faceR, eMr_EtaOld, method_EtaM) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) integer, intent(in) :: e2r_Volume_new real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: eMr_Volume_new real, intent(in) :: faceR (:,:) integer, intent(in) :: eMr_EtaOld integer, intent(in) :: method_EtaM Calls proc~~rectangular_geometry_update~~CallsGraph proc~rectangular_geometry_update rectangular_geometry_update proc~rectangular_junction_leg rectangular_junction_leg proc~rectangular_geometry_update->proc~rectangular_junction_leg proc~rectangular_channel_or_junction rectangular_channel_or_junction proc~rectangular_geometry_update->proc~rectangular_channel_or_junction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rectangular_geometry_update~~CalledByGraph proc~rectangular_geometry_update rectangular_geometry_update proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~rectangular_geometry_update proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_geometry_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocrectangular_geometry_updateCalledByGraph = svgPanZoom('#procrectangular_geometry_updateCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"rectangular_geometry_update – SWMMengine","tags":"","loc":"proc/rectangular_geometry_update.html"},{"text":"private subroutine rectangular_channel_or_junction(elemR, elemI, ei_geometry, ei_elem_type, elem_typ_value, er_Length, er_Zbottom, er_BreadthScale, er_Topwidth, er_Area, er_Eta, er_Perimeter, er_HydDepth, er_HydRadius, er_Volume) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) integer, intent(in) :: elemI (:,:) integer, intent(in) :: ei_geometry integer, intent(in) :: ei_elem_type integer, intent(in) :: elem_typ_value integer, intent(in) :: er_Length integer, intent(in) :: er_Zbottom integer, intent(in) :: er_BreadthScale integer, intent(in) :: er_Topwidth integer, intent(in) :: er_Area integer, intent(in) :: er_Eta integer, intent(in) :: er_Perimeter integer, intent(in) :: er_HydDepth integer, intent(in) :: er_HydRadius integer, intent(in) :: er_Volume Called by proc~~rectangular_channel_or_junction~~CalledByGraph proc~rectangular_channel_or_junction rectangular_channel_or_junction proc~rectangular_geometry_update rectangular_geometry_update proc~rectangular_geometry_update->proc~rectangular_channel_or_junction proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~rectangular_geometry_update proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_geometry_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocrectangular_channel_or_junctionCalledByGraph = svgPanZoom('#procrectangular_channel_or_junctionCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"rectangular_channel_or_junction – SWMMengine","tags":"","loc":"proc/rectangular_channel_or_junction.html"},{"text":"private subroutine rectangular_junction_leg(elemMR, elemMI, faceR, face_per_elemM, eMi_nfacesDir, eMi_MfaceDir, eMr_AreaDir, eMr_ZbottomDir, eMr_BreadthScaleDir, eMr_TopwidthDir, eMr_EtaDir, eMr_HydDepthDir, eMr_EtaOld, fr_Eta_dir, method_EtaM) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in) :: face_per_elemM integer, intent(in) :: eMi_nfacesDir integer, intent(in) :: eMi_MfaceDir (:) integer, intent(in) :: eMr_AreaDir (:) integer, intent(in) :: eMr_ZbottomDir (:) integer, intent(in) :: eMr_BreadthScaleDir (:) integer, intent(in) :: eMr_TopwidthDir (:) integer, intent(in) :: eMr_EtaDir (:) integer, intent(in) :: eMr_HydDepthDir (:) integer, intent(in) :: eMr_EtaOld integer, intent(in) :: fr_Eta_dir integer, intent(in) :: method_EtaM Called by proc~~rectangular_junction_leg~~CalledByGraph proc~rectangular_junction_leg rectangular_junction_leg proc~rectangular_geometry_update rectangular_geometry_update proc~rectangular_geometry_update->proc~rectangular_junction_leg proc~element_geometry_branch_fix element_geometry_branch_fix proc~element_geometry_branch_fix->proc~rectangular_junction_leg proc~element_geometry_update element_geometry_update proc~element_geometry_update->proc~rectangular_geometry_update proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_geometry_branch_fix proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_geometry_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~time_marching->proc~rk2 var panprocrectangular_junction_legCalledByGraph = svgPanZoom('#procrectangular_junction_legCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"rectangular_junction_leg – SWMMengine","tags":"","loc":"proc/rectangular_junction_leg.html"},{"text":"public subroutine setting_default() Arguments None Called by proc~~setting_default~~CalledByGraph proc~setting_default setting_default program~main main program~main->proc~setting_default Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"setting_default – SWMMengine","tags":"","loc":"proc/setting_default.html"},{"text":"private pure elemental function small_chezy_velocity(ManningsN, HydRadius, Slope) Arguments Type Intent Optional Attributes Name real, intent(in) :: ManningsN real, intent(in) :: HydRadius real, intent(in) :: Slope Return Value real Called by proc~~small_chezy_velocity~~CalledByGraph proc~small_chezy_velocity small_chezy_velocity proc~velocity_blend_with_mask velocity_blend_with_mask proc~velocity_blend_with_mask->proc~small_chezy_velocity proc~blended_smallvolume_velocity blended_smallvolume_velocity proc~blended_smallvolume_velocity->proc~velocity_blend_with_mask proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~blended_smallvolume_velocity proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocsmall_chezy_velocityCalledByGraph = svgPanZoom('#procsmall_chezy_velocityCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"small_chezy_velocity – SWMMengine","tags":"","loc":"proc/small_chezy_velocity.html"},{"text":"private pure elemental function velocity_blend(SmallVolumeRatio, velocity, smallVelocity) Arguments Type Intent Optional Attributes Name real, intent(in) :: SmallVolumeRatio real, intent(in) :: velocity real, intent(in) :: smallVelocity Return Value real Called by proc~~velocity_blend~~CalledByGraph proc~velocity_blend velocity_blend proc~velocity_blend_with_mask velocity_blend_with_mask proc~velocity_blend_with_mask->proc~velocity_blend proc~blended_smallvolume_velocity blended_smallvolume_velocity proc~blended_smallvolume_velocity->proc~velocity_blend_with_mask proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~blended_smallvolume_velocity proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocvelocity_blendCalledByGraph = svgPanZoom('#procvelocity_blendCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"velocity_blend – SWMMengine","tags":"","loc":"proc/velocity_blend.html"},{"text":"public subroutine element_dynamics_update(elem2R, elemMR, faceR, elem2I, elemMI, elem2YN, elemMYN, bcdataDn, bcdataUp, e2r_Velocity_new, eMr_Velocity_new, e2r_Volume_new, eMr_Volume_new, thisTime) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) real, intent(inout), target :: elemMR (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in) :: elem2I (:,:) integer, intent(in) :: elemMI (:,:) logical, intent(inout), target :: elem2YN (:,:) logical, intent(inout), target :: elemMYN (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: eMr_Velocity_new integer, intent(in) :: e2r_Volume_new integer, intent(in) :: eMr_Volume_new real, intent(in) :: thisTime Calls proc~~element_dynamics_update~~CallsGraph proc~element_dynamics_update element_dynamics_update proc~bc_applied_onelement bc_applied_onelement proc~element_dynamics_update->proc~bc_applied_onelement proc~adjust_zero_velocity_at_zero_volume adjust_zero_velocity_at_zero_volume proc~element_dynamics_update->proc~adjust_zero_velocity_at_zero_volume proc~adjust_channel_velocity_limiter adjust_channel_velocity_limiter proc~element_dynamics_update->proc~adjust_channel_velocity_limiter proc~blended_smallvolume_velocity blended_smallvolume_velocity proc~element_dynamics_update->proc~blended_smallvolume_velocity proc~element_flowrate_update element_flowrate_update proc~element_dynamics_update->proc~element_flowrate_update proc~element_timescale element_timescale proc~element_dynamics_update->proc~element_timescale proc~bc_onelement bc_onelement proc~bc_applied_onelement->proc~bc_onelement proc~zero_velocity_at_zero_volume zero_velocity_at_zero_volume proc~adjust_zero_velocity_at_zero_volume->proc~zero_velocity_at_zero_volume emi_mfaceup emi_mfaceup proc~blended_smallvolume_velocity->emi_mfaceup emr_lengthdn emr_lengthdn proc~blended_smallvolume_velocity->emr_lengthdn emr_velocitydn emr_velocitydn proc~blended_smallvolume_velocity->emr_velocitydn emr_areadn emr_areadn proc~blended_smallvolume_velocity->emr_areadn proc~velocity_blend_with_mask velocity_blend_with_mask proc~blended_smallvolume_velocity->proc~velocity_blend_with_mask emr_lengthup emr_lengthup proc~blended_smallvolume_velocity->emr_lengthup emr_flowratedn emr_flowratedn proc~blended_smallvolume_velocity->emr_flowratedn emr_areaup emr_areaup proc~blended_smallvolume_velocity->emr_areaup emi_mfacedn emi_mfacedn proc~blended_smallvolume_velocity->emi_mfacedn emr_flowrateup emr_flowrateup proc~blended_smallvolume_velocity->emr_flowrateup emr_velocityup emr_velocityup proc~blended_smallvolume_velocity->emr_velocityup proc~junction_branch_sum_areas_by_direction junction_branch_sum_areas_by_direction proc~element_flowrate_update->proc~junction_branch_sum_areas_by_direction proc~adjust_junction_branch_velocity_limit adjust_junction_branch_velocity_limit proc~element_flowrate_update->proc~adjust_junction_branch_velocity_limit emr_temp emr_temp proc~element_flowrate_update->emr_temp proc~flowrate_from_velocity flowrate_from_velocity proc~element_flowrate_update->proc~flowrate_from_velocity proc~junction_branch_velocity_and_flowrate_proportional_to_area junction_branch_velocity_and_flowrate_proportional_to_area proc~element_flowrate_update->proc~junction_branch_velocity_and_flowrate_proportional_to_area proc~utility_advance_temp_array utility_advance_temp_array proc~element_flowrate_update->proc~utility_advance_temp_array proc~bc_timescale_value bc_timescale_value proc~element_timescale->proc~bc_timescale_value proc~timescale_value_junction timescale_value_junction proc~element_timescale->proc~timescale_value_junction proc~timescale_value_channel timescale_value_channel proc~element_timescale->proc~timescale_value_channel proc~timescale_value_junction->emr_temp proc~timescale_value_junction->proc~utility_advance_temp_array proc~timescale_limit_junction_one_direction timescale_limit_junction_one_direction proc~timescale_value_junction->proc~timescale_limit_junction_one_direction proc~timescale_junction_one_direction timescale_junction_one_direction proc~timescale_value_junction->proc~timescale_junction_one_direction proc~velocity_blend_with_mask->proc~utility_advance_temp_array proc~velocity_blend velocity_blend proc~velocity_blend_with_mask->proc~velocity_blend proc~smallvolume_manningsn smallvolume_ManningsN proc~velocity_blend_with_mask->proc~smallvolume_manningsn proc~small_chezy_velocity small_chezy_velocity proc~velocity_blend_with_mask->proc~small_chezy_velocity proc~adjust_junction_branch_velocity_limit->emr_velocitydn proc~adjust_junction_branch_velocity_limit->emr_areadn proc~adjust_junction_branch_velocity_limit->emr_flowratedn proc~adjust_junction_branch_velocity_limit->emr_areaup proc~adjust_junction_branch_velocity_limit->emr_flowrateup proc~adjust_junction_branch_velocity_limit->emr_velocityup proc~bc_updatevalue bc_updatevalue proc~bc_onelement->proc~bc_updatevalue proc~timescale_value_channel->proc~utility_advance_temp_array e2yn_temp e2yn_temp proc~timescale_value_channel->e2yn_temp e2r_temp e2r_temp proc~timescale_value_channel->e2r_temp proc~timescale_limiter timescale_limiter proc~timescale_value_channel->proc~timescale_limiter proc~timescale_limit_junction_one_direction->proc~utility_advance_temp_array proc~timescale_limit_junction_one_direction->proc~timescale_limiter emyn_temp emyn_temp proc~timescale_limit_junction_one_direction->emyn_temp proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist proc~apply_limiter_with_mask apply_limiter_with_mask proc~timescale_limiter->proc~apply_limiter_with_mask var panprocelement_dynamics_updateCallsGraph = svgPanZoom('#procelement_dynamics_updateCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~element_dynamics_update~~CalledByGraph proc~element_dynamics_update element_dynamics_update proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocelement_dynamics_updateCalledByGraph = svgPanZoom('#procelement_dynamics_updateCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"element_dynamics_update – SWMMengine","tags":"","loc":"proc/element_dynamics_update.html"},{"text":"private subroutine element_flowrate_update(elem2R, elemMR, faceR, elem2I, elemMI, e2r_Velocity_new, eMr_Velocity_new) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) real, intent(inout), target :: elemMR (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in), target :: elem2I (:,:) integer, intent(in), target :: elemMI (:,:) integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: eMr_Velocity_new Calls proc~~element_flowrate_update~~CallsGraph proc~element_flowrate_update element_flowrate_update proc~flowrate_from_velocity flowrate_from_velocity proc~element_flowrate_update->proc~flowrate_from_velocity proc~utility_advance_temp_array utility_advance_temp_array proc~element_flowrate_update->proc~utility_advance_temp_array proc~junction_branch_velocity_and_flowrate_proportional_to_area junction_branch_velocity_and_flowrate_proportional_to_area proc~element_flowrate_update->proc~junction_branch_velocity_and_flowrate_proportional_to_area proc~junction_branch_sum_areas_by_direction junction_branch_sum_areas_by_direction proc~element_flowrate_update->proc~junction_branch_sum_areas_by_direction proc~adjust_junction_branch_velocity_limit adjust_junction_branch_velocity_limit proc~element_flowrate_update->proc~adjust_junction_branch_velocity_limit emr_temp emr_temp proc~element_flowrate_update->emr_temp emr_flowratedn emr_flowratedn proc~adjust_junction_branch_velocity_limit->emr_flowratedn emr_flowrateup emr_flowrateup proc~adjust_junction_branch_velocity_limit->emr_flowrateup emr_velocityup emr_velocityup proc~adjust_junction_branch_velocity_limit->emr_velocityup emr_velocitydn emr_velocitydn proc~adjust_junction_branch_velocity_limit->emr_velocitydn emr_areadn emr_areadn proc~adjust_junction_branch_velocity_limit->emr_areadn emr_areaup emr_areaup proc~adjust_junction_branch_velocity_limit->emr_areaup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~element_flowrate_update~~CalledByGraph proc~element_flowrate_update element_flowrate_update proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~element_flowrate_update proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocelement_flowrate_updateCalledByGraph = svgPanZoom('#procelement_flowrate_updateCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"element_flowrate_update – SWMMengine","tags":"","loc":"proc/element_flowrate_update.html"},{"text":"private subroutine flowrate_from_velocity(elemR, elemI, er_Flowrate, er_Area, er_Velocity, ei_elem_type, eThisElemType) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) integer, intent(in) :: elemI (:,:) integer, intent(in) :: er_Flowrate integer, intent(in) :: er_Area integer, intent(in) :: er_Velocity integer, intent(in) :: ei_elem_type integer, intent(in) :: eThisElemType Called by proc~~flowrate_from_velocity~~CalledByGraph proc~flowrate_from_velocity flowrate_from_velocity proc~element_flowrate_update element_flowrate_update proc~element_flowrate_update->proc~flowrate_from_velocity proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~element_flowrate_update proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocflowrate_from_velocityCalledByGraph = svgPanZoom('#procflowrate_from_velocityCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"flowrate_from_velocity – SWMMengine","tags":"","loc":"proc/flowrate_from_velocity.html"},{"text":"private subroutine blended_smallvolume_velocity(elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, e2r_Velocity_new, eMr_Velocity_new) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) logical, intent(in) :: elem2YN (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) logical, intent(in) :: elemMYN (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: eMr_Velocity_new Calls proc~~blended_smallvolume_velocity~~CallsGraph proc~blended_smallvolume_velocity blended_smallvolume_velocity emi_mfacedn emi_mfacedn proc~blended_smallvolume_velocity->emi_mfacedn emr_flowratedn emr_flowratedn proc~blended_smallvolume_velocity->emr_flowratedn emi_mfaceup emi_mfaceup proc~blended_smallvolume_velocity->emi_mfaceup emr_flowrateup emr_flowrateup proc~blended_smallvolume_velocity->emr_flowrateup emr_velocityup emr_velocityup proc~blended_smallvolume_velocity->emr_velocityup emr_lengthdn emr_lengthdn proc~blended_smallvolume_velocity->emr_lengthdn proc~velocity_blend_with_mask velocity_blend_with_mask proc~blended_smallvolume_velocity->proc~velocity_blend_with_mask emr_velocitydn emr_velocitydn proc~blended_smallvolume_velocity->emr_velocitydn emr_areadn emr_areadn proc~blended_smallvolume_velocity->emr_areadn emr_areaup emr_areaup proc~blended_smallvolume_velocity->emr_areaup emr_lengthup emr_lengthup proc~blended_smallvolume_velocity->emr_lengthup proc~utility_advance_temp_array utility_advance_temp_array proc~velocity_blend_with_mask->proc~utility_advance_temp_array proc~smallvolume_manningsn smallvolume_ManningsN proc~velocity_blend_with_mask->proc~smallvolume_manningsn proc~small_chezy_velocity small_chezy_velocity proc~velocity_blend_with_mask->proc~small_chezy_velocity proc~velocity_blend velocity_blend proc~velocity_blend_with_mask->proc~velocity_blend Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~blended_smallvolume_velocity~~CalledByGraph proc~blended_smallvolume_velocity blended_smallvolume_velocity proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~blended_smallvolume_velocity proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocblended_smallvolume_velocityCalledByGraph = svgPanZoom('#procblended_smallvolume_velocityCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"blended_smallvolume_velocity – SWMMengine","tags":"","loc":"proc/blended_smallvolume_velocity.html"},{"text":"private subroutine velocity_blend_with_mask(elemR, elemI, elemYN, faceR, next_er_temparray, er_n_temp, er_Temp, er_Velocity_new, er_Flowrate, er_Length, er_Area, er_HydRadius, er_SmallVolumeRatio, eYN_IsSmallVolume, ei_roughness_type, er_Roughness, ei_elem_type, elemType, ei_Mface_u, ei_Mface_d) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) integer, intent(in), target :: elemI (:,:) logical, intent(in) :: elemYN (:,:) real, intent(in) :: faceR (:,:) integer, intent(inout) :: next_er_temparray integer, intent(in) :: er_n_temp integer, intent(in) :: er_Temp (:) integer, intent(in) :: er_Velocity_new integer, intent(in) :: er_Flowrate integer, intent(in) :: er_Length integer, intent(in) :: er_Area integer, intent(in) :: er_HydRadius integer, intent(in) :: er_SmallVolumeRatio integer, intent(in) :: eYN_IsSmallVolume integer, intent(in) :: ei_roughness_type integer, intent(in) :: er_Roughness integer, intent(in) :: ei_elem_type integer, intent(in) :: elemType integer, intent(in) :: ei_Mface_u integer, intent(in) :: ei_Mface_d Calls proc~~velocity_blend_with_mask~~CallsGraph proc~velocity_blend_with_mask velocity_blend_with_mask proc~utility_advance_temp_array utility_advance_temp_array proc~velocity_blend_with_mask->proc~utility_advance_temp_array proc~smallvolume_manningsn smallvolume_ManningsN proc~velocity_blend_with_mask->proc~smallvolume_manningsn proc~small_chezy_velocity small_chezy_velocity proc~velocity_blend_with_mask->proc~small_chezy_velocity proc~velocity_blend velocity_blend proc~velocity_blend_with_mask->proc~velocity_blend Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~velocity_blend_with_mask~~CalledByGraph proc~velocity_blend_with_mask velocity_blend_with_mask proc~blended_smallvolume_velocity blended_smallvolume_velocity proc~blended_smallvolume_velocity->proc~velocity_blend_with_mask proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~blended_smallvolume_velocity proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocvelocity_blend_with_maskCalledByGraph = svgPanZoom('#procvelocity_blend_with_maskCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"velocity_blend_with_mask – SWMMengine","tags":"","loc":"proc/velocity_blend_with_mask.html"},{"text":"private subroutine smallvolume_ManningsN(elemR, elemI, elemYN, er_tManningsN, er_tSmallVelocity, eYN_IsSmallVolume, ei_roughness_type, er_Roughness) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) integer, intent(in) :: elemI (:,:) logical, intent(in) :: elemYN (:,:) integer, intent(in) :: er_tManningsN integer, intent(in) :: er_tSmallVelocity integer, intent(in) :: eYN_IsSmallVolume integer, intent(in) :: ei_roughness_type integer, intent(in) :: er_Roughness Called by proc~~smallvolume_manningsn~~CalledByGraph proc~smallvolume_manningsn smallvolume_ManningsN proc~velocity_blend_with_mask velocity_blend_with_mask proc~velocity_blend_with_mask->proc~smallvolume_manningsn proc~blended_smallvolume_velocity blended_smallvolume_velocity proc~blended_smallvolume_velocity->proc~velocity_blend_with_mask proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~blended_smallvolume_velocity proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocsmallvolume_manningsnCalledByGraph = svgPanZoom('#procsmallvolume_manningsnCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"smallvolume_ManningsN – SWMMengine","tags":"","loc":"proc/smallvolume_manningsn.html"},{"text":"private subroutine element_timescale(elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, bcdataDn, bcdataUp, e2r_Velocity_new) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) logical, intent(inout) :: elem2YN (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) logical, intent(inout) :: elemMYN (:,:) type(bcType), intent(in) :: bcdataDn (:) type(bcType), intent(in) :: bcdataUp (:) integer, intent(in) :: e2r_Velocity_new Calls proc~~element_timescale~~CallsGraph proc~element_timescale element_timescale proc~bc_timescale_value bc_timescale_value proc~element_timescale->proc~bc_timescale_value proc~timescale_value_channel timescale_value_channel proc~element_timescale->proc~timescale_value_channel proc~timescale_value_junction timescale_value_junction proc~element_timescale->proc~timescale_value_junction e2yn_temp e2yn_temp proc~timescale_value_channel->e2yn_temp e2r_temp e2r_temp proc~timescale_value_channel->e2r_temp proc~utility_advance_temp_array utility_advance_temp_array proc~timescale_value_channel->proc~utility_advance_temp_array proc~timescale_limiter timescale_limiter proc~timescale_value_channel->proc~timescale_limiter proc~timescale_limit_junction_one_direction timescale_limit_junction_one_direction proc~timescale_value_junction->proc~timescale_limit_junction_one_direction proc~timescale_value_junction->proc~utility_advance_temp_array proc~timescale_junction_one_direction timescale_junction_one_direction proc~timescale_value_junction->proc~timescale_junction_one_direction emr_temp emr_temp proc~timescale_value_junction->emr_temp proc~timescale_limit_junction_one_direction->proc~utility_advance_temp_array proc~timescale_limit_junction_one_direction->proc~timescale_limiter emyn_temp emyn_temp proc~timescale_limit_junction_one_direction->emyn_temp proc~apply_limiter_with_mask apply_limiter_with_mask proc~timescale_limiter->proc~apply_limiter_with_mask var panprocelement_timescaleCallsGraph = svgPanZoom('#procelement_timescaleCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~element_timescale~~CalledByGraph proc~element_timescale element_timescale proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~element_timescale proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocelement_timescaleCalledByGraph = svgPanZoom('#procelement_timescaleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"element_timescale – SWMMengine","tags":"","loc":"proc/element_timescale.html"},{"text":"private subroutine timescale_value_channel(elem2R, elem2I, elem2YN, e2r_Velocity_new) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) logical, intent(inout), target :: elem2YN (:,:) integer, intent(in) :: e2r_Velocity_new Calls proc~~timescale_value_channel~~CallsGraph proc~timescale_value_channel timescale_value_channel proc~timescale_limiter timescale_limiter proc~timescale_value_channel->proc~timescale_limiter proc~utility_advance_temp_array utility_advance_temp_array proc~timescale_value_channel->proc~utility_advance_temp_array e2yn_temp e2yn_temp proc~timescale_value_channel->e2yn_temp e2r_temp e2r_temp proc~timescale_value_channel->e2r_temp proc~apply_limiter_with_mask apply_limiter_with_mask proc~timescale_limiter->proc~apply_limiter_with_mask Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~timescale_value_channel~~CalledByGraph proc~timescale_value_channel timescale_value_channel proc~element_timescale element_timescale proc~element_timescale->proc~timescale_value_channel proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~element_timescale proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panproctimescale_value_channelCalledByGraph = svgPanZoom('#proctimescale_value_channelCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"timescale_value_channel – SWMMengine","tags":"","loc":"proc/timescale_value_channel.html"},{"text":"private subroutine timescale_value_junction(elemMR, elemMI, elemMYN) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) logical, intent(inout) :: elemMYN (:,:) Calls proc~~timescale_value_junction~~CallsGraph proc~timescale_value_junction timescale_value_junction proc~timescale_limit_junction_one_direction timescale_limit_junction_one_direction proc~timescale_value_junction->proc~timescale_limit_junction_one_direction proc~utility_advance_temp_array utility_advance_temp_array proc~timescale_value_junction->proc~utility_advance_temp_array proc~timescale_junction_one_direction timescale_junction_one_direction proc~timescale_value_junction->proc~timescale_junction_one_direction emr_temp emr_temp proc~timescale_value_junction->emr_temp proc~timescale_limit_junction_one_direction->proc~utility_advance_temp_array proc~timescale_limiter timescale_limiter proc~timescale_limit_junction_one_direction->proc~timescale_limiter emyn_temp emyn_temp proc~timescale_limit_junction_one_direction->emyn_temp proc~apply_limiter_with_mask apply_limiter_with_mask proc~timescale_limiter->proc~apply_limiter_with_mask var panproctimescale_value_junctionCallsGraph = svgPanZoom('#proctimescale_value_junctionCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~timescale_value_junction~~CalledByGraph proc~timescale_value_junction timescale_value_junction proc~element_timescale element_timescale proc~element_timescale->proc~timescale_value_junction proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~element_timescale proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panproctimescale_value_junctionCalledByGraph = svgPanZoom('#proctimescale_value_junctionCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"timescale_value_junction – SWMMengine","tags":"","loc":"proc/timescale_value_junction.html"},{"text":"private subroutine timescale_junction_one_direction(elemMR, elemMI, dir_face_per_elemM, eMi_nfaces_dir, eMr_LengthDir, eMr_VelocityDir, eMr_TimescaleDir, eMr_waveindx, isUp) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: dir_face_per_elemM integer, intent(in) :: eMi_nfaces_dir integer, intent(in) :: eMr_LengthDir (:) integer, intent(in) :: eMr_VelocityDir (:) integer, intent(in) :: eMr_TimescaleDir (:) integer, intent(in) :: eMr_waveindx logical, intent(in) :: isUp Called by proc~~timescale_junction_one_direction~~CalledByGraph proc~timescale_junction_one_direction timescale_junction_one_direction proc~timescale_value_junction timescale_value_junction proc~timescale_value_junction->proc~timescale_junction_one_direction proc~element_timescale element_timescale proc~element_timescale->proc~timescale_value_junction proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~element_timescale proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panproctimescale_junction_one_directionCalledByGraph = svgPanZoom('#proctimescale_junction_one_directionCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"timescale_junction_one_direction – SWMMengine","tags":"","loc":"proc/timescale_junction_one_direction.html"},{"text":"private subroutine timescale_limit_junction_one_direction(elemMR, elemMI, elemMYN, dir_face_per_elemM, eMi_nfaces_dir, eMr_TimescaleDir) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) logical, intent(inout), target :: elemMYN (:,:) integer, intent(in) :: dir_face_per_elemM integer, intent(in) :: eMi_nfaces_dir integer, intent(in) :: eMr_TimescaleDir (:) Calls proc~~timescale_limit_junction_one_direction~~CallsGraph proc~timescale_limit_junction_one_direction timescale_limit_junction_one_direction proc~timescale_limiter timescale_limiter proc~timescale_limit_junction_one_direction->proc~timescale_limiter proc~utility_advance_temp_array utility_advance_temp_array proc~timescale_limit_junction_one_direction->proc~utility_advance_temp_array emyn_temp emyn_temp proc~timescale_limit_junction_one_direction->emyn_temp proc~apply_limiter_with_mask apply_limiter_with_mask proc~timescale_limiter->proc~apply_limiter_with_mask Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~timescale_limit_junction_one_direction~~CalledByGraph proc~timescale_limit_junction_one_direction timescale_limit_junction_one_direction proc~timescale_value_junction timescale_value_junction proc~timescale_value_junction->proc~timescale_limit_junction_one_direction proc~element_timescale element_timescale proc~element_timescale->proc~timescale_value_junction proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~element_timescale proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panproctimescale_limit_junction_one_directionCalledByGraph = svgPanZoom('#proctimescale_limit_junction_one_directionCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"timescale_limit_junction_one_direction – SWMMengine","tags":"","loc":"proc/timescale_limit_junction_one_direction.html"},{"text":"private subroutine timescale_limiter(elemR, elemI, elemYN, indx, maskindx1, maskindx2) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) integer, intent(in) :: elemI (:,:) logical, intent(inout), target :: elemYN (:,:) integer, intent(in) :: indx (:) integer, intent(in) :: maskindx1 integer, intent(in) :: maskindx2 Calls proc~~timescale_limiter~~CallsGraph proc~timescale_limiter timescale_limiter proc~apply_limiter_with_mask apply_limiter_with_mask proc~timescale_limiter->proc~apply_limiter_with_mask Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~timescale_limiter~~CalledByGraph proc~timescale_limiter timescale_limiter proc~timescale_limit_junction_one_direction timescale_limit_junction_one_direction proc~timescale_limit_junction_one_direction->proc~timescale_limiter proc~timescale_value_channel timescale_value_channel proc~timescale_value_channel->proc~timescale_limiter proc~timescale_value_junction timescale_value_junction proc~timescale_value_junction->proc~timescale_limit_junction_one_direction proc~element_timescale element_timescale proc~element_timescale->proc~timescale_value_channel proc~element_timescale->proc~timescale_value_junction proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~element_timescale proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panproctimescale_limiterCalledByGraph = svgPanZoom('#proctimescale_limiterCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"timescale_limiter – SWMMengine","tags":"","loc":"proc/timescale_limiter.html"},{"text":"private pure subroutine apply_limiter_with_mask(inoutarray, maskarray, limitvalue) Arguments Type Intent Optional Attributes Name real, intent(inout) :: inoutarray (:) logical, intent(in) :: maskarray (:) real, intent(in) :: limitvalue Called by proc~~apply_limiter_with_mask~~CalledByGraph proc~apply_limiter_with_mask apply_limiter_with_mask proc~timescale_limiter timescale_limiter proc~timescale_limiter->proc~apply_limiter_with_mask proc~timescale_limit_junction_one_direction timescale_limit_junction_one_direction proc~timescale_limit_junction_one_direction->proc~timescale_limiter proc~timescale_value_channel timescale_value_channel proc~timescale_value_channel->proc~timescale_limiter proc~timescale_value_junction timescale_value_junction proc~timescale_value_junction->proc~timescale_limit_junction_one_direction proc~element_timescale element_timescale proc~element_timescale->proc~timescale_value_channel proc~element_timescale->proc~timescale_value_junction proc~element_dynamics_update element_dynamics_update proc~element_dynamics_update->proc~element_timescale proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~element_dynamics_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocapply_limiter_with_maskCalledByGraph = svgPanZoom('#procapply_limiter_with_maskCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"apply_limiter_with_mask – SWMMengine","tags":"","loc":"proc/apply_limiter_with_mask.html"},{"text":"public subroutine custom_1link_network(linkR, nodeR, linkI, nodeI, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(inout) :: linkR (:,:) real, intent(inout) :: nodeR (:,:) integer, intent(inout) :: linkI (:,:) integer, intent(inout) :: nodeI (:,:) type(string), intent(inout), dimension(:) :: linkName type(string), intent(inout), dimension(:) :: nodeName Contents None","title":"custom_1link_network – SWMMengine","tags":"","loc":"proc/custom_1link_network.html"},{"text":"public subroutine custom_6link_1_line_network(linkR, nodeR, linkI, nodeI, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(inout) :: linkR (:,:) real, intent(inout) :: nodeR (:,:) integer, intent(inout) :: linkI (:,:) integer, intent(inout) :: nodeI (:,:) type(string), intent(inout), dimension(:) :: linkName type(string), intent(inout), dimension(:) :: nodeName Contents None","title":"custom_6link_1_line_network – SWMMengine","tags":"","loc":"proc/custom_6link_1_line_network.html"},{"text":"public subroutine custom_3link_Y_network(linkR, nodeR, linkI, nodeI, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(inout) :: linkR (:,:) real, intent(inout) :: nodeR (:,:) integer, intent(inout) :: linkI (:,:) integer, intent(inout) :: nodeI (:,:) type(string), intent(inout), dimension(:) :: linkName type(string), intent(inout), dimension(:) :: nodeName Contents None","title":"custom_3link_Y_network – SWMMengine","tags":"","loc":"proc/custom_3link_y_network.html"},{"text":"public subroutine custom_6link_Y_network(linkR, nodeR, linkI, nodeI, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(inout) :: linkR (:,:) real, intent(inout) :: nodeR (:,:) integer, intent(inout) :: linkI (:,:) integer, intent(inout) :: nodeI (:,:) type(string), intent(inout), dimension(:) :: linkName type(string), intent(inout), dimension(:) :: nodeName Contents None","title":"custom_6link_Y_network – SWMMengine","tags":"","loc":"proc/custom_6link_y_network.html"},{"text":"public subroutine face_update(elem2R, elem2I, elemMR, faceR, faceI, faceYN, bcdataDn, bcdataUp, e2r_Velocity_new, eMr_Velocity_new, e2r_Volume_new, eMr_Volume_new, thisTime, thisIter) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) real, intent(in) :: elemMR (:,:) real, intent(inout) :: faceR (:,:) integer, intent(inout) :: faceI (:,:) logical, intent(inout) :: faceYN (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: eMr_Velocity_new integer, intent(in) :: e2r_Volume_new integer, intent(in) :: eMr_Volume_new real, intent(in) :: thisTime integer, intent(in) :: thisIter Calls proc~~face_update~~CallsGraph proc~face_update face_update proc~face_surface_elevation_interp face_surface_elevation_interp proc~face_update->proc~face_surface_elevation_interp proc~bc_applied_onface bc_applied_onface proc~face_update->proc~bc_applied_onface proc~face_hydraulic_jump face_hydraulic_jump proc~face_update->proc~face_hydraulic_jump proc~face_bc_flowrate_update face_bc_flowrate_update proc~face_update->proc~face_bc_flowrate_update proc~face_interp_for_elem2 face_interp_for_elem2 proc~face_update->proc~face_interp_for_elem2 proc~face_interp_for_upstreamchannel_to_downstreamjunction face_interp_for_upstreamchannel_to_downstreamjunction proc~face_update->proc~face_interp_for_upstreamchannel_to_downstreamjunction proc~face_interp_for_downstreamchannel_to_upstreamjunction face_interp_for_downstreamchannel_to_upstreamjunction proc~face_update->proc~face_interp_for_downstreamchannel_to_upstreamjunction proc~utility_advance_temp_array utility_advance_temp_array proc~face_surface_elevation_interp->proc~utility_advance_temp_array emr_lengthdn emr_lengthdn proc~face_surface_elevation_interp->emr_lengthdn emr_lengthup emr_lengthup proc~face_surface_elevation_interp->emr_lengthup fyn_temp fyn_temp proc~face_surface_elevation_interp->fyn_temp fr_temp fr_temp proc~face_surface_elevation_interp->fr_temp proc~bc_onface bc_onface proc~bc_applied_onface->proc~bc_onface proc~bc_face_othervalues bc_face_othervalues proc~bc_applied_onface->proc~bc_face_othervalues proc~bc_ghost_othervalues bc_ghost_othervalues proc~bc_applied_onface->proc~bc_ghost_othervalues proc~face_hydraulic_jump->proc~utility_advance_temp_array proc~face_hydraulic_jump->fr_temp proc~face_bc_flowrate_update_onevalue face_bc_flowrate_update_onevalue proc~face_bc_flowrate_update->proc~face_bc_flowrate_update_onevalue proc~face_interp_for_elem2->proc~utility_advance_temp_array proc~face_interp_for_elem2->fyn_temp proc~face_interp_for_elem2->fr_temp proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~utility_advance_temp_array proc~interp_with_junction_downstream interp_with_junction_downstream proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~interp_with_junction_downstream proc~face_interp_for_upstreamchannel_to_downstreamjunction->fyn_temp emr_timescaleup emr_timescaleup proc~face_interp_for_upstreamchannel_to_downstreamjunction->emr_timescaleup proc~face_interp_for_upstreamchannel_to_downstreamjunction->fr_temp proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~utility_advance_temp_array proc~interp_with_junction_upstream interp_with_junction_upstream proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~interp_with_junction_upstream emr_timescaledn emr_timescaledn proc~face_interp_for_downstreamchannel_to_upstreamjunction->emr_timescaledn proc~face_interp_for_downstreamchannel_to_upstreamjunction->fyn_temp proc~face_interp_for_downstreamchannel_to_upstreamjunction->fr_temp proc~linear_interpolation linear_interpolation proc~interp_with_junction_upstream->proc~linear_interpolation proc~interp_with_junction_downstream->proc~linear_interpolation proc~bc_updatevalue bc_updatevalue proc~bc_onface->proc~bc_updatevalue proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist var panprocface_updateCallsGraph = svgPanZoom('#procface_updateCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~face_update~~CalledByGraph proc~face_update face_update proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~face_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~face_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"face_update – SWMMengine","tags":"","loc":"proc/face_update.html"},{"text":"private subroutine face_bc_flowrate_update(bcdataDn, bcdataUp, faceR) Arguments Type Intent Optional Attributes Name type(bcType), intent(inout), target :: bcdataDn (:) type(bcType), intent(inout), target :: bcdataUp (:) real, intent(in) :: faceR (:,:) Calls proc~~face_bc_flowrate_update~~CallsGraph proc~face_bc_flowrate_update face_bc_flowrate_update proc~face_bc_flowrate_update_onevalue face_bc_flowrate_update_onevalue proc~face_bc_flowrate_update->proc~face_bc_flowrate_update_onevalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~face_bc_flowrate_update~~CalledByGraph proc~face_bc_flowrate_update face_bc_flowrate_update proc~face_update face_update proc~face_update->proc~face_bc_flowrate_update proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~face_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~face_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocface_bc_flowrate_updateCalledByGraph = svgPanZoom('#procface_bc_flowrate_updateCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"face_bc_flowrate_update – SWMMengine","tags":"","loc":"proc/face_bc_flowrate_update.html"},{"text":"private subroutine face_bc_flowrate_update_onevalue(bcdata, faceR) Arguments Type Intent Optional Attributes Name type(bcType), intent(inout), target :: bcdata (:) real, intent(in) :: faceR (:,:) Called by proc~~face_bc_flowrate_update_onevalue~~CalledByGraph proc~face_bc_flowrate_update_onevalue face_bc_flowrate_update_onevalue proc~face_bc_flowrate_update face_bc_flowrate_update proc~face_bc_flowrate_update->proc~face_bc_flowrate_update_onevalue proc~face_update face_update proc~face_update->proc~face_bc_flowrate_update proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~face_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~face_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocface_bc_flowrate_update_onevalueCalledByGraph = svgPanZoom('#procface_bc_flowrate_update_onevalueCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"face_bc_flowrate_update_onevalue – SWMMengine","tags":"","loc":"proc/face_bc_flowrate_update_onevalue.html"},{"text":"private subroutine face_interp_for_elem2(elem2R, faceR, faceI, faceYN, bcdataDn, bcdataUp, e2r_Volume_new) Arguments Type Intent Optional Attributes Name real, intent(in), target :: elem2R (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(in) :: faceI (:,:) logical, intent(inout), target :: faceYN (:,:) type(bcType), intent(in) :: bcdataDn (:) type(bcType), intent(in) :: bcdataUp (:) integer, intent(in) :: e2r_Volume_new Calls proc~~face_interp_for_elem2~~CallsGraph proc~face_interp_for_elem2 face_interp_for_elem2 proc~utility_advance_temp_array utility_advance_temp_array proc~face_interp_for_elem2->proc~utility_advance_temp_array fyn_temp fyn_temp proc~face_interp_for_elem2->fyn_temp fr_temp fr_temp proc~face_interp_for_elem2->fr_temp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~face_interp_for_elem2~~CalledByGraph proc~face_interp_for_elem2 face_interp_for_elem2 proc~face_update face_update proc~face_update->proc~face_interp_for_elem2 proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~face_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~face_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocface_interp_for_elem2CalledByGraph = svgPanZoom('#procface_interp_for_elem2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"face_interp_for_elem2 – SWMMengine","tags":"","loc":"proc/face_interp_for_elem2.html"},{"text":"private subroutine face_interp_for_upstreamchannel_to_downstreamjunction(elem2R, elemMR, faceR, faceI, faceYN, e2r_Volume_new, eMr_Volume_new) Arguments Type Intent Optional Attributes Name real, intent(in), target :: elem2R (:,:) real, intent(in), target :: elemMR (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(in) :: faceI (:,:) logical, intent(inout), target :: faceYN (:,:) integer, intent(in) :: e2r_Volume_new integer, intent(in) :: eMr_Volume_new Calls proc~~face_interp_for_upstreamchannel_to_downstreamjunction~~CallsGraph proc~face_interp_for_upstreamchannel_to_downstreamjunction face_interp_for_upstreamchannel_to_downstreamjunction proc~utility_advance_temp_array utility_advance_temp_array proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~utility_advance_temp_array fyn_temp fyn_temp proc~face_interp_for_upstreamchannel_to_downstreamjunction->fyn_temp emr_timescaleup emr_timescaleup proc~face_interp_for_upstreamchannel_to_downstreamjunction->emr_timescaleup proc~interp_with_junction_downstream interp_with_junction_downstream proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~interp_with_junction_downstream fr_temp fr_temp proc~face_interp_for_upstreamchannel_to_downstreamjunction->fr_temp proc~linear_interpolation linear_interpolation proc~interp_with_junction_downstream->proc~linear_interpolation var panprocface_interp_for_upstreamchannel_to_downstreamjunctionCallsGraph = svgPanZoom('#procface_interp_for_upstreamchannel_to_downstreamjunctionCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~face_interp_for_upstreamchannel_to_downstreamjunction~~CalledByGraph proc~face_interp_for_upstreamchannel_to_downstreamjunction face_interp_for_upstreamchannel_to_downstreamjunction proc~face_update face_update proc~face_update->proc~face_interp_for_upstreamchannel_to_downstreamjunction proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~face_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~face_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocface_interp_for_upstreamchannel_to_downstreamjunctionCalledByGraph = svgPanZoom('#procface_interp_for_upstreamchannel_to_downstreamjunctionCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"face_interp_for_upstreamchannel_to_downstreamjunction – SWMMengine","tags":"","loc":"proc/face_interp_for_upstreamchannel_to_downstreamjunction.html"},{"text":"private subroutine face_interp_for_downstreamchannel_to_upstreamjunction(elem2R, elemMR, faceR, faceI, faceYN, e2r_Volume_new, eMr_Volume_new) Arguments Type Intent Optional Attributes Name real, intent(in), target :: elem2R (:,:) real, intent(in), target :: elemMR (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(in) :: faceI (:,:) logical, intent(inout), target :: faceYN (:,:) integer, intent(in) :: e2r_Volume_new integer, intent(in) :: eMr_Volume_new Calls proc~~face_interp_for_downstreamchannel_to_upstreamjunction~~CallsGraph proc~face_interp_for_downstreamchannel_to_upstreamjunction face_interp_for_downstreamchannel_to_upstreamjunction proc~utility_advance_temp_array utility_advance_temp_array proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~utility_advance_temp_array fyn_temp fyn_temp proc~face_interp_for_downstreamchannel_to_upstreamjunction->fyn_temp emr_timescaledn emr_timescaledn proc~face_interp_for_downstreamchannel_to_upstreamjunction->emr_timescaledn proc~interp_with_junction_upstream interp_with_junction_upstream proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~interp_with_junction_upstream fr_temp fr_temp proc~face_interp_for_downstreamchannel_to_upstreamjunction->fr_temp proc~linear_interpolation linear_interpolation proc~interp_with_junction_upstream->proc~linear_interpolation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~face_interp_for_downstreamchannel_to_upstreamjunction~~CalledByGraph proc~face_interp_for_downstreamchannel_to_upstreamjunction face_interp_for_downstreamchannel_to_upstreamjunction proc~face_update face_update proc~face_update->proc~face_interp_for_downstreamchannel_to_upstreamjunction proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~face_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~face_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocface_interp_for_downstreamchannel_to_upstreamjunctionCalledByGraph = svgPanZoom('#procface_interp_for_downstreamchannel_to_upstreamjunctionCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"face_interp_for_downstreamchannel_to_upstreamjunction – SWMMengine","tags":"","loc":"proc/face_interp_for_downstreamchannel_to_upstreamjunction.html"},{"text":"private subroutine face_hydraulic_jump(elem2R, elemMR, faceR, faceI, e2r_Velocity_new, eMr_Velocity_new) Arguments Type Intent Optional Attributes Name real, intent(in) :: elem2R (:,:) real, intent(in) :: elemMR (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(inout), target :: faceI (:,:) integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: eMr_Velocity_new Calls proc~~face_hydraulic_jump~~CallsGraph proc~face_hydraulic_jump face_hydraulic_jump proc~utility_advance_temp_array utility_advance_temp_array proc~face_hydraulic_jump->proc~utility_advance_temp_array fr_temp fr_temp proc~face_hydraulic_jump->fr_temp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~face_hydraulic_jump~~CalledByGraph proc~face_hydraulic_jump face_hydraulic_jump proc~face_update face_update proc~face_update->proc~face_hydraulic_jump proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~face_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~face_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocface_hydraulic_jumpCalledByGraph = svgPanZoom('#procface_hydraulic_jumpCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"face_hydraulic_jump – SWMMengine","tags":"","loc":"proc/face_hydraulic_jump.html"},{"text":"private subroutine face_surface_elevation_interp(elem2R, elemMR, faceR, faceI, faceYN) Arguments Type Intent Optional Attributes Name real, intent(in) :: elem2R (:,:) real, intent(in) :: elemMR (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(in) :: faceI (:,:) logical, intent(inout), target :: faceYN (:,:) Calls proc~~face_surface_elevation_interp~~CallsGraph proc~face_surface_elevation_interp face_surface_elevation_interp emr_lengthdn emr_lengthdn proc~face_surface_elevation_interp->emr_lengthdn proc~utility_advance_temp_array utility_advance_temp_array proc~face_surface_elevation_interp->proc~utility_advance_temp_array fyn_temp fyn_temp proc~face_surface_elevation_interp->fyn_temp fr_temp fr_temp proc~face_surface_elevation_interp->fr_temp emr_lengthup emr_lengthup proc~face_surface_elevation_interp->emr_lengthup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~face_surface_elevation_interp~~CalledByGraph proc~face_surface_elevation_interp face_surface_elevation_interp proc~face_update face_update proc~face_update->proc~face_surface_elevation_interp proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~face_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~face_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocface_surface_elevation_interpCalledByGraph = svgPanZoom('#procface_surface_elevation_interpCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"face_surface_elevation_interp – SWMMengine","tags":"","loc":"proc/face_surface_elevation_interp.html"},{"text":"private subroutine interp_channel_onetype(faceR, facemask, faceI, elem2R, weightUp, weightDn, valueUp, valueDn, e2r_ThisType, fr_ThisType) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: faceR (:,:) logical, intent(in) :: facemask (:) integer, intent(in) :: faceI (:,:) real, intent(in) :: elem2R (:,:) real, intent(in) :: weightUp (:) real, intent(in) :: weightDn (:) real, intent(inout) :: valueUp (:) real, intent(inout) :: valueDn (:) integer, intent(in) :: e2r_ThisType integer, intent(in) :: fr_ThisType Calls proc~~interp_channel_onetype~~CallsGraph proc~interp_channel_onetype interp_channel_onetype proc~linear_interpolation linear_interpolation proc~interp_channel_onetype->proc~linear_interpolation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"interp_channel_onetype – SWMMengine","tags":"","loc":"proc/interp_channel_onetype.html"},{"text":"private subroutine interp_with_junction_downstream(faceR, facemask, faceI, elem2R, elemMR, weightUp, weightDn, valueUp, valueDn, e2r_ThisValue, eMr_ThisValueUp, fr_ThisValue) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: faceR (:,:) logical, intent(in) :: facemask (:) integer, intent(in) :: faceI (:,:) real, intent(in) :: elem2R (:,:) real, intent(in) :: elemMR (:,:) real, intent(in) :: weightUp (:) real, intent(in) :: weightDn (:) real, intent(inout) :: valueUp (:) real, intent(inout) :: valueDn (:) integer, intent(in) :: e2r_ThisValue integer, intent(in) :: eMr_ThisValueUp (:) integer, intent(in) :: fr_ThisValue Calls proc~~interp_with_junction_downstream~~CallsGraph proc~interp_with_junction_downstream interp_with_junction_downstream proc~linear_interpolation linear_interpolation proc~interp_with_junction_downstream->proc~linear_interpolation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~interp_with_junction_downstream~~CalledByGraph proc~interp_with_junction_downstream interp_with_junction_downstream proc~face_interp_for_upstreamchannel_to_downstreamjunction face_interp_for_upstreamchannel_to_downstreamjunction proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~interp_with_junction_downstream proc~face_update face_update proc~face_update->proc~face_interp_for_upstreamchannel_to_downstreamjunction proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~face_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~face_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocinterp_with_junction_downstreamCalledByGraph = svgPanZoom('#procinterp_with_junction_downstreamCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"interp_with_junction_downstream – SWMMengine","tags":"","loc":"proc/interp_with_junction_downstream.html"},{"text":"private subroutine interp_with_junction_upstream(faceR, facemask, faceI, elem2R, elemMR, weightUp, weightDn, valueUp, valueDn, e2r_ThisValue, eMr_ThisValueDn, fr_ThisValue) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: faceR (:,:) logical, intent(in) :: facemask (:) integer, intent(in) :: faceI (:,:) real, intent(in) :: elem2R (:,:) real, intent(in) :: elemMR (:,:) real, intent(in) :: weightUp (:) real, intent(in) :: weightDn (:) real, intent(inout) :: valueUp (:) real, intent(inout) :: valueDn (:) integer, intent(in) :: e2r_ThisValue integer, intent(in) :: eMr_ThisValueDn (:) integer, intent(in) :: fr_ThisValue Calls proc~~interp_with_junction_upstream~~CallsGraph proc~interp_with_junction_upstream interp_with_junction_upstream proc~linear_interpolation linear_interpolation proc~interp_with_junction_upstream->proc~linear_interpolation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~interp_with_junction_upstream~~CalledByGraph proc~interp_with_junction_upstream interp_with_junction_upstream proc~face_interp_for_downstreamchannel_to_upstreamjunction face_interp_for_downstreamchannel_to_upstreamjunction proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~interp_with_junction_upstream proc~face_update face_update proc~face_update->proc~face_interp_for_downstreamchannel_to_upstreamjunction proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~face_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~face_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panprocinterp_with_junction_upstreamCalledByGraph = svgPanZoom('#procinterp_with_junction_upstreamCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"interp_with_junction_upstream – SWMMengine","tags":"","loc":"proc/interp_with_junction_upstream.html"},{"text":"private pure subroutine linear_interpolation(inoutarray, facemask, upstreamWeight, downstreamWeight, upstreamValue, downstreamValue) Arguments Type Intent Optional Attributes Name real, intent(inout) :: inoutarray (:) logical, intent(in) :: facemask (:) real, intent(in) :: upstreamWeight (:) real, intent(in) :: downstreamWeight (:) real, intent(in) :: upstreamValue (:) real, intent(in) :: downstreamValue (:) Called by proc~~linear_interpolation~~CalledByGraph proc~linear_interpolation linear_interpolation proc~interp_with_junction_upstream interp_with_junction_upstream proc~interp_with_junction_upstream->proc~linear_interpolation proc~interp_with_junction_downstream interp_with_junction_downstream proc~interp_with_junction_downstream->proc~linear_interpolation proc~interp_channel_onetype interp_channel_onetype proc~interp_channel_onetype->proc~linear_interpolation proc~face_interp_for_downstreamchannel_to_upstreamjunction face_interp_for_downstreamchannel_to_upstreamjunction proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~interp_with_junction_upstream proc~face_interp_for_upstreamchannel_to_downstreamjunction face_interp_for_upstreamchannel_to_downstreamjunction proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~interp_with_junction_downstream proc~face_update face_update proc~face_update->proc~face_interp_for_downstreamchannel_to_upstreamjunction proc~face_update->proc~face_interp_for_upstreamchannel_to_downstreamjunction proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2_update_auxiliary_variables->proc~face_update proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~face_update program~main main program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~rk2 rk2 proc~rk2->proc~rk2_update_auxiliary_variables proc~time_marching->proc~rk2 var panproclinear_interpolationCalledByGraph = svgPanZoom('#proclinear_interpolationCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"linear_interpolation – SWMMengine","tags":"","loc":"proc/linear_interpolation.html"},{"text":"public subroutine initial_condition_setup(elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, faceI, faceYN, linkR, linkI, nodeR, nodeI, bcdataDn, bcdataUp, thisTime) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(inout) :: elem2I (:,:) logical, intent(inout) :: elem2YN (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(inout) :: elemMI (:,:) logical, intent(inout) :: elemMYN (:,:) real, intent(inout) :: faceR (:,:) integer, intent(inout) :: faceI (:,:) logical, intent(inout) :: faceYN (:,:) real, intent(in) :: linkR (:,:) integer, intent(in), target :: linkI (:,:) real, intent(in) :: nodeR (:,:) integer, intent(in), target :: nodeI (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) real, intent(in) :: thisTime Calls proc~~initial_condition_setup~~CallsGraph proc~initial_condition_setup initial_condition_setup proc~element_dynamics_update element_dynamics_update proc~initial_condition_setup->proc~element_dynamics_update proc~bc_nullify_ghost_elem bc_nullify_ghost_elem proc~initial_condition_setup->proc~bc_nullify_ghost_elem proc~face_update face_update proc~initial_condition_setup->proc~face_update proc~element_geometry_update element_geometry_update proc~initial_condition_setup->proc~element_geometry_update proc~initial_conditions_from_linkdata initial_conditions_from_linkdata proc~initial_condition_setup->proc~initial_conditions_from_linkdata proc~initial_junction_conditions initial_junction_conditions proc~initial_condition_setup->proc~initial_junction_conditions proc~bc_applied_onelement bc_applied_onelement proc~element_dynamics_update->proc~bc_applied_onelement proc~adjust_zero_velocity_at_zero_volume adjust_zero_velocity_at_zero_volume proc~element_dynamics_update->proc~adjust_zero_velocity_at_zero_volume proc~adjust_channel_velocity_limiter adjust_channel_velocity_limiter proc~element_dynamics_update->proc~adjust_channel_velocity_limiter proc~element_flowrate_update element_flowrate_update proc~element_dynamics_update->proc~element_flowrate_update proc~blended_smallvolume_velocity blended_smallvolume_velocity proc~element_dynamics_update->proc~blended_smallvolume_velocity proc~element_timescale element_timescale proc~element_dynamics_update->proc~element_timescale proc~face_hydraulic_jump face_hydraulic_jump proc~face_update->proc~face_hydraulic_jump proc~face_interp_for_upstreamchannel_to_downstreamjunction face_interp_for_upstreamchannel_to_downstreamjunction proc~face_update->proc~face_interp_for_upstreamchannel_to_downstreamjunction proc~face_interp_for_downstreamchannel_to_upstreamjunction face_interp_for_downstreamchannel_to_upstreamjunction proc~face_update->proc~face_interp_for_downstreamchannel_to_upstreamjunction proc~face_surface_elevation_interp face_surface_elevation_interp proc~face_update->proc~face_surface_elevation_interp proc~bc_applied_onface bc_applied_onface proc~face_update->proc~bc_applied_onface proc~face_bc_flowrate_update face_bc_flowrate_update proc~face_update->proc~face_bc_flowrate_update proc~face_interp_for_elem2 face_interp_for_elem2 proc~face_update->proc~face_interp_for_elem2 proc~element_geometry_update->proc~bc_applied_onelement proc~adjust_for_zero_geometry adjust_for_zero_geometry proc~element_geometry_update->proc~adjust_for_zero_geometry proc~rectangular_geometry_update rectangular_geometry_update proc~element_geometry_update->proc~rectangular_geometry_update emr_temp emr_temp proc~element_geometry_update->emr_temp proc~utility_advance_temp_array utility_advance_temp_array proc~element_geometry_update->proc~utility_advance_temp_array proc~adjust_smallvolumes adjust_smallvolumes proc~element_geometry_update->proc~adjust_smallvolumes proc~junction_branch_velocities junction_branch_velocities proc~initial_junction_conditions->proc~junction_branch_velocities proc~junction_adjacent_element_average junction_adjacent_element_average proc~initial_junction_conditions->proc~junction_adjacent_element_average proc~junction_adjacent_element_values_to_branches junction_adjacent_element_values_to_branches proc~initial_junction_conditions->proc~junction_adjacent_element_values_to_branches proc~junction_branch_average_of_inflows_and_outflows junction_branch_average_of_inflows_and_outflows proc~initial_junction_conditions->proc~junction_branch_average_of_inflows_and_outflows proc~bc_onelement bc_onelement proc~bc_applied_onelement->proc~bc_onelement proc~reset_juctionbranches_for_zero_values reset_juctionbranches_for_zero_values proc~adjust_for_zero_geometry->proc~reset_juctionbranches_for_zero_values proc~reset_element_for_zero_values reset_element_for_zero_values proc~adjust_for_zero_geometry->proc~reset_element_for_zero_values proc~face_hydraulic_jump->proc~utility_advance_temp_array fr_temp fr_temp proc~face_hydraulic_jump->fr_temp proc~junction_branch_velocities_one_direction junction_branch_velocities_one_direction proc~junction_branch_velocities->proc~junction_branch_velocities_one_direction proc~zero_velocity_at_zero_volume zero_velocity_at_zero_volume proc~adjust_zero_velocity_at_zero_volume->proc~zero_velocity_at_zero_volume proc~junction_adjacent_element_average->emr_temp proc~junction_adjacent_element_average->proc~utility_advance_temp_array proc~junction_summation_from_adjacent_elements_one_direction junction_summation_from_adjacent_elements_one_direction proc~junction_adjacent_element_average->proc~junction_summation_from_adjacent_elements_one_direction proc~rectangular_junction_leg rectangular_junction_leg proc~rectangular_geometry_update->proc~rectangular_junction_leg proc~rectangular_channel_or_junction rectangular_channel_or_junction proc~rectangular_geometry_update->proc~rectangular_channel_or_junction proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~utility_advance_temp_array proc~interp_with_junction_downstream interp_with_junction_downstream proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~interp_with_junction_downstream fyn_temp fyn_temp proc~face_interp_for_upstreamchannel_to_downstreamjunction->fyn_temp emr_timescaleup emr_timescaleup proc~face_interp_for_upstreamchannel_to_downstreamjunction->emr_timescaleup proc~face_interp_for_upstreamchannel_to_downstreamjunction->fr_temp proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~utility_advance_temp_array proc~face_interp_for_downstreamchannel_to_upstreamjunction->fyn_temp proc~face_interp_for_downstreamchannel_to_upstreamjunction->fr_temp emr_timescaledn emr_timescaledn proc~face_interp_for_downstreamchannel_to_upstreamjunction->emr_timescaledn proc~interp_with_junction_upstream interp_with_junction_upstream proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~interp_with_junction_upstream proc~junction_adjacent_element_values_one_direction junction_adjacent_element_values_one_direction proc~junction_adjacent_element_values_to_branches->proc~junction_adjacent_element_values_one_direction proc~element_flowrate_update->emr_temp proc~element_flowrate_update->proc~utility_advance_temp_array proc~junction_branch_sum_areas_by_direction junction_branch_sum_areas_by_direction proc~element_flowrate_update->proc~junction_branch_sum_areas_by_direction proc~adjust_junction_branch_velocity_limit adjust_junction_branch_velocity_limit proc~element_flowrate_update->proc~adjust_junction_branch_velocity_limit proc~flowrate_from_velocity flowrate_from_velocity proc~element_flowrate_update->proc~flowrate_from_velocity proc~junction_branch_velocity_and_flowrate_proportional_to_area junction_branch_velocity_and_flowrate_proportional_to_area proc~element_flowrate_update->proc~junction_branch_velocity_and_flowrate_proportional_to_area proc~face_surface_elevation_interp->proc~utility_advance_temp_array emr_lengthdn emr_lengthdn proc~face_surface_elevation_interp->emr_lengthdn emr_lengthup emr_lengthup proc~face_surface_elevation_interp->emr_lengthup proc~face_surface_elevation_interp->fyn_temp proc~face_surface_elevation_interp->fr_temp proc~junction_branch_average_of_inflows_and_outflows->emr_temp proc~junction_branch_average_of_inflows_and_outflows->proc~utility_advance_temp_array proc~junction_net_inflow_and_outflow junction_net_inflow_and_outflow proc~junction_branch_average_of_inflows_and_outflows->proc~junction_net_inflow_and_outflow proc~bc_onface bc_onface proc~bc_applied_onface->proc~bc_onface proc~bc_ghost_othervalues bc_ghost_othervalues proc~bc_applied_onface->proc~bc_ghost_othervalues proc~bc_face_othervalues bc_face_othervalues proc~bc_applied_onface->proc~bc_face_othervalues proc~face_bc_flowrate_update_onevalue face_bc_flowrate_update_onevalue proc~face_bc_flowrate_update->proc~face_bc_flowrate_update_onevalue proc~face_interp_for_elem2->proc~utility_advance_temp_array proc~face_interp_for_elem2->fyn_temp proc~face_interp_for_elem2->fr_temp emi_mfaceup emi_mfaceup proc~blended_smallvolume_velocity->emi_mfaceup proc~blended_smallvolume_velocity->emr_lengthdn emr_velocitydn emr_velocitydn proc~blended_smallvolume_velocity->emr_velocitydn emr_areadn emr_areadn proc~blended_smallvolume_velocity->emr_areadn proc~velocity_blend_with_mask velocity_blend_with_mask proc~blended_smallvolume_velocity->proc~velocity_blend_with_mask proc~blended_smallvolume_velocity->emr_lengthup emr_flowratedn emr_flowratedn proc~blended_smallvolume_velocity->emr_flowratedn emr_areaup emr_areaup proc~blended_smallvolume_velocity->emr_areaup emi_mfacedn emi_mfacedn proc~blended_smallvolume_velocity->emi_mfacedn emr_flowrateup emr_flowrateup proc~blended_smallvolume_velocity->emr_flowrateup emr_velocityup emr_velocityup proc~blended_smallvolume_velocity->emr_velocityup proc~smallvolume_identification smallvolume_identification proc~adjust_smallvolumes->proc~smallvolume_identification proc~smallvolume_geometry smallvolume_geometry proc~adjust_smallvolumes->proc~smallvolume_geometry proc~bc_timescale_value bc_timescale_value proc~element_timescale->proc~bc_timescale_value proc~timescale_value_junction timescale_value_junction proc~element_timescale->proc~timescale_value_junction proc~timescale_value_channel timescale_value_channel proc~element_timescale->proc~timescale_value_channel proc~bc_updatevalue bc_updatevalue proc~bc_onface->proc~bc_updatevalue proc~smallvolume_identification_for_element smallvolume_identification_for_element proc~smallvolume_identification->proc~smallvolume_identification_for_element proc~timescale_value_junction->emr_temp proc~timescale_value_junction->proc~utility_advance_temp_array proc~timescale_limit_junction_one_direction timescale_limit_junction_one_direction proc~timescale_value_junction->proc~timescale_limit_junction_one_direction proc~timescale_junction_one_direction timescale_junction_one_direction proc~timescale_value_junction->proc~timescale_junction_one_direction proc~linear_interpolation linear_interpolation proc~interp_with_junction_downstream->proc~linear_interpolation proc~velocity_blend_with_mask->proc~utility_advance_temp_array proc~velocity_blend velocity_blend proc~velocity_blend_with_mask->proc~velocity_blend proc~smallvolume_manningsn smallvolume_ManningsN proc~velocity_blend_with_mask->proc~smallvolume_manningsn proc~small_chezy_velocity small_chezy_velocity proc~velocity_blend_with_mask->proc~small_chezy_velocity proc~adjust_junction_branch_velocity_limit->emr_velocitydn proc~adjust_junction_branch_velocity_limit->emr_areadn proc~adjust_junction_branch_velocity_limit->emr_flowratedn proc~adjust_junction_branch_velocity_limit->emr_areaup proc~adjust_junction_branch_velocity_limit->emr_flowrateup proc~adjust_junction_branch_velocity_limit->emr_velocityup proc~junction_net_flow_in_or_out junction_net_flow_in_or_out proc~junction_net_inflow_and_outflow->proc~junction_net_flow_in_or_out proc~smallvolume_junctionbranch_reset smallvolume_junctionbranch_reset proc~smallvolume_geometry->proc~smallvolume_junctionbranch_reset proc~smallvolume_element_geometry_reset smallvolume_element_geometry_reset proc~smallvolume_geometry->proc~smallvolume_element_geometry_reset proc~bc_onelement->proc~bc_updatevalue proc~timescale_value_channel->proc~utility_advance_temp_array e2yn_temp e2yn_temp proc~timescale_value_channel->e2yn_temp e2r_temp e2r_temp proc~timescale_value_channel->e2r_temp proc~timescale_limiter timescale_limiter proc~timescale_value_channel->proc~timescale_limiter proc~interp_with_junction_upstream->proc~linear_interpolation proc~timescale_limit_junction_one_direction->proc~utility_advance_temp_array proc~timescale_limit_junction_one_direction->proc~timescale_limiter emyn_temp emyn_temp proc~timescale_limit_junction_one_direction->emyn_temp proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist proc~apply_limiter_with_mask apply_limiter_with_mask proc~timescale_limiter->proc~apply_limiter_with_mask var panprocinitial_condition_setupCallsGraph = svgPanZoom('#procinitial_condition_setupCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initial_condition_setup~~CalledByGraph proc~initial_condition_setup initial_condition_setup program~main main program~main->proc~initial_condition_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"initial_condition_setup – SWMMengine","tags":"","loc":"proc/initial_condition_setup.html"},{"text":"private subroutine initial_conditions_from_linkdata(elem2R, elem2I, elemMR, elemMI, linkR, linkI) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(inout) :: elem2I (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(inout) :: elemMI (:,:) real, intent(in), target :: linkR (:,:) integer, intent(in), target :: linkI (:,:) Called by proc~~initial_conditions_from_linkdata~~CalledByGraph proc~initial_conditions_from_linkdata initial_conditions_from_linkdata proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~initial_conditions_from_linkdata program~main main program~main->proc~initial_condition_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"initial_conditions_from_linkdata – SWMMengine","tags":"","loc":"proc/initial_conditions_from_linkdata.html"},{"text":"private subroutine initial_junction_conditions(faceR, faceI, elem2R, elem2I, elemMR, elemMI, nodeR, nodeI) Arguments Type Intent Optional Attributes Name real, intent(in), target :: faceR (:,:) integer, intent(in), target :: faceI (:,:) real, intent(in), target :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(in), target :: nodeR (:,:) integer, intent(in), target :: nodeI (:,:) Calls proc~~initial_junction_conditions~~CallsGraph proc~initial_junction_conditions initial_junction_conditions proc~junction_adjacent_element_values_to_branches junction_adjacent_element_values_to_branches proc~initial_junction_conditions->proc~junction_adjacent_element_values_to_branches proc~junction_branch_average_of_inflows_and_outflows junction_branch_average_of_inflows_and_outflows proc~initial_junction_conditions->proc~junction_branch_average_of_inflows_and_outflows proc~junction_adjacent_element_average junction_adjacent_element_average proc~initial_junction_conditions->proc~junction_adjacent_element_average proc~junction_branch_velocities junction_branch_velocities proc~initial_junction_conditions->proc~junction_branch_velocities proc~junction_adjacent_element_values_one_direction junction_adjacent_element_values_one_direction proc~junction_adjacent_element_values_to_branches->proc~junction_adjacent_element_values_one_direction proc~junction_net_inflow_and_outflow junction_net_inflow_and_outflow proc~junction_branch_average_of_inflows_and_outflows->proc~junction_net_inflow_and_outflow proc~utility_advance_temp_array utility_advance_temp_array proc~junction_branch_average_of_inflows_and_outflows->proc~utility_advance_temp_array emr_temp emr_temp proc~junction_branch_average_of_inflows_and_outflows->emr_temp proc~junction_adjacent_element_average->proc~utility_advance_temp_array proc~junction_adjacent_element_average->emr_temp proc~junction_summation_from_adjacent_elements_one_direction junction_summation_from_adjacent_elements_one_direction proc~junction_adjacent_element_average->proc~junction_summation_from_adjacent_elements_one_direction proc~junction_branch_velocities_one_direction junction_branch_velocities_one_direction proc~junction_branch_velocities->proc~junction_branch_velocities_one_direction proc~junction_net_flow_in_or_out junction_net_flow_in_or_out proc~junction_net_inflow_and_outflow->proc~junction_net_flow_in_or_out var panprocinitial_junction_conditionsCallsGraph = svgPanZoom('#procinitial_junction_conditionsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initial_junction_conditions~~CalledByGraph proc~initial_junction_conditions initial_junction_conditions proc~initial_condition_setup initial_condition_setup proc~initial_condition_setup->proc~initial_junction_conditions program~main main program~main->proc~initial_condition_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"initial_junction_conditions – SWMMengine","tags":"","loc":"proc/initial_junction_conditions.html"},{"text":"public subroutine case_simple_channel_initialize(channel_length, channel_breadth, subdivide_length, lowerZ, upperZ, initial_flowrate, depth_upstream, depth_dnstream, ManningsN, roughness_type, idepth_type, linkR, nodeR, linkI, nodeI, linkYN, nodeYN, linkName, nodeName, bcdataDn, bcdataUp) Arguments Type Intent Optional Attributes Name real, intent(in) :: channel_length real, intent(in) :: channel_breadth real, intent(in) :: subdivide_length real, intent(in) :: lowerZ real, intent(in) :: upperZ real, intent(in) :: initial_flowrate real, intent(in) :: depth_upstream real, intent(in) :: depth_dnstream real, intent(in) :: ManningsN integer, intent(in) :: roughness_type integer, intent(in) :: idepth_type real, intent(out), dimension(:,:), allocatable, target :: linkR real, intent(out), dimension(:,:), allocatable, target :: nodeR integer, intent(out), dimension(:,:), allocatable, target :: linkI integer, intent(out), dimension(:,:), allocatable, target :: nodeI logical, intent(out), dimension(:,:), allocatable, target :: linkYN logical, intent(out), dimension(:,:), allocatable, target :: nodeYN type(string), intent(out), dimension(:), allocatable, target :: linkName type(string), intent(out), dimension(:), allocatable, target :: nodeName type(bcType), intent(out), dimension(:), allocatable :: bcdataDn type(bcType), intent(out), dimension(:), allocatable :: bcdataUp Calls proc~~case_simple_channel_initialize~~CallsGraph proc~case_simple_channel_initialize case_simple_channel_initialize proc~bc_allocate bc_allocate proc~case_simple_channel_initialize->proc~bc_allocate proc~case_simple_channel_links_and_nodes case_simple_channel_links_and_nodes proc~case_simple_channel_initialize->proc~case_simple_channel_links_and_nodes proc~utility_check_allocation utility_check_allocation proc~bc_allocate->proc~utility_check_allocation proc~allocate_linknode_storage allocate_linknode_storage proc~case_simple_channel_links_and_nodes->proc~allocate_linknode_storage proc~allocate_linknode_storage->proc~utility_check_allocation var panproccase_simple_channel_initializeCallsGraph = svgPanZoom('#proccase_simple_channel_initializeCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"case_simple_channel_initialize – SWMMengine","tags":"","loc":"proc/case_simple_channel_initialize.html"},{"text":"private subroutine case_simple_channel_links_and_nodes(channel_length, channel_breadth, subdivide_length, lowerZ, upperZ, initial_flowrate, depth_upstream, depth_dnstream, ManningsN, roughness_type, idepth_type, linkR, nodeR, linkI, nodeI, linkYN, nodeYN, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(in) :: channel_length real, intent(in) :: channel_breadth real, intent(in) :: subdivide_length real, intent(in) :: lowerZ real, intent(in) :: upperZ real, intent(in) :: initial_flowrate real, intent(in) :: depth_upstream real, intent(in) :: depth_dnstream real, intent(in) :: ManningsN integer, intent(in) :: roughness_type integer, intent(in) :: idepth_type real, intent(out), dimension(:,:), allocatable, target :: linkR real, intent(out), dimension(:,:), allocatable, target :: nodeR integer, intent(out), dimension(:,:), allocatable, target :: linkI integer, intent(out), dimension(:,:), allocatable, target :: nodeI logical, intent(out), dimension(:,:), allocatable, target :: linkYN logical, intent(out), dimension(:,:), allocatable, target :: nodeYN type(string), intent(out), dimension(:), allocatable, target :: linkName type(string), intent(out), dimension(:), allocatable, target :: nodeName Calls proc~~case_simple_channel_links_and_nodes~~CallsGraph proc~case_simple_channel_links_and_nodes case_simple_channel_links_and_nodes proc~allocate_linknode_storage allocate_linknode_storage proc~case_simple_channel_links_and_nodes->proc~allocate_linknode_storage proc~utility_check_allocation utility_check_allocation proc~allocate_linknode_storage->proc~utility_check_allocation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~case_simple_channel_links_and_nodes~~CalledByGraph proc~case_simple_channel_links_and_nodes case_simple_channel_links_and_nodes proc~case_simple_channel_initialize case_simple_channel_initialize proc~case_simple_channel_initialize->proc~case_simple_channel_links_and_nodes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","title":"case_simple_channel_links_and_nodes – SWMMengine","tags":"","loc":"proc/case_simple_channel_links_and_nodes.html"},{"text":"Uses array_index data_keys globals module~~checking~~UsesGraph module~checking checking module~globals globals module~checking->module~globals module~data_keys data_keys module~checking->module~data_keys module~array_index array_index module~checking->module~array_index module~setting_definition setting_definition module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~data_keys->module~globals module~array_index->module~globals module~setting_definition->module~type_definitions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~checking~~UsedByGraph module~checking checking program~main main program~main->module~checking Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines checking_consistency checking_smallvolume_consistency Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Subroutines public subroutine checking_consistency () Arguments None public subroutine checking_smallvolume_consistency (elem2R, elemMR) Arguments Type Intent Optional Attributes Name real, intent(in) :: elem2R (:,:) real, intent(in) :: elemMR (:,:)","title":"checking – SWMMengine","tags":"","loc":"module/checking.html"},{"text":"Uses array_index data_keys globals setting_definition type_definitions utility module~~bc~~UsesGraph module~bc bc module~globals globals module~bc->module~globals module~utility utility module~bc->module~utility module~array_index array_index module~bc->module~array_index module~type_definitions type_definitions module~bc->module~type_definitions module~setting_definition setting_definition module~bc->module~setting_definition module~data_keys data_keys module~bc->module~data_keys module~globals->module~type_definitions module~globals->module~setting_definition module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~utility->module~data_keys module~array_index->module~globals module~setting_definition->module~type_definitions module~data_keys->module~globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~bc~~UsedByGraph module~bc bc module~output output module~output->module~bc module~runge_kutta runge_kutta module~runge_kutta->module~bc module~element_dynamics element_dynamics module~runge_kutta->module~element_dynamics module~diagnostic diagnostic module~runge_kutta->module~diagnostic module~element_geometry element_geometry module~runge_kutta->module~element_geometry module~face_values face_values module~runge_kutta->module~face_values module~element_dynamics->module~bc program~main main program~main->module~bc program~main->module~output program~main->module~diagnostic module~time_loop time_loop program~main->module~time_loop module~debug debug program~main->module~debug module~initial_condition initial_condition program~main->module~initial_condition module~test_cases test_cases program~main->module~test_cases module~diagnostic->module~bc module~element_geometry->module~bc module~explicit_euler explicit_euler module~explicit_euler->module~bc module~explicit_euler->module~element_dynamics module~explicit_euler->module~element_geometry module~explicit_euler->module~face_values module~case_simple_channel case_simple_channel module~case_simple_channel->module~bc module~face_values->module~bc module~time_loop->module~bc module~time_loop->module~output module~time_loop->module~runge_kutta module~time_loop->module~diagnostic module~time_loop->module~explicit_euler module~time_loop->module~face_values module~time_loop->module~debug module~debug->module~bc module~initial_condition->module~bc module~initial_condition->module~element_dynamics module~initial_condition->module~element_geometry module~initial_condition->module~face_values module~case_y_channel case_y_channel module~case_y_channel->module~bc module~test_cases->module~bc module~test_cases->module~case_simple_channel module~test_cases->module~case_y_channel Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines bc_allocate bc_applied_onface bc_applied_onelement bc_checks bc_timescale_value bc_nullify_ghost_elem bc_adequate_coverage bc_onface bc_face_othervalues bc_onelement bc_updatevalue bc_node_assignment_error_check bc_assign_faceID bc_adequate_coverage_onedir bc_ghost_othervalues Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Subroutines public subroutine bc_allocate (bcdataDn, bcdataUp, ndnstreamBC, nupstreamBC, ntimepoint) Arguments Type Intent Optional Attributes Name type(bcType), intent(out), dimension(:), allocatable :: bcdataDn type(bcType), intent(out), dimension(:), allocatable :: bcdataUp integer, intent(in) :: ndnstreamBC integer, intent(in) :: nupstreamBC integer, intent(in) :: ntimepoint public subroutine bc_applied_onface (faceR, faceI, elem2R, elem2I, bcdataDn, bcdataUp, e2r_Velocity_new, thisTime) Arguments Type Intent Optional Attributes Name real, intent(inout) :: faceR (:,:) integer, intent(inout) :: faceI (:,:) real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) integer, intent(in) :: e2r_Velocity_new real, intent(in) :: thisTime public subroutine bc_applied_onelement (elem2R, bcdataDn, bcdataUp, thisTime, thiscategory, e2r_VelocityColumn) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) real, intent(in) :: thisTime integer, intent(in) :: thiscategory integer, intent(in) :: e2r_VelocityColumn public subroutine bc_checks (bcdataUp, bcdataDn, elem2I, faceI, nodeI) Arguments Type Intent Optional Attributes Name type(bcType), intent(inout) :: bcdataUp (:) type(bcType), intent(inout) :: bcdataDn (:) integer, intent(in) :: elem2I (:,:) integer, intent(in) :: faceI (:,:) integer, intent(in), target :: nodeI (:,:) public subroutine bc_timescale_value (elem2R, bcdata) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) type(bcType), intent(in), target :: bcdata (:) public subroutine bc_nullify_ghost_elem (elem2R, bcdata) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) type(bcType), intent(in), target :: bcdata (:) private subroutine bc_adequate_coverage (bcdataUp, bcdataDn) Arguments Type Intent Optional Attributes Name type(bcType), intent(in) :: bcdataUp (:) type(bcType), intent(in) :: bcdataDn (:) private subroutine bc_onface (faceR, faceI, elem2R, bcdata, thisTime) Arguments Type Intent Optional Attributes Name real, intent(inout) :: faceR (:,:) integer, intent(inout) :: faceI (:,:) real, intent(in) :: elem2R (:,:) type(bcType), intent(inout), target :: bcdata (:) real, intent(in) :: thisTime private subroutine bc_face_othervalues (faceR, faceI, elem2R, bcdata) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: faceR (:,:) integer, intent(in), target :: faceI (:,:) real, intent(in), target :: elem2R (:,:) type(bcType), intent(in), target :: bcdata (:) private subroutine bc_onelement (elem2R, bcdata, thisTime, thiscategory, e2r_VelocityColumn) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) type(bcType), intent(inout), target :: bcdata (:) real, intent(in) :: thisTime integer, intent(in) :: thiscategory integer, intent(in) :: e2r_VelocityColumn private subroutine bc_updatevalue (bcdata, thisTime) Arguments Type Intent Optional Attributes Name type(bcType), intent(inout) :: bcdata (:) real, intent(in) :: thisTime private subroutine bc_node_assignment_error_check (nodeI, faceI, nBCdir) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: nodeI (:,:) integer, intent(in) :: faceI (:,:) integer, intent(in) :: nBCdir private subroutine bc_assign_faceID (bcdata, faceI) Arguments Type Intent Optional Attributes Name type(bcType), intent(inout), target :: bcdata (:) integer, intent(in) :: faceI (:,:) private subroutine bc_adequate_coverage_onedir (bcdata, nBCdir) Arguments Type Intent Optional Attributes Name type(bcType), intent(in) :: bcdata (:) integer, intent(in) :: nBCdir private subroutine bc_ghost_othervalues (elem2R, elem2I, faceR, faceI, bcdata, e2i_Mface_dir, e2r_Velocity_new, fr_Area_dir, fr_Velocity_dir, fr_HydDepth_dir, fr_Eta_dir) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) real, intent(in) :: faceR (:,:) integer, intent(in), target :: faceI (:,:) type(bcType), intent(in), target :: bcdata (:) integer, intent(in) :: e2i_Mface_dir integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: fr_Area_dir integer, intent(in) :: fr_Velocity_dir integer, intent(in) :: fr_HydDepth_dir integer, intent(in) :: fr_Eta_dir","title":"bc – SWMMengine","tags":"","loc":"module/bc.html"},{"text":"Contents Variables today Derived Types date Variables Type Visibility Attributes Name Initial type( date ), public :: today Derived Types type, public :: date Components Type Visibility Attributes Name Initial integer, public :: day integer, public :: month integer, public :: year","title":"link_node – SWMMengine","tags":"","loc":"module/link_node.html"},{"text":"Uses adjustments array_index bc data_keys diagnostic element_geometry element_dynamics face_values globals setting_definition utility module~~runge_kutta~~UsesGraph module~runge_kutta runge_kutta module~globals globals module~runge_kutta->module~globals module~utility utility module~runge_kutta->module~utility module~array_index array_index module~runge_kutta->module~array_index module~element_dynamics element_dynamics module~runge_kutta->module~element_dynamics module~diagnostic diagnostic module~runge_kutta->module~diagnostic module~element_geometry element_geometry module~runge_kutta->module~element_geometry module~adjustments adjustments module~runge_kutta->module~adjustments module~face_values face_values module~runge_kutta->module~face_values module~setting_definition setting_definition module~runge_kutta->module~setting_definition module~bc bc module~runge_kutta->module~bc module~data_keys data_keys module~runge_kutta->module~data_keys module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~utility->module~data_keys module~array_index->module~globals module~element_dynamics->module~globals module~element_dynamics->module~utility module~element_dynamics->module~array_index module~element_dynamics->module~adjustments module~element_dynamics->module~setting_definition module~element_dynamics->module~bc module~element_dynamics->module~data_keys module~junction junction module~element_dynamics->module~junction module~diagnostic->module~globals module~diagnostic->module~utility module~diagnostic->module~array_index module~diagnostic->module~setting_definition module~diagnostic->module~bc module~diagnostic->module~data_keys module~diagnostic->module~type_definitions module~element_geometry->module~globals module~element_geometry->module~utility module~element_geometry->module~array_index module~element_geometry->module~adjustments module~element_geometry->module~setting_definition module~element_geometry->module~bc module~element_geometry->module~data_keys module~element_geometry->module~junction module~adjustments->module~globals module~adjustments->module~utility module~adjustments->module~array_index module~adjustments->module~setting_definition module~adjustments->module~data_keys module~face_values->module~globals module~face_values->module~utility module~face_values->module~array_index module~face_values->module~adjustments module~face_values->module~setting_definition module~face_values->module~bc module~face_values->module~data_keys module~setting_definition->module~type_definitions module~bc->module~globals module~bc->module~utility module~bc->module~array_index module~bc->module~setting_definition module~bc->module~data_keys module~bc->module~type_definitions module~data_keys->module~globals module~junction->module~globals module~junction->module~utility module~junction->module~array_index module~junction->module~setting_definition module~junction->module~data_keys var panmodulerunge_kuttaUsesGraph = svgPanZoom('#modulerunge_kuttaUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~runge_kutta~~UsedByGraph module~runge_kutta runge_kutta module~time_loop time_loop module~time_loop->module~runge_kutta program~main main program~main->module~time_loop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines rk2 sve_rk2_step rk2_update_auxiliary_variables overwrite_old_values Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Subroutines public subroutine rk2 (elem2R, elemMR, elem2I, elemMI, faceR, faceI, elem2YN, elemMYN, faceYN, bcdataDn, bcdataUp, thistime, dt) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(inout), target :: elem2I (:,:) integer, intent(inout), target :: elemMI (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(inout), target :: faceI (:,:) logical, intent(inout), target :: elem2YN (:,:) logical, intent(inout), target :: elemMYN (:,:) logical, intent(inout), target :: faceYN (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) real, intent(in) :: thistime real, intent(in) :: dt private subroutine sve_rk2_step (e2r_Volume_old, e2r_Velocity_old, eMr_Volume_old, eMr_Velocity_old, e2r_Volume_new, e2r_Velocity_new, eMr_Volume_new, eMr_Velocity_new, elem2R, elemMR, faceR, elem2I, elemMI, elem2YN, elemMYN, thiscoef) Arguments Type Intent Optional Attributes Name integer, intent(in) :: e2r_Volume_old integer, intent(in) :: e2r_Velocity_old integer, intent(in) :: eMr_Volume_old integer, intent(in) :: eMr_Velocity_old integer, intent(in) :: e2r_Volume_new integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: eMr_Volume_new integer, intent(in) :: eMr_Velocity_new real, intent(inout), target :: elem2R (:,:) real, intent(inout), target :: elemMR (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in), target :: elem2I (:,:) integer, intent(in), target :: elemMI (:,:) logical, intent(inout) :: elem2YN (:,:) logical, intent(inout) :: elemMYN (:,:) real, intent(in) :: thiscoef private subroutine rk2_update_auxiliary_variables (e2r_Velocity_new, eMr_Velocity_new, e2r_Volume_new, eMr_Volume_new, elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, faceI, faceYN, bcdataDn, bcdataUp, steptime, rkiteration) Arguments Type Intent Optional Attributes Name integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: eMr_Velocity_new integer, intent(in) :: e2r_Volume_new integer, intent(in) :: eMr_Volume_new real, intent(inout) :: elem2R (:,:) integer, intent(inout) :: elem2I (:,:) logical, intent(inout) :: elem2YN (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(inout) :: elemMI (:,:) logical, intent(inout) :: elemMYN (:,:) real, intent(inout) :: faceR (:,:) integer, intent(inout) :: faceI (:,:) logical, intent(inout) :: faceYN (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) real, intent(in) :: steptime integer, intent(in) :: rkiteration private subroutine overwrite_old_values (elemR, elemI, er_Velocity, er_Velocity_new, er_Volume, er_Volume_new, ei_elem_type, ThisElemType, overwriteGhost) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elemR (:,:) integer, intent(in) :: elemI (:,:) integer, intent(in) :: er_Velocity integer, intent(in) :: er_Velocity_new integer, intent(in) :: er_Volume integer, intent(in) :: er_Volume_new integer, intent(in) :: ei_elem_type integer, intent(in) :: ThisElemType logical, intent(in) :: overwriteGhost","title":"runge_kutta – SWMMengine","tags":"","loc":"module/runge_kutta.html"},{"text":"Uses globals module~~data_keys~~UsesGraph module~data_keys data_keys module~globals globals module~data_keys->module~globals module~setting_definition setting_definition module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~setting_definition->module~type_definitions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~data_keys~~UsedByGraph module~data_keys data_keys module~output output module~output->module~data_keys module~utility utility module~output->module~utility module~bc bc module~output->module~bc program~main main program~main->module~data_keys program~main->module~output module~time_loop time_loop program~main->module~time_loop module~test_cases test_cases program~main->module~test_cases module~initialization initialization program~main->module~initialization program~main->module~utility module~diagnostic diagnostic program~main->module~diagnostic module~network_define network_define program~main->module~network_define module~initial_condition initial_condition program~main->module~initial_condition program~main->module~bc module~junction junction program~main->module~junction module~debug debug program~main->module~debug module~checking checking program~main->module~checking module~allocate_storage allocate_storage program~main->module~allocate_storage module~time_loop->module~data_keys module~time_loop->module~output module~explicit_euler explicit_euler module~time_loop->module~explicit_euler module~time_loop->module~diagnostic module~face_values face_values module~time_loop->module~face_values module~time_loop->module~bc module~runge_kutta runge_kutta module~time_loop->module~runge_kutta module~time_loop->module~debug module~custom_network custom_network module~custom_network->module~data_keys module~test_cases->module~data_keys module~case_simple_channel case_simple_channel module~test_cases->module~case_simple_channel module~case_y_channel case_y_channel module~test_cases->module~case_y_channel module~test_cases->module~utility module~test_cases->module~bc module~initialization->module~data_keys module~explicit_euler->module~data_keys module~explicit_euler->module~utility module~element_dynamics element_dynamics module~explicit_euler->module~element_dynamics module~adjustments adjustments module~explicit_euler->module~adjustments module~explicit_euler->module~face_values module~explicit_euler->module~bc module~element_geometry element_geometry module~explicit_euler->module~element_geometry module~case_simple_channel->module~data_keys module~case_simple_channel->module~bc module~case_simple_channel->module~allocate_storage module~case_y_channel->module~data_keys module~case_y_channel->module~bc module~case_y_channel->module~allocate_storage module~stub stub module~stub->module~data_keys module~utility->module~data_keys module~element_dynamics->module~data_keys module~element_dynamics->module~utility module~element_dynamics->module~adjustments module~element_dynamics->module~bc module~element_dynamics->module~junction module~diagnostic->module~data_keys module~diagnostic->module~utility module~diagnostic->module~bc module~adjustments->module~data_keys module~adjustments->module~utility module~face_values->module~data_keys module~face_values->module~utility module~face_values->module~adjustments module~face_values->module~bc module~network_define->module~data_keys module~network_define->module~initialization module~network_define->module~junction module~network_define->module~allocate_storage module~initial_condition->module~data_keys module~initial_condition->module~utility module~initial_condition->module~element_dynamics module~initial_condition->module~face_values module~initial_condition->module~bc module~initial_condition->module~junction module~initial_condition->module~element_geometry module~bc->module~data_keys module~bc->module~utility module~runge_kutta->module~data_keys module~runge_kutta->module~utility module~runge_kutta->module~element_dynamics module~runge_kutta->module~diagnostic module~runge_kutta->module~adjustments module~runge_kutta->module~face_values module~runge_kutta->module~bc module~runge_kutta->module~element_geometry module~junction->module~data_keys module~junction->module~utility module~friction_model friction_model module~friction_model->module~data_keys module~element_geometry->module~data_keys module~element_geometry->module~utility module~element_geometry->module~adjustments module~element_geometry->module~bc module~element_geometry->module~junction module~debug->module~data_keys module~debug->module~utility module~debug->module~bc module~checking->module~data_keys module~allocate_storage->module~utility var panmoduledata_keysUsedByGraph = svgPanZoom('#moduledata_keysUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables eChannel ePipe eJunctionChannel eJunctionPipe eCulvert ePump eValve eBCup eBCdn fChannel fPipe fMultiple fBCup fBCdn eRectangular eParabolic eTrapezoidal eWidthDepth eManningsN eCD jump_none jump_downstream jump_upstream nJ2 nJm nBCdn nBCup nUnassigned nAssigned nDeferred lchannel lpipe lRectangular lParabolic lTrapezoidal lWidthDepth lManningsN lCD lUnassigned lAssigned lDeferred bc_updn_downstream bc_updn_upstream bc_category_elevation bc_category_inflowrate Variables Type Visibility Attributes Name Initial integer, public, parameter :: eChannel = 1 integer, public, parameter :: ePipe = 2 integer, public, parameter :: eJunctionChannel = 3 integer, public, parameter :: eJunctionPipe = 4 integer, public, parameter :: eCulvert = 5 integer, public, parameter :: ePump = 6 integer, public, parameter :: eValve = 7 integer, public, parameter :: eBCup = 8 integer, public, parameter :: eBCdn = 9 integer, public, parameter :: fChannel = eChannel integer, public, parameter :: fPipe = ePipe integer, public, parameter :: fMultiple = eJunctionChannel integer, public, parameter :: fBCup = eBCup integer, public, parameter :: fBCdn = eBCdn integer, public, parameter :: eRectangular = 1 integer, public, parameter :: eParabolic = 2 integer, public, parameter :: eTrapezoidal = 3 integer, public, parameter :: eWidthDepth = 4 integer, public, parameter :: eManningsN = 1 integer, public, parameter :: eCD = 2 integer, public, parameter :: jump_none = 0 integer, public, parameter :: jump_downstream = 1 integer, public, parameter :: jump_upstream = 2 integer, public, parameter :: nJ2 = 1 integer, public, parameter :: nJm = 2 integer, public, parameter :: nBCdn = 3 integer, public, parameter :: nBCup = 4 integer, public, parameter :: nUnassigned = nullvalueI integer, public, parameter :: nAssigned = 1 integer, public, parameter :: nDeferred = -1 integer, public, parameter :: lchannel = eChannel integer, public, parameter :: lpipe = ePipe integer, public, parameter :: lRectangular = eRectangular integer, public, parameter :: lParabolic = eParabolic integer, public, parameter :: lTrapezoidal = eTrapezoidal integer, public, parameter :: lWidthDepth = eWidthDepth integer, public, parameter :: lManningsN = eManningsN integer, public, parameter :: lCD = eCD integer, public, parameter :: lUnassigned = nullvalueI integer, public, parameter :: lAssigned = 1 integer, public, parameter :: lDeferred = -1 integer, public, parameter :: bc_updn_downstream = 1 integer, public, parameter :: bc_updn_upstream = 0 integer, public, parameter :: bc_category_elevation = 0 integer, public, parameter :: bc_category_inflowrate = 1","title":"data_keys – SWMMengine","tags":"","loc":"module/data_keys.html"},{"text":"Uses array_index bc data_keys debug diagnostic explicit_euler face_values globals output runge_kutta setting_definition module~~time_loop~~UsesGraph module~time_loop time_loop module~globals globals module~time_loop->module~globals module~output output module~time_loop->module~output module~runge_kutta runge_kutta module~time_loop->module~runge_kutta module~array_index array_index module~time_loop->module~array_index module~diagnostic diagnostic module~time_loop->module~diagnostic module~explicit_euler explicit_euler module~time_loop->module~explicit_euler module~face_values face_values module~time_loop->module~face_values module~debug debug module~time_loop->module~debug module~setting_definition setting_definition module~time_loop->module~setting_definition module~bc bc module~time_loop->module~bc module~data_keys data_keys module~time_loop->module~data_keys module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~output->module~globals module~output->module~array_index module~output->module~setting_definition module~output->module~bc module~output->module~data_keys module~utility utility module~output->module~utility module~runge_kutta->module~globals module~runge_kutta->module~array_index module~runge_kutta->module~diagnostic module~runge_kutta->module~face_values module~runge_kutta->module~setting_definition module~runge_kutta->module~bc module~runge_kutta->module~data_keys module~element_dynamics element_dynamics module~runge_kutta->module~element_dynamics module~element_geometry element_geometry module~runge_kutta->module~element_geometry module~runge_kutta->module~utility module~adjustments adjustments module~runge_kutta->module~adjustments module~array_index->module~globals module~diagnostic->module~globals module~diagnostic->module~array_index module~diagnostic->module~setting_definition module~diagnostic->module~bc module~diagnostic->module~data_keys module~diagnostic->module~utility module~diagnostic->module~type_definitions module~explicit_euler->module~globals module~explicit_euler->module~array_index module~explicit_euler->module~face_values module~explicit_euler->module~setting_definition module~explicit_euler->module~bc module~explicit_euler->module~data_keys module~explicit_euler->module~element_dynamics module~explicit_euler->module~element_geometry module~explicit_euler->module~utility module~explicit_euler->module~adjustments module~face_values->module~globals module~face_values->module~array_index module~face_values->module~setting_definition module~face_values->module~bc module~face_values->module~data_keys module~face_values->module~utility module~face_values->module~adjustments module~debug->module~globals module~debug->module~array_index module~debug->module~setting_definition module~debug->module~bc module~debug->module~data_keys module~debug->module~utility module~debug->module~type_definitions module~setting_definition->module~type_definitions module~bc->module~globals module~bc->module~array_index module~bc->module~setting_definition module~bc->module~data_keys module~bc->module~utility module~bc->module~type_definitions module~data_keys->module~globals module~element_dynamics->module~globals module~element_dynamics->module~array_index module~element_dynamics->module~setting_definition module~element_dynamics->module~bc module~element_dynamics->module~data_keys module~element_dynamics->module~utility module~element_dynamics->module~adjustments module~junction junction module~element_dynamics->module~junction module~element_geometry->module~globals module~element_geometry->module~array_index module~element_geometry->module~setting_definition module~element_geometry->module~bc module~element_geometry->module~data_keys module~element_geometry->module~utility module~element_geometry->module~adjustments module~element_geometry->module~junction module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~utility->module~data_keys module~adjustments->module~globals module~adjustments->module~array_index module~adjustments->module~setting_definition module~adjustments->module~data_keys module~adjustments->module~utility module~junction->module~globals module~junction->module~array_index module~junction->module~setting_definition module~junction->module~data_keys module~junction->module~utility var panmoduletime_loopUsesGraph = svgPanZoom('#moduletime_loopUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~time_loop~~UsedByGraph module~time_loop time_loop program~main main program~main->module~time_loop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel idummy Subroutines time_marching Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 integer, private, parameter :: idummy = 0 Subroutines public subroutine time_marching (elem2R, elemMR, faceR, elem2I, elemMI, faceI, elem2YN, elemMYN, faceYN, bcdataDn, bcdataUp, linkI, debugfile, diagnostic, threadedfile) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) real, intent(inout), target :: elemMR (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(inout), target :: elem2I (:,:) integer, intent(inout), target :: elemMI (:,:) integer, intent(inout), target :: faceI (:,:) logical, intent(inout), target :: elem2YN (:,:) logical, intent(inout), target :: elemMYN (:,:) logical, intent(inout), target :: faceYN (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) integer, intent(in) :: linkI (:,:) type(debugfileType), intent(in), target :: debugfile (:) type(diagnosticType), intent(inout), target :: diagnostic (:) type(threadedfileType), intent(in) :: threadedfile (:)","title":"time_loop – SWMMengine","tags":"","loc":"module/time_loop.html"},{"text":"Uses array_index bc data_keys globals setting_definition type_definitions utility module~~debug~~UsesGraph module~debug debug module~globals globals module~debug->module~globals module~utility utility module~debug->module~utility module~array_index array_index module~debug->module~array_index module~type_definitions type_definitions module~debug->module~type_definitions module~setting_definition setting_definition module~debug->module~setting_definition module~bc bc module~debug->module~bc module~data_keys data_keys module~debug->module~data_keys module~globals->module~type_definitions module~globals->module~setting_definition module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~utility->module~data_keys module~array_index->module~globals module~setting_definition->module~type_definitions module~bc->module~globals module~bc->module~utility module~bc->module~array_index module~bc->module~type_definitions module~bc->module~setting_definition module~bc->module~data_keys module~data_keys->module~globals var panmoduledebugUsesGraph = svgPanZoom('#moduledebugUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~debug~~UsedByGraph module~debug debug program~main main program~main->module~debug module~time_loop time_loop program~main->module~time_loop module~time_loop->module~debug Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines debug_initialize debug_output debug_finalize debug_singlefile_open Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Subroutines public subroutine debug_initialize (debugfile) Arguments Type Intent Optional Attributes Name type(debugfileType), intent(out), dimension(:), allocatable :: debugfile public subroutine debug_output (debugfile, elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, faceI, faceYN, bcdataUp, bcdataDn, thisstep) Arguments Type Intent Optional Attributes Name type(debugfileType), intent(in), target :: debugfile (:) real, intent(in), target :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) logical, intent(in), target :: elem2YN (:,:) real, intent(in), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) logical, intent(in), target :: elemMYN (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in), target :: faceI (:,:) logical, intent(in), target :: faceYN (:,:) type(bcType), intent(in) :: bcdataUp (:) type(bcType), intent(in) :: bcdataDn (:) integer, intent(in) :: thisstep public subroutine debug_finalize (debugfile) Arguments Type Intent Optional Attributes Name type(debugfileType), intent(inout) :: debugfile (:) private subroutine debug_singlefile_open (debugfile, ArrayName, DataName, ColumnIndex) Arguments Type Intent Optional Attributes Name type(debugfileType), intent(inout) :: debugfile character(len=*), intent(in) :: ArrayName character(len=*), intent(in) :: DataName integer, intent(in) :: ColumnIndex","title":"debug – SWMMengine","tags":"","loc":"module/debug.html"},{"text":"Uses array_index data_keys globals setting_definition module~~stub~~UsesGraph module~stub stub module~array_index array_index module~stub->module~array_index module~globals globals module~stub->module~globals module~data_keys data_keys module~stub->module~data_keys module~setting_definition setting_definition module~stub->module~setting_definition module~array_index->module~globals module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~data_keys->module~globals module~setting_definition->module~type_definitions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines x Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 1 Subroutines private subroutine x () Arguments None","title":"stub – SWMMengine","tags":"","loc":"module/stub.html"},{"text":"Used by module~~type_definitions~~UsedByGraph module~type_definitions type_definitions module~globals globals module~globals->module~type_definitions module~setting_definition setting_definition module~globals->module~setting_definition program~main main program~main->module~type_definitions program~main->module~globals module~diagnostic diagnostic program~main->module~diagnostic module~debug debug program~main->module~debug program~main->module~setting_definition module~bc bc program~main->module~bc module~output output program~main->module~output module~allocate_storage allocate_storage program~main->module~allocate_storage module~time_loop time_loop program~main->module~time_loop module~test_cases test_cases program~main->module~test_cases module~initialization initialization program~main->module~initialization module~array_index array_index program~main->module~array_index module~utility utility program~main->module~utility module~network_define network_define program~main->module~network_define module~initial_condition initial_condition program~main->module~initial_condition module~junction junction program~main->module~junction module~checking checking program~main->module~checking module~data_keys data_keys program~main->module~data_keys module~diagnostic->module~type_definitions module~diagnostic->module~globals module~diagnostic->module~setting_definition module~diagnostic->module~bc module~diagnostic->module~array_index module~diagnostic->module~utility module~diagnostic->module~data_keys module~debug->module~type_definitions module~debug->module~globals module~debug->module~setting_definition module~debug->module~bc module~debug->module~array_index module~debug->module~utility module~debug->module~data_keys module~setting_definition->module~type_definitions module~bc->module~type_definitions module~bc->module~globals module~bc->module~setting_definition module~bc->module~array_index module~bc->module~utility module~bc->module~data_keys module~output->module~globals module~output->module~setting_definition module~output->module~bc module~output->module~array_index module~output->module~utility module~output->module~data_keys module~allocate_storage->module~globals module~allocate_storage->module~array_index module~allocate_storage->module~utility module~custom_network custom_network module~custom_network->module~globals module~custom_network->module~array_index module~custom_network->module~data_keys module~time_loop->module~globals module~time_loop->module~diagnostic module~time_loop->module~debug module~time_loop->module~setting_definition module~time_loop->module~bc module~time_loop->module~output module~time_loop->module~array_index module~explicit_euler explicit_euler module~time_loop->module~explicit_euler module~face_values face_values module~time_loop->module~face_values module~runge_kutta runge_kutta module~time_loop->module~runge_kutta module~time_loop->module~data_keys module~test_cases->module~globals module~test_cases->module~setting_definition module~test_cases->module~bc module~test_cases->module~array_index module~case_simple_channel case_simple_channel module~test_cases->module~case_simple_channel module~case_y_channel case_y_channel module~test_cases->module~case_y_channel module~test_cases->module~utility module~test_cases->module~data_keys module~initialization->module~globals module~initialization->module~array_index module~initialization->module~data_keys module~array_index->module~globals module~explicit_euler->module~globals module~explicit_euler->module~setting_definition module~explicit_euler->module~bc module~explicit_euler->module~array_index module~explicit_euler->module~utility module~element_dynamics element_dynamics module~explicit_euler->module~element_dynamics module~adjustments adjustments module~explicit_euler->module~adjustments module~explicit_euler->module~face_values module~element_geometry element_geometry module~explicit_euler->module~element_geometry module~explicit_euler->module~data_keys module~case_simple_channel->module~globals module~case_simple_channel->module~setting_definition module~case_simple_channel->module~bc module~case_simple_channel->module~allocate_storage module~case_simple_channel->module~array_index module~case_simple_channel->module~data_keys module~case_y_channel->module~globals module~case_y_channel->module~setting_definition module~case_y_channel->module~bc module~case_y_channel->module~allocate_storage module~case_y_channel->module~array_index module~case_y_channel->module~data_keys module~stub stub module~stub->module~globals module~stub->module~setting_definition module~stub->module~array_index module~stub->module~data_keys module~utility->module~globals module~utility->module~setting_definition module~utility->module~array_index module~utility->module~data_keys module~element_dynamics->module~globals module~element_dynamics->module~setting_definition module~element_dynamics->module~bc module~element_dynamics->module~array_index module~element_dynamics->module~utility module~element_dynamics->module~adjustments module~element_dynamics->module~junction module~element_dynamics->module~data_keys module~adjustments->module~globals module~adjustments->module~setting_definition module~adjustments->module~array_index module~adjustments->module~utility module~adjustments->module~data_keys module~face_values->module~globals module~face_values->module~setting_definition module~face_values->module~bc module~face_values->module~array_index module~face_values->module~utility module~face_values->module~adjustments module~face_values->module~data_keys module~network_define->module~globals module~network_define->module~allocate_storage module~network_define->module~initialization module~network_define->module~array_index module~network_define->module~junction module~network_define->module~data_keys module~initial_condition->module~globals module~initial_condition->module~setting_definition module~initial_condition->module~bc module~initial_condition->module~array_index module~initial_condition->module~utility module~initial_condition->module~element_dynamics module~initial_condition->module~face_values module~initial_condition->module~junction module~initial_condition->module~element_geometry module~initial_condition->module~data_keys module~runge_kutta->module~globals module~runge_kutta->module~diagnostic module~runge_kutta->module~setting_definition module~runge_kutta->module~bc module~runge_kutta->module~array_index module~runge_kutta->module~utility module~runge_kutta->module~element_dynamics module~runge_kutta->module~adjustments module~runge_kutta->module~face_values module~runge_kutta->module~element_geometry module~runge_kutta->module~data_keys module~junction->module~globals module~junction->module~setting_definition module~junction->module~array_index module~junction->module~utility module~junction->module~data_keys module~friction_model friction_model module~friction_model->module~globals module~friction_model->module~setting_definition module~friction_model->module~array_index module~friction_model->module~data_keys module~element_geometry->module~globals module~element_geometry->module~setting_definition module~element_geometry->module~bc module~element_geometry->module~array_index module~element_geometry->module~utility module~element_geometry->module~adjustments module~element_geometry->module~junction module~element_geometry->module~data_keys module~checking->module~globals module~checking->module~array_index module~checking->module~data_keys module~data_keys->module~globals var panmoduletype_definitionsUsedByGraph = svgPanZoom('#moduletype_definitionsUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types string diagnosticVolumeType diagnosticType bcType outputfileType debugfileType threadedfileType Derived Types type, public :: string Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: str type, public :: diagnosticVolumeType Components Type Visibility Attributes Name Initial integer, public :: Step real, public :: Time real, public :: Volume real, public :: VolumeChange real, public :: NetInflowVolume real, public :: InflowRate real, public :: OutflowRate real, public :: ConservationThisStep real, public :: ConservationTotal type, public :: diagnosticType Components Type Visibility Attributes Name Initial type( diagnosticVolumeType ), public :: Volume type, public :: bcType Components Type Visibility Attributes Name Initial integer, public :: Idx integer, public :: NodeID integer, public :: FaceID integer, public :: ElemGhostID integer, public :: ElemInsideID integer, public :: Updn integer, public :: Category real, public, dimension(:), allocatable :: TimeArray real, public, dimension(:), allocatable :: ValueArray real, public :: ThisValue real, public :: ThisTime real, public :: ThisFlowrate type, public :: outputfileType Components Type Visibility Attributes Name Initial integer, public :: UnitNumber = 0 character(len=256), public :: FileName = 'dummy.txt' character(len=256), public :: FolderName = 'dummyFolder' character(len=256), public :: FolderPath = './' character(len=32), public :: FileStatus = 'new' character(len=512), public :: WriteName = '' logical, public :: IsOpen = .false. type, public :: debugfileType Components Type Visibility Attributes Name Initial type( outputfileType ), public :: FileInfo character(len=32), public :: ArrayName integer, public :: ColumnIndex type, public :: threadedfileType Components Type Visibility Attributes Name Initial type( outputfileType ), public :: FileInfo character(len=32), public :: DataName","title":"type_definitions – SWMMengine","tags":"","loc":"module/type_definitions.html"},{"text":"Uses setting_definition type_definitions module~~globals~~UsesGraph module~globals globals module~setting_definition setting_definition module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~setting_definition->module~type_definitions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~globals~~UsedByGraph module~globals globals module~output output module~output->module~globals module~array_index array_index module~output->module~array_index module~utility utility module~output->module~utility module~bc bc module~output->module~bc module~data_keys data_keys module~output->module~data_keys program~main main program~main->module~globals program~main->module~output module~allocate_storage allocate_storage program~main->module~allocate_storage module~time_loop time_loop program~main->module~time_loop module~test_cases test_cases program~main->module~test_cases module~initialization initialization program~main->module~initialization program~main->module~array_index program~main->module~utility module~diagnostic diagnostic program~main->module~diagnostic module~network_define network_define program~main->module~network_define module~initial_condition initial_condition program~main->module~initial_condition program~main->module~bc module~junction junction program~main->module~junction module~debug debug program~main->module~debug module~checking checking program~main->module~checking program~main->module~data_keys module~allocate_storage->module~globals module~allocate_storage->module~array_index module~allocate_storage->module~utility module~custom_network custom_network module~custom_network->module~globals module~custom_network->module~array_index module~custom_network->module~data_keys module~time_loop->module~globals module~time_loop->module~output module~time_loop->module~array_index module~explicit_euler explicit_euler module~time_loop->module~explicit_euler module~time_loop->module~diagnostic module~face_values face_values module~time_loop->module~face_values module~time_loop->module~bc module~runge_kutta runge_kutta module~time_loop->module~runge_kutta module~time_loop->module~debug module~time_loop->module~data_keys module~test_cases->module~globals module~test_cases->module~array_index module~case_simple_channel case_simple_channel module~test_cases->module~case_simple_channel module~case_y_channel case_y_channel module~test_cases->module~case_y_channel module~test_cases->module~utility module~test_cases->module~bc module~test_cases->module~data_keys module~initialization->module~globals module~initialization->module~array_index module~initialization->module~data_keys module~array_index->module~globals module~explicit_euler->module~globals module~explicit_euler->module~array_index module~explicit_euler->module~utility module~element_dynamics element_dynamics module~explicit_euler->module~element_dynamics module~adjustments adjustments module~explicit_euler->module~adjustments module~explicit_euler->module~face_values module~explicit_euler->module~bc module~element_geometry element_geometry module~explicit_euler->module~element_geometry module~explicit_euler->module~data_keys module~case_simple_channel->module~globals module~case_simple_channel->module~allocate_storage module~case_simple_channel->module~array_index module~case_simple_channel->module~bc module~case_simple_channel->module~data_keys module~case_y_channel->module~globals module~case_y_channel->module~allocate_storage module~case_y_channel->module~array_index module~case_y_channel->module~bc module~case_y_channel->module~data_keys module~stub stub module~stub->module~globals module~stub->module~array_index module~stub->module~data_keys module~utility->module~globals module~utility->module~array_index module~utility->module~data_keys module~element_dynamics->module~globals module~element_dynamics->module~array_index module~element_dynamics->module~utility module~element_dynamics->module~adjustments module~element_dynamics->module~bc module~element_dynamics->module~junction module~element_dynamics->module~data_keys module~diagnostic->module~globals module~diagnostic->module~array_index module~diagnostic->module~utility module~diagnostic->module~bc module~diagnostic->module~data_keys module~adjustments->module~globals module~adjustments->module~array_index module~adjustments->module~utility module~adjustments->module~data_keys module~face_values->module~globals module~face_values->module~array_index module~face_values->module~utility module~face_values->module~adjustments module~face_values->module~bc module~face_values->module~data_keys module~network_define->module~globals module~network_define->module~allocate_storage module~network_define->module~initialization module~network_define->module~array_index module~network_define->module~junction module~network_define->module~data_keys module~initial_condition->module~globals module~initial_condition->module~array_index module~initial_condition->module~utility module~initial_condition->module~element_dynamics module~initial_condition->module~face_values module~initial_condition->module~bc module~initial_condition->module~junction module~initial_condition->module~element_geometry module~initial_condition->module~data_keys module~bc->module~globals module~bc->module~array_index module~bc->module~utility module~bc->module~data_keys module~runge_kutta->module~globals module~runge_kutta->module~array_index module~runge_kutta->module~utility module~runge_kutta->module~element_dynamics module~runge_kutta->module~diagnostic module~runge_kutta->module~adjustments module~runge_kutta->module~face_values module~runge_kutta->module~bc module~runge_kutta->module~element_geometry module~runge_kutta->module~data_keys module~junction->module~globals module~junction->module~array_index module~junction->module~utility module~junction->module~data_keys module~friction_model friction_model module~friction_model->module~globals module~friction_model->module~array_index module~friction_model->module~data_keys module~element_geometry->module~globals module~element_geometry->module~array_index module~element_geometry->module~utility module~element_geometry->module~adjustments module~element_geometry->module~bc module~element_geometry->module~junction module~element_geometry->module~data_keys module~debug->module~globals module~debug->module~array_index module~debug->module~utility module~debug->module~bc module~debug->module~data_keys module~checking->module~globals module~checking->module~array_index module~checking->module~data_keys module~data_keys->module~globals var panmoduleglobalsUsedByGraph = svgPanZoom('#moduleglobalsUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables casename nullvalueI nullvalueR nullvalueL zeroR oneR twoR threeR fourR eightR tenR oneeighthR onefourthR onethirdR onehalfR twothirdR threefourthR zeroI oneI N_link N_node N_elem2 N_elemM N_face N_BCupstream N_BCdnstream dummy_face_index dummy_elem2_index dummy_elemM_index next_e2i_temparray next_e2r_temparray next_e2YN_temparray next_eMi_temparray next_eMr_temparray next_eMYN_temparray next_fi_temparray next_fr_temparray next_fYN_temparray outputfile_next_unitnumber dt grav debugcounter debuglevelall idummyarray Variables Type Visibility Attributes Name Initial character(len=99), public :: casename integer, public, parameter :: nullvalueI = -998877 real, public, parameter :: nullvalueR = -9.98877e16 logical, public, parameter :: nullvalueL = .false. real, public, parameter :: zeroR = 0.0 real, public, parameter :: oneR = 1.0 real, public, parameter :: twoR = 2.0 real, public, parameter :: threeR = 3.0 real, public, parameter :: fourR = 4.0 real, public, parameter :: eightR = 8.0 real, public, parameter :: tenR = 10.0 real, public, parameter :: oneeighthR = oneR/eightR real, public, parameter :: onefourthR = oneR/fourR real, public, parameter :: onethirdR = oneR/threeR real, public, parameter :: onehalfR = oneR/twoR real, public, parameter :: twothirdR = twoR/threeR real, public, parameter :: threefourthR = threeR/fourR integer, public, parameter :: zeroI = 0 integer, public, parameter :: oneI = 1 integer, public :: N_link integer, public :: N_node integer, public :: N_elem2 integer, public :: N_elemM integer, public :: N_face integer, public :: N_BCupstream integer, public :: N_BCdnstream integer, public :: dummy_face_index integer, public :: dummy_elem2_index integer, public :: dummy_elemM_index integer, public :: next_e2i_temparray = 1 integer, public :: next_e2r_temparray = 1 integer, public :: next_e2YN_temparray = 1 integer, public :: next_eMi_temparray = 1 integer, public :: next_eMr_temparray = 1 integer, public :: next_eMYN_temparray = 1 integer, public :: next_fi_temparray = 1 integer, public :: next_fr_temparray = 1 integer, public :: next_fYN_temparray = 1 integer, public :: outputfile_next_unitnumber = 10 real, public, pointer :: dt => setting%time%dt real, public, pointer :: grav => setting%constant%gravity integer, public :: debugcounter = 0 integer, public, parameter :: debuglevelall = 0 integer, public :: idummyarray (1)","title":"globals – SWMMengine","tags":"","loc":"module/globals.html"},{"text":"Uses array_index data_keys setting_definition globals utility module~~adjustments~~UsesGraph module~adjustments adjustments module~array_index array_index module~adjustments->module~array_index module~globals globals module~adjustments->module~globals module~utility utility module~adjustments->module~utility module~data_keys data_keys module~adjustments->module~data_keys module~setting_definition setting_definition module~adjustments->module~setting_definition module~array_index->module~globals module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~utility->module~array_index module~utility->module~globals module~utility->module~data_keys module~utility->module~setting_definition module~data_keys->module~globals module~setting_definition->module~type_definitions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~adjustments~~UsedByGraph module~adjustments adjustments module~element_dynamics element_dynamics module~element_dynamics->module~adjustments module~runge_kutta runge_kutta module~runge_kutta->module~adjustments module~runge_kutta->module~element_dynamics module~element_geometry element_geometry module~runge_kutta->module~element_geometry module~face_values face_values module~runge_kutta->module~face_values module~element_geometry->module~adjustments module~explicit_euler explicit_euler module~explicit_euler->module~adjustments module~explicit_euler->module~element_dynamics module~explicit_euler->module~element_geometry module~explicit_euler->module~face_values module~face_values->module~adjustments module~initial_condition initial_condition module~initial_condition->module~element_dynamics module~initial_condition->module~element_geometry module~initial_condition->module~face_values module~time_loop time_loop module~time_loop->module~runge_kutta module~time_loop->module~explicit_euler module~time_loop->module~face_values program~main main program~main->module~initial_condition program~main->module~time_loop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines adjust_channel_velocity_limiter adjust_junction_branch_velocity_limit adjust_face_dynamic_limits adjust_for_zero_geometry adjust_negative_volume_reset adjust_smallvolumes adjust_Vshaped_flowrate adjust_zero_velocity_at_zero_volume smallvolume_identification smallvolume_identification_for_element smallvolume_geometry smallvolume_element_geometry_reset smallvolume_junctionbranch_reset reset_element_for_zero_values reset_juctionbranches_for_zero_values zero_velocity_at_zero_volume Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Subroutines public subroutine adjust_channel_velocity_limiter (elemR, elemYN, elemI, ei_elem_type, elemType, eYN_IsAdhocFlowrate, er_Velocity_new) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) logical, intent(inout) :: elemYN (:,:) integer, intent(in) :: elemI (:,:) integer, intent(in) :: ei_elem_type integer, intent(in) :: elemType integer, intent(in) :: eYN_IsAdhocFlowrate integer, intent(in) :: er_Velocity_new public subroutine adjust_junction_branch_velocity_limit (elemMR, elemMI) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) public subroutine adjust_face_dynamic_limits (faceR, faceI, volumeUp, volumeDn, facemask, Ltemp) Arguments Type Intent Optional Attributes Name real, intent(inout) :: faceR (:,:) integer, intent(in), target :: faceI (:,:) real, intent(in) :: volumeUp (:) real, intent(in) :: volumeDn (:) logical, intent(in) :: facemask (:) logical, intent(in) :: Ltemp public subroutine adjust_for_zero_geometry (elem2R, elem2YN, elemMR, elemMI, elemMYN) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) logical, intent(in) :: elem2YN (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) logical, intent(in) :: elemMYN (:,:) public subroutine adjust_negative_volume_reset (volume) Arguments Type Intent Optional Attributes Name real, intent(inout) :: volume (:) public subroutine adjust_smallvolumes (elem2R, elem2I, elem2YN, e2r_VolumeColumn, elemMR, elemMI, elemMYN, eMr_VolumeColumn) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) logical, intent(inout) :: elem2YN (:,:) integer, intent(in) :: e2r_VolumeColumn real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) logical, intent(inout) :: elemMYN (:,:) integer, intent(in) :: eMr_VolumeColumn public subroutine adjust_Vshaped_flowrate (elem2R, faceR, elem2I, elem2YN) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in), target :: elem2I (:,:) logical, intent(inout), target :: elem2YN (:,:) public subroutine adjust_zero_velocity_at_zero_volume (elem2R, elem2YN, e2r_VelocityColumn, e2r_VolumeColumn, elemMR, elemMYN, eMr_VelocityColumn, eMr_VolumeColumn) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) logical, intent(inout) :: elem2YN (:,:) integer, intent(in) :: e2r_VelocityColumn integer, intent(in) :: e2r_VolumeColumn real, intent(inout) :: elemMR (:,:) logical, intent(inout) :: elemMYN (:,:) integer, intent(in) :: eMr_VelocityColumn integer, intent(in) :: eMr_VolumeColumn private subroutine smallvolume_identification (elem2R, elem2I, elem2YN, eTr_Volume2, elemMR, elemMI, elemMYN, eTr_VolumeM) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) logical, intent(inout), target :: elem2YN (:,:) integer, intent(in) :: eTr_Volume2 real, intent(inout), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) logical, intent(inout), target :: elemMYN (:,:) integer, intent(in) :: eTr_VolumeM private subroutine smallvolume_identification_for_element (volume, smallvolumeratio, smallvolume, issmallvolume, elemtype, thiselementtype) Arguments Type Intent Optional Attributes Name real, intent(inout) :: volume (:) real, intent(inout) :: smallvolumeratio (:) real, intent(in) :: smallvolume (:) logical, intent(inout) :: issmallvolume (:) integer, intent(in) :: elemtype (:) integer, intent(in) :: thiselementtype private subroutine smallvolume_geometry (elem2R, elem2YN, elemMR, elemMYN) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) logical, intent(in) :: elem2YN (:,:) real, intent(inout), target :: elemMR (:,:) logical, intent(in) :: elemMYN (:,:) private subroutine smallvolume_element_geometry_reset (elemR, elemYN, er_Area, er_Eta, er_Perimeter, er_Zbottom, er_HydDepth, er_HydRadius, er_Topwidth, eYN_IsSmallVolume) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) logical, intent(in) :: elemYN (:,:) integer, intent(in) :: er_Area integer, intent(in) :: er_Eta integer, intent(in) :: er_Perimeter integer, intent(in) :: er_Zbottom integer, intent(in) :: er_HydDepth integer, intent(in) :: er_HydRadius integer, intent(in) :: er_Topwidth integer, intent(in) :: eYN_IsSmallVolume private subroutine smallvolume_junctionbranch_reset (elemMR, elemMYN, eMr_AreaDir, eMr_TopwidthDir, Dir_face_per_elem) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) logical, intent(in) :: elemMYN (:,:) integer, intent(in) :: eMr_AreaDir (:) integer, intent(in) :: eMr_TopwidthDir (:) integer, intent(in) :: Dir_face_per_elem private subroutine reset_element_for_zero_values (elemR, elemYN, er_Area, er_Eta, er_Zbottom, er_Topwidth, er_Perimeter, er_HydDepth, er_HydRadius, eYN_IsSmallVolume) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) logical, intent(in) :: elemYN (:,:) integer, intent(in) :: er_Area integer, intent(in) :: er_Eta integer, intent(in) :: er_Zbottom integer, intent(in) :: er_Topwidth integer, intent(in) :: er_Perimeter integer, intent(in) :: er_HydDepth integer, intent(in) :: er_HydRadius integer, intent(in) :: eYN_IsSmallVolume private subroutine reset_juctionbranches_for_zero_values (elemMR, elemMI, elemMYN, eMr_AreaDir, eMr_TopwidthDir, eMr_nfaces_Dir, Dir_face_per_elemM) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) logical, intent(in) :: elemMYN (:,:) integer, intent(in) :: eMr_AreaDir (:) integer, intent(in) :: eMr_TopwidthDir (:) integer, intent(in) :: eMr_nfaces_Dir integer, intent(in) :: Dir_face_per_elemM private subroutine zero_velocity_at_zero_volume (elemR, elemYN, er_Velocity, er_Volume, eYN_IsAdhocFlowrate) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) logical, intent(inout) :: elemYN (:,:) integer, intent(in) :: er_Velocity integer, intent(in) :: er_Volume integer, intent(in) :: eYN_IsAdhocFlowrate","title":"adjustments – SWMMengine","tags":"","loc":"module/adjustments.html"},{"text":"Uses array_index data_keys setting_definition globals module~~utility~~UsesGraph module~utility utility module~array_index array_index module~utility->module~array_index module~globals globals module~utility->module~globals module~data_keys data_keys module~utility->module~data_keys module~setting_definition setting_definition module~utility->module~setting_definition module~array_index->module~globals module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~data_keys->module~globals module~setting_definition->module~type_definitions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~utility~~UsedByGraph module~utility utility module~output output module~output->module~utility module~bc bc module~output->module~bc module~runge_kutta runge_kutta module~runge_kutta->module~utility module~element_dynamics element_dynamics module~runge_kutta->module~element_dynamics module~diagnostic diagnostic module~runge_kutta->module~diagnostic module~element_geometry element_geometry module~runge_kutta->module~element_geometry module~adjustments adjustments module~runge_kutta->module~adjustments module~face_values face_values module~runge_kutta->module~face_values module~runge_kutta->module~bc module~junction junction module~junction->module~utility module~element_dynamics->module~utility module~element_dynamics->module~junction module~element_dynamics->module~adjustments module~element_dynamics->module~bc program~main main program~main->module~utility program~main->module~output program~main->module~junction program~main->module~diagnostic module~allocate_storage allocate_storage program~main->module~allocate_storage module~debug debug program~main->module~debug module~initial_condition initial_condition program~main->module~initial_condition program~main->module~bc module~test_cases test_cases program~main->module~test_cases module~network_define network_define program~main->module~network_define module~time_loop time_loop program~main->module~time_loop module~diagnostic->module~utility module~diagnostic->module~bc module~element_geometry->module~utility module~element_geometry->module~junction module~element_geometry->module~adjustments module~element_geometry->module~bc module~adjustments->module~utility module~explicit_euler explicit_euler module~explicit_euler->module~utility module~explicit_euler->module~element_dynamics module~explicit_euler->module~element_geometry module~explicit_euler->module~adjustments module~explicit_euler->module~face_values module~explicit_euler->module~bc module~allocate_storage->module~utility module~face_values->module~utility module~face_values->module~adjustments module~face_values->module~bc module~debug->module~utility module~debug->module~bc module~initial_condition->module~utility module~initial_condition->module~junction module~initial_condition->module~element_dynamics module~initial_condition->module~element_geometry module~initial_condition->module~face_values module~initial_condition->module~bc module~bc->module~utility module~test_cases->module~utility module~test_cases->module~bc module~case_y_channel case_y_channel module~test_cases->module~case_y_channel module~case_simple_channel case_simple_channel module~test_cases->module~case_simple_channel module~network_define->module~junction module~network_define->module~allocate_storage module~case_y_channel->module~allocate_storage module~case_y_channel->module~bc module~case_simple_channel->module~allocate_storage module~case_simple_channel->module~bc module~time_loop->module~output module~time_loop->module~runge_kutta module~time_loop->module~diagnostic module~time_loop->module~explicit_euler module~time_loop->module~face_values module~time_loop->module~debug module~time_loop->module~bc var panmoduleutilityUsedByGraph = svgPanZoom('#moduleutilityUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Functions utility_advance_temp_array utility_average utility_linear_interpolate_within_indexlist utility_round_to_significant_digits utility_scale_of_number utility_sign_with_ones Subroutines utility_print_values_by_link utility_check_fileopen utility_check_allocation utility_get_datetime_stamp Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Functions public function utility_advance_temp_array (next_temparray, temparraysize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: next_temparray integer, intent(in) :: temparraysize Return Value integer public pure function utility_average (inarray) result(outscalar) Arguments Type Intent Optional Attributes Name real, intent(in) :: inarray (:) Return Value real public function utility_linear_interpolate_within_indexlist (thisIndex, IndexArray, ValueArray) result(thisValue) Arguments Type Intent Optional Attributes Name real, intent(in) :: thisIndex real, intent(in) :: IndexArray (:) real, intent(in) :: ValueArray (:) Return Value real public pure elemental function utility_round_to_significant_digits (inarray, idigits) result(outarray) Arguments Type Intent Optional Attributes Name real, intent(in) :: inarray integer, intent(in) :: idigits Return Value real public pure elemental function utility_scale_of_number (inarray) result(outarray) Arguments Type Intent Optional Attributes Name real, intent(in) :: inarray Return Value integer public pure elemental function utility_sign_with_ones (inarray) result(outarray) Arguments Type Intent Optional Attributes Name real, intent(in) :: inarray Return Value real Subroutines public subroutine utility_print_values_by_link (elem2R, elem2I, elemMR, elemMI, faceR, faceI, ilink, fcolDn, fcolUp, e2col, eMcolC, eMcolDn, eMcolUp) Arguments Type Intent Optional Attributes Name real, intent(in) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) real, intent(in) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) real, intent(in) :: faceR (:,:) integer, intent(in) :: faceI (:,:) integer, intent(in) :: ilink integer, intent(in) :: fcolDn integer, intent(in) :: fcolUp integer, intent(in) :: e2col integer, intent(in) :: eMcolC integer, intent(in) :: eMcolDn (:) integer, intent(in) :: eMcolUp (:) public subroutine utility_check_fileopen (open_status, emsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: open_status character(len=*), intent(in) :: emsg public subroutine utility_check_allocation (allocation_status, emsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: allocation_status character(len=*), intent(in) :: emsg public subroutine utility_get_datetime_stamp (datetimestamp) Arguments Type Intent Optional Attributes Name character(len=14), intent(out) :: datetimestamp","title":"utility – SWMMengine","tags":"","loc":"module/utility.html"},{"text":"Uses allocate_storage array_index bc data_keys globals setting_definition module~~case_y_channel~~UsesGraph module~case_y_channel case_y_channel module~globals globals module~case_y_channel->module~globals module~array_index array_index module~case_y_channel->module~array_index module~allocate_storage allocate_storage module~case_y_channel->module~allocate_storage module~setting_definition setting_definition module~case_y_channel->module~setting_definition module~bc bc module~case_y_channel->module~bc module~data_keys data_keys module~case_y_channel->module~data_keys module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~array_index->module~globals module~allocate_storage->module~globals module~allocate_storage->module~array_index module~utility utility module~allocate_storage->module~utility module~setting_definition->module~type_definitions module~bc->module~globals module~bc->module~array_index module~bc->module~setting_definition module~bc->module~data_keys module~bc->module~utility module~bc->module~type_definitions module~data_keys->module~globals module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~utility->module~data_keys var panmodulecase_y_channelUsesGraph = svgPanZoom('#modulecase_y_channelUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~case_y_channel~~UsedByGraph module~case_y_channel case_y_channel module~test_cases test_cases module~test_cases->module~case_y_channel program~main main program~main->module~test_cases Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines case_y_channel_initialize case_y_channel_links_and_nodes Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 1 Subroutines public subroutine case_y_channel_initialize (channel_length, channel_breadth, subdivide_length, lowerZ, upperZ, initial_flowrate, depth_upstream, depth_dnstream, ManningsN, roughness_type, idepth_type, linkR, nodeR, linkI, nodeI, linkYN, nodeYN, linkName, nodeName, bcdataDn, bcdataUp) Arguments Type Intent Optional Attributes Name real, intent(in) :: channel_length (:) real, intent(in) :: channel_breadth (:) real, intent(in) :: subdivide_length (:) real, intent(in) :: lowerZ (:) real, intent(in) :: upperZ (:) real, intent(in) :: initial_flowrate (:) real, intent(in) :: depth_upstream (:) real, intent(in) :: depth_dnstream (:) real, intent(in) :: ManningsN (:) integer, intent(in) :: roughness_type integer, intent(in) :: idepth_type (:) real, intent(out), dimension(:,:), allocatable, target :: linkR real, intent(out), dimension(:,:), allocatable, target :: nodeR integer, intent(out), dimension(:,:), allocatable, target :: linkI integer, intent(out), dimension(:,:), allocatable, target :: nodeI logical, intent(out), dimension(:,:), allocatable, target :: linkYN logical, intent(out), dimension(:,:), allocatable, target :: nodeYN type(string), intent(out), dimension(:), allocatable, target :: linkName type(string), intent(out), dimension(:), allocatable, target :: nodeName type(bcType), intent(out), dimension(:), allocatable :: bcdataDn type(bcType), intent(out), dimension(:), allocatable :: bcdataUp private subroutine case_y_channel_links_and_nodes (channel_length, channel_breadth, subdivide_length, lowerZ, upperZ, initial_flowrate, depth_upstream, depth_dnstream, ManningsN, roughness_type, idepth_type, linkR, nodeR, linkI, nodeI, linkYN, nodeYN, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(in) :: channel_length (:) real, intent(in) :: channel_breadth (:) real, intent(in) :: subdivide_length (:) real, intent(in) :: lowerZ (:) real, intent(in) :: upperZ (:) real, intent(in) :: initial_flowrate (:) real, intent(in) :: depth_upstream (:) real, intent(in) :: depth_dnstream (:) real, intent(in) :: ManningsN (:) integer, intent(in) :: roughness_type integer, intent(in) :: idepth_type (:) real, intent(out), dimension(:,:), allocatable, target :: linkR real, intent(out), dimension(:,:), allocatable, target :: nodeR integer, intent(out), dimension(:,:), allocatable, target :: linkI integer, intent(out), dimension(:,:), allocatable, target :: nodeI logical, intent(out), dimension(:,:), allocatable, target :: linkYN logical, intent(out), dimension(:,:), allocatable, target :: nodeYN type(string), intent(out), dimension(:), allocatable, target :: linkName type(string), intent(out), dimension(:), allocatable, target :: nodeName","title":"case_y_channel – SWMMengine","tags":"","loc":"module/case_y_channel.html"},{"text":"Uses array_index bc data_keys globals setting_definition utility module~~output~~UsesGraph module~output output module~globals globals module~output->module~globals module~utility utility module~output->module~utility module~array_index array_index module~output->module~array_index module~setting_definition setting_definition module~output->module~setting_definition module~bc bc module~output->module~bc module~data_keys data_keys module~output->module~data_keys module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~utility->module~data_keys module~array_index->module~globals module~setting_definition->module~type_definitions module~bc->module~globals module~bc->module~utility module~bc->module~array_index module~bc->module~setting_definition module~bc->module~data_keys module~bc->module~type_definitions module~data_keys->module~globals var panmoduleoutputUsesGraph = svgPanZoom('#moduleoutputUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~output~~UsedByGraph module~output output program~main main program~main->module~output module~time_loop time_loop program~main->module~time_loop module~time_loop->module~output Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines output_threaded_by_link_initialize output_all_threaded_data_by_link output_one_threaded_data_by_link output_singlethreadedfile_open Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Subroutines public subroutine output_threaded_by_link_initialize (threadedfile) Arguments Type Intent Optional Attributes Name type(threadedfileType), intent(out), dimension(:), allocatable :: threadedfile public subroutine output_all_threaded_data_by_link (threadedfile, elem2R, elem2I, elemMR, elemMI, faceR, faceI, linkI, bcdataUp, bcdataDn, thisstep) Arguments Type Intent Optional Attributes Name type(threadedfileType), intent(in) :: threadedfile (:) real, intent(in), target :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) real, intent(in), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in), target :: faceI (:,:) integer, intent(in), target :: linkI (:,:) type(bcType), intent(in) :: bcdataUp (:) type(bcType), intent(in) :: bcdataDn (:) integer, intent(in) :: thisstep public subroutine output_one_threaded_data_by_link (outdataName, thisUnit, thisstep, elem2R, elem2I, elemMR, elemMI, faceR, faceI, linkI, bcdataUp, bcdataDn, itemp) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: outdataName integer, intent(in) :: thisUnit integer, intent(in) :: thisstep real, intent(in), target :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) real, intent(in), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in), target :: faceI (:,:) integer, intent(in), target :: linkI (:,:) type(bcType), intent(in) :: bcdataUp (:) type(bcType), intent(in) :: bcdataDn (:) integer, intent(in) :: itemp private subroutine output_singlethreadedfile_open (threadedfile) Arguments Type Intent Optional Attributes Name type(threadedfileType), intent(inout) :: threadedfile","title":"output – SWMMengine","tags":"","loc":"module/output.html"},{"text":"Uses allocate_storage array_index initialization data_keys globals junction module~~network_define~~UsesGraph module~network_define network_define module~globals globals module~network_define->module~globals module~initialization initialization module~network_define->module~initialization module~junction junction module~network_define->module~junction module~array_index array_index module~network_define->module~array_index module~allocate_storage allocate_storage module~network_define->module~allocate_storage module~data_keys data_keys module~network_define->module~data_keys module~setting_definition setting_definition module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~initialization->module~globals module~initialization->module~array_index module~initialization->module~data_keys module~junction->module~globals module~junction->module~array_index module~junction->module~data_keys module~junction->module~setting_definition module~utility utility module~junction->module~utility module~array_index->module~globals module~allocate_storage->module~globals module~allocate_storage->module~array_index module~allocate_storage->module~utility module~data_keys->module~globals module~setting_definition->module~type_definitions module~utility->module~globals module~utility->module~array_index module~utility->module~data_keys module~utility->module~setting_definition var panmodulenetwork_defineUsesGraph = svgPanZoom('#modulenetwork_defineUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~network_define~~UsedByGraph module~network_define network_define program~main main program~main->module~network_define Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Functions setAssigned setFaceType Subroutines network_initiation network_node_assignment network_check_node_link_match network_check_BC network_get_link_slope network_adjust_link_length network_count_elements_and_faces network_data_create handle_thisnode subdivide_link_going_upstream link_shortening Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Functions private function setAssigned (thisX, assigned_idx, unassignedValue, assignedValue, arrayI) result(f_result) Arguments Type Intent Optional Attributes Name integer, intent(in) :: thisX integer, intent(in) :: assigned_idx integer, intent(in) :: unassignedValue integer, intent(in) :: assignedValue integer, intent(in) :: arrayI (:,:) Return Value integer private function setFaceType (up_elem_type, dn_elem_type) result(f_result) Arguments Type Intent Optional Attributes Name integer, intent(in) :: up_elem_type integer, intent(in) :: dn_elem_type Return Value integer Subroutines public subroutine network_initiation (linkI, linkR, linkYN, linkName, nodeI, nodeR, nodeYN, nodeName, elem2R, elem2I, elem2YN, elem2Name, elemMR, elemMI, elemMYN, elemMName, faceR, faceI, faceYN, faceName) Arguments Type Intent Optional Attributes Name integer, intent(inout), target :: linkI (:,:) real, intent(inout) :: linkR (:,:) logical, intent(inout) :: linkYN (:,:) type(string), intent(inout) :: linkName (:) integer, intent(inout), target :: nodeI (:,:) real, intent(inout), target :: nodeR (:,:) logical, intent(out) :: nodeYN (:,:) type(string), intent(inout) :: nodeName (:) real, dimension(:,:), allocatable, target :: elem2R integer, dimension(:,:), allocatable, target :: elem2I logical, dimension(:,:), allocatable, target :: elem2YN type(string), dimension(:), allocatable, target :: elem2Name real, dimension(:,:), allocatable, target :: elemMR integer, dimension(:,:), allocatable, target :: elemMI logical, dimension(:,:), allocatable, target :: elemMYN type(string), dimension(:), allocatable, target :: elemMName real, dimension(:,:), allocatable, target :: faceR integer, dimension(:,:), allocatable, target :: faceI logical, dimension(:,:), allocatable, target :: faceYN type(string), dimension(:), allocatable, target :: faceName private subroutine network_node_assignment (nodeI, linkI) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: nodeI (:,:) integer, intent(in) :: linkI (:,:) private subroutine network_check_node_link_match (linkI, nodeI) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: linkI (:,:) integer, intent(in) :: nodeI (:,:) private subroutine network_check_BC (nodeI, N_node) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodeI (:,:) integer, intent(in) :: N_node private subroutine network_get_link_slope (linkR, nodeR, linkI, nodeI) Arguments Type Intent Optional Attributes Name real, intent(inout) :: linkR (:,:) real, intent(in), target :: nodeR (:,:) integer, intent(in), target :: linkI (:,:) integer, intent(in), target :: nodeI (:,:) private subroutine network_adjust_link_length (linkR, nodeR, linkI, nodeI) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: linkR (:,:) real, intent(inout), target :: nodeR (:,:) integer, intent(inout), target :: linkI (:,:) integer, intent(in) :: nodeI (:,:) private subroutine network_count_elements_and_faces (nodeR, linkI, nodeI) Arguments Type Intent Optional Attributes Name real, intent(in) :: nodeR (:,:) integer, intent(in) :: linkI (:,:) integer, intent(in) :: nodeI (:,:) private subroutine network_data_create (elem2R, elemMR, faceR, linkR, nodeR, elem2I, elemMI, faceI, linkI, nodeI, nodeYN, elem2Name, elemMName, faceName, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) real, intent(inout) :: elemMR (:,:) real, intent(inout) :: faceR (:,:) real, intent(in), target :: linkR (:,:) real, intent(in), target :: nodeR (:,:) integer, intent(inout) :: elem2I (:,:) integer, intent(inout) :: elemMI (:,:) integer, intent(inout) :: faceI (:,:) integer, intent(inout) :: linkI (:,:) integer, intent(inout), target :: nodeI (:,:) logical, intent(in), target :: nodeYN (:,:) type(string), intent(inout) :: elem2Name (:) type(string), intent(inout) :: elemMName (:) type(string), intent(inout) :: faceName (:) type(string), intent(in) :: linkName (:) type(string), intent(in) :: nodeName (:) private recursive subroutine handle_thisnode (lastElem2, thisElem2, lastElemM, thisElemM, lastFace, thisFace, thisNode, thisLink, elem2I, elemMI, faceI, linkI, nodeI, elem2R, elemMR, faceR, linkR, nodeR, elem2Name, elemMName, faceName, linkName, nodeName) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: lastElem2 integer, intent(inout) :: thisElem2 integer, intent(inout) :: lastElemM integer, intent(inout) :: thisElemM integer, intent(inout) :: lastFace integer, intent(inout) :: thisFace integer, intent(inout) :: thisNode integer, intent(inout) :: thisLink integer, intent(inout) :: elem2I (:,:) integer, intent(inout) :: elemMI (:,:) integer, intent(inout) :: faceI (:,:) integer, intent(inout) :: linkI (:,:) integer, intent(inout), target :: nodeI (:,:) real, intent(inout) :: elem2R (:,:) real, intent(inout) :: elemMR (:,:) real, intent(inout) :: faceR (:,:) real, intent(in), target :: linkR (:,:) real, intent(in), target :: nodeR (:,:) type(string), intent(inout) :: elem2Name (:) type(string), intent(inout) :: elemMName (:) type(string), intent(inout) :: faceName (:) type(string), intent(in) :: linkName (:) type(string), intent(in) :: nodeName (:) private subroutine subdivide_link_going_upstream (lastElem2, thisElem2, lastFace, thisFace, thisLink, elem2I, faceI, linkI, elem2R, faceR, linkR, nodeR, zDownstream) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: lastElem2 integer, intent(inout) :: thisElem2 integer, intent(inout) :: lastFace integer, intent(inout) :: thisFace integer, intent(in) :: thisLink integer, intent(inout) :: elem2I (:,:) integer, intent(inout) :: faceI (:,:) integer, intent(inout) :: linkI (:,:) real, intent(inout) :: elem2R (:,:) real, intent(inout) :: faceR (:,:) real, intent(in) :: linkR (:,:) real, intent(in) :: nodeR (:,:) real, intent(in) :: zDownstream private subroutine link_shortening (linkLength, nodeR, nodeI, thisNode, niNlinkX, niMlinkX, nrElementLengthX, element_nominal_length) Arguments Type Intent Optional Attributes Name real, intent(inout) :: linkLength (:) real, intent(inout), target :: nodeR (:,:) integer, intent(in), target :: nodeI (:,:) integer, intent(in) :: thisNode integer, intent(in) :: niNlinkX integer, intent(in) :: niMlinkX (:) integer, intent(in) :: nrElementLengthX (:) real, intent(in) :: element_nominal_length (:)","title":"network_define – SWMMengine","tags":"","loc":"module/network_define.html"},{"text":"Uses array_index globals utility module~~allocate_storage~~UsesGraph module~allocate_storage allocate_storage module~globals globals module~allocate_storage->module~globals module~utility utility module~allocate_storage->module~utility module~array_index array_index module~allocate_storage->module~array_index module~setting_definition setting_definition module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~data_keys data_keys module~utility->module~data_keys module~array_index->module~globals module~setting_definition->module~type_definitions module~data_keys->module~globals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~allocate_storage~~UsedByGraph module~allocate_storage allocate_storage module~case_simple_channel case_simple_channel module~case_simple_channel->module~allocate_storage module~case_y_channel case_y_channel module~case_y_channel->module~allocate_storage program~main main program~main->module~allocate_storage module~network_define network_define program~main->module~network_define module~test_cases test_cases program~main->module~test_cases module~network_define->module~allocate_storage module~test_cases->module~case_simple_channel module~test_cases->module~case_y_channel Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables allocation_status emsg debuglevel Subroutines allocate_linknode_storage allocate_data_storage Variables Type Visibility Attributes Name Initial integer, private :: allocation_status character(len=99), private :: emsg integer, private :: debuglevel = 0 Subroutines public subroutine allocate_linknode_storage (linkR, nodeR, linkI, nodeI, linkYN, nodeYN, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:,:), allocatable, target :: linkR real, intent(out), dimension(:,:), allocatable, target :: nodeR integer, intent(out), dimension(:,:), allocatable, target :: linkI integer, intent(out), dimension(:,:), allocatable, target :: nodeI logical, intent(out), dimension(:,:), allocatable, target :: linkYN logical, intent(out), dimension(:,:), allocatable, target :: nodeYN type(string), intent(out), dimension(:), allocatable, target :: linkName type(string), intent(out), dimension(:), allocatable, target :: nodeName public subroutine allocate_data_storage (elem2R, elemMR, faceR, elem2I, elemMI, faceI, elem2YN, elemMYN, faceYN, elem2Name, elemMName, faceName) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:,:), allocatable, target :: elem2R real, intent(out), dimension(:,:), allocatable, target :: elemMR real, intent(out), dimension(:,:), allocatable, target :: faceR integer, intent(out), dimension(:,:), allocatable, target :: elem2I integer, intent(out), dimension(:,:), allocatable, target :: elemMI integer, intent(out), dimension(:,:), allocatable, target :: faceI logical, intent(out), dimension(:,:), allocatable, target :: elem2YN logical, intent(out), dimension(:,:), allocatable, target :: elemMYN logical, intent(out), dimension(:,:), allocatable, target :: faceYN type(string), intent(out), dimension(:), allocatable, target :: elem2Name type(string), intent(out), dimension(:), allocatable, target :: elemMName type(string), intent(out), dimension(:), allocatable, target :: faceName","title":"allocate_storage – SWMMengine","tags":"","loc":"module/allocate_storage.html"},{"text":"Uses adjustments array_index bc data_keys element_dynamics element_geometry face_values globals setting_definition utility module~~explicit_euler~~UsesGraph module~explicit_euler explicit_euler module~globals globals module~explicit_euler->module~globals module~utility utility module~explicit_euler->module~utility module~array_index array_index module~explicit_euler->module~array_index module~element_dynamics element_dynamics module~explicit_euler->module~element_dynamics module~element_geometry element_geometry module~explicit_euler->module~element_geometry module~adjustments adjustments module~explicit_euler->module~adjustments module~face_values face_values module~explicit_euler->module~face_values module~setting_definition setting_definition module~explicit_euler->module~setting_definition module~bc bc module~explicit_euler->module~bc module~data_keys data_keys module~explicit_euler->module~data_keys module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~utility->module~data_keys module~array_index->module~globals module~element_dynamics->module~globals module~element_dynamics->module~utility module~element_dynamics->module~array_index module~element_dynamics->module~adjustments module~element_dynamics->module~setting_definition module~element_dynamics->module~bc module~element_dynamics->module~data_keys module~junction junction module~element_dynamics->module~junction module~element_geometry->module~globals module~element_geometry->module~utility module~element_geometry->module~array_index module~element_geometry->module~adjustments module~element_geometry->module~setting_definition module~element_geometry->module~bc module~element_geometry->module~data_keys module~element_geometry->module~junction module~adjustments->module~globals module~adjustments->module~utility module~adjustments->module~array_index module~adjustments->module~setting_definition module~adjustments->module~data_keys module~face_values->module~globals module~face_values->module~utility module~face_values->module~array_index module~face_values->module~adjustments module~face_values->module~setting_definition module~face_values->module~bc module~face_values->module~data_keys module~setting_definition->module~type_definitions module~bc->module~globals module~bc->module~utility module~bc->module~array_index module~bc->module~setting_definition module~bc->module~data_keys module~bc->module~type_definitions module~data_keys->module~globals module~junction->module~globals module~junction->module~utility module~junction->module~array_index module~junction->module~setting_definition module~junction->module~data_keys var panmoduleexplicit_eulerUsesGraph = svgPanZoom('#moduleexplicit_eulerUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~explicit_euler~~UsedByGraph module~explicit_euler explicit_euler module~time_loop time_loop module~time_loop->module~explicit_euler program~main main program~main->module~time_loop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables idummy debuglevel Subroutines explicit_test_advance test_face_update quadratic_face_update explicit_euler_advance Variables Type Visibility Attributes Name Initial integer, private, parameter :: idummy = 0 integer, private :: debuglevel = 0 Subroutines public subroutine explicit_test_advance (elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, faceI, faceYN, bcdataDn, bcdataUp, thistime, dt) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(inout), target :: elem2I (:,:) logical, intent(inout), target :: elem2YN (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(inout), target :: elemMI (:,:) logical, intent(inout), target :: elemMYN (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(inout), target :: faceI (:,:) logical, intent(inout), target :: faceYN (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) real, intent(in) :: thistime real, intent(in) :: dt private subroutine test_face_update (elem2R, elem2I, faceR, faceI, elemUp2) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(inout), target :: elem2I (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(inout), target :: faceI (:,:) integer, intent(inout) :: elemUp2 (:) private subroutine quadratic_face_update (elem2R, elem2I, faceR, faceI, elemUp2) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(inout), target :: elem2I (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(inout), target :: faceI (:,:) integer, intent(inout) :: elemUp2 (:) public subroutine explicit_euler_advance (elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, faceI, faceYN, bcdataDn, bcdataUp, thistime, dt) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(inout), target :: elem2I (:,:) logical, intent(inout), target :: elem2YN (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(inout), target :: elemMI (:,:) logical, intent(inout), target :: elemMYN (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(inout), target :: faceI (:,:) logical, intent(inout), target :: faceYN (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) real, intent(in) :: thistime real, intent(in) :: dt","title":"explicit_euler – SWMMengine","tags":"","loc":"module/explicit_euler.html"},{"text":"Uses array_index data_keys globals setting_definition utility module~~junction~~UsesGraph module~junction junction module~array_index array_index module~junction->module~array_index module~globals globals module~junction->module~globals module~utility utility module~junction->module~utility module~data_keys data_keys module~junction->module~data_keys module~setting_definition setting_definition module~junction->module~setting_definition module~array_index->module~globals module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~utility->module~array_index module~utility->module~globals module~utility->module~data_keys module~utility->module~setting_definition module~data_keys->module~globals module~setting_definition->module~type_definitions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~junction~~UsedByGraph module~junction junction module~element_dynamics element_dynamics module~element_dynamics->module~junction module~initial_condition initial_condition module~initial_condition->module~junction module~initial_condition->module~element_dynamics module~element_geometry element_geometry module~initial_condition->module~element_geometry program~main main program~main->module~junction program~main->module~initial_condition module~network_define network_define program~main->module~network_define module~time_loop time_loop program~main->module~time_loop module~element_geometry->module~junction module~network_define->module~junction module~explicit_euler explicit_euler module~explicit_euler->module~element_dynamics module~explicit_euler->module~element_geometry module~runge_kutta runge_kutta module~runge_kutta->module~element_dynamics module~runge_kutta->module~element_geometry module~time_loop->module~explicit_euler module~time_loop->module~runge_kutta Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines junction_adjacent_element_average junction_adjacent_element_values_to_branches junction_branch_assigned_to_faces junction_branch_average_of_inflows_and_outflows junction_branch_velocity_and_flowrate_proportional_to_area junction_branch_sum_areas_by_direction junction_branch_velocities junction_geometry_setup junction_adjacent_element_values_one_direction junction_branch_average junction_branch_average_for_directions_then_sum junction_branch_summation junction_branch_summation_and_updown_average junction_branch_summation_one_direction junction_branch_velocities_one_direction junction_net_flow_in_or_out junction_net_inflow_and_outflow junction_summation_from_adjacent_elements_one_direction Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Subroutines public subroutine junction_adjacent_element_average (elem2R, elemMR, elemMI, faceI, e2r_data, eMr_out) Arguments Type Intent Optional Attributes Name real, intent(in) :: elem2R (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: faceI (:,:) integer, intent(in) :: e2r_data integer, intent(in) :: eMr_out public subroutine junction_adjacent_element_values_to_branches (elem2R, elemMR, elemMI, faceI, e2r_data, eMr_outUp, eMr_outDn) Arguments Type Intent Optional Attributes Name real, intent(in) :: elem2R (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: faceI (:,:) integer, intent(in) :: e2r_data integer, intent(in) :: eMr_outUp (:) integer, intent(in) :: eMr_outDn (:) public subroutine junction_branch_assigned_to_faces (faceI, elemMI) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: faceI (:,:) integer, intent(in) :: elemMI (:,:) public subroutine junction_branch_average_of_inflows_and_outflows (elemMR, elemMI) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) public subroutine junction_branch_velocity_and_flowrate_proportional_to_area (eMR_totalarea, eMR_totalflowrate, this_face_per_elem, eMr_AreaThis, eMi_MfaceThis, eMi_nfaces_This, eMr_FlowrateThis, eMr_VelocityThis, rdir_face_per_elem, eMr_AreaRdir, eMi_MfaceRdir, eMi_nfaces_Rdir, eMr_FlowrateRdir, eMr_VelocityRdir, elemMR, elemMI, faceR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMR_totalarea integer, intent(in) :: eMR_totalflowrate integer, intent(in) :: this_face_per_elem integer, intent(in) :: eMr_AreaThis (:) integer, intent(in) :: eMi_MfaceThis (:) integer, intent(in) :: eMi_nfaces_This integer, intent(in) :: eMr_FlowrateThis (:) integer, intent(in) :: eMr_VelocityThis (:) integer, intent(in) :: rdir_face_per_elem integer, intent(in) :: eMr_AreaRdir (:) integer, intent(in) :: eMi_MfaceRdir (:) integer, intent(in) :: eMi_nfaces_Rdir integer, intent(in) :: eMr_FlowrateRdir (:) integer, intent(in) :: eMr_VelocityRdir (:) real, intent(inout), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(in) :: faceR (:,:) public subroutine junction_branch_sum_areas_by_direction (eMR_totalarea, this_face_per_element, eMr_AreaThis, eMi_MfaceThis, eMi_nfaces_This, rdir_face_per_element, eMr_AreaRdir, eMi_MfaceRdir, eMi_nfaces_Rdir, elemMR, elemMI, faceR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMR_totalarea integer, intent(in) :: this_face_per_element integer, intent(in) :: eMr_AreaThis (:) integer, intent(in) :: eMi_MfaceThis (:) integer, intent(in) :: eMi_nfaces_This integer, intent(in) :: rdir_face_per_element integer, intent(in) :: eMr_AreaRdir (:) integer, intent(in) :: eMi_MfaceRdir (:) integer, intent(in) :: eMi_nfaces_Rdir real, intent(inout), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(in) :: faceR (:,:) public subroutine junction_branch_velocities (elemMR, elemMI) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) public subroutine junction_geometry_setup (elemMR, elemMI) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) private subroutine junction_adjacent_element_values_one_direction (elem2R, elemMR, elemMI, faceI, dir_face_per_elemM, eMi_nfaces_dir, eMi_MfaceDir, fi_Melem_dir, e2r_data, eMr_outDir) Arguments Type Intent Optional Attributes Name real, intent(in) :: elem2R (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) integer, intent(in), target :: faceI (:,:) integer, intent(in) :: dir_face_per_elemM integer, intent(in) :: eMi_nfaces_dir integer, intent(in) :: eMi_MfaceDir (:) integer, intent(in) :: fi_Melem_dir integer, intent(in) :: e2r_data integer, intent(in) :: eMr_outDir (:) private subroutine junction_branch_average (eMr_avgvalue, elemMR, elemMI, eMr_column_up, eMr_column_dn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMr_avgvalue real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: eMr_column_up (:) integer, intent(in) :: eMr_column_dn (:) private subroutine junction_branch_average_for_directions_then_sum (elemMR, elemMI, eMr_columnUp, eMr_columnDn, eMr_out) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: eMr_columnUp (:) integer, intent(in) :: eMr_columnDn (:) integer, intent(in) :: eMr_out private subroutine junction_branch_summation (eMr_sumvalue, elemMR, elemMI, eMr_column_up, eMr_column_dn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMr_sumvalue real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: eMr_column_up (:) integer, intent(in) :: eMr_column_dn (:) private subroutine junction_branch_summation_and_updown_average (elemMR, elemMI, eMr_columnUp, eMr_columnDn, eMr_out) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: eMr_columnUp (:) integer, intent(in) :: eMr_columnDn (:) integer, intent(in) :: eMr_out private subroutine junction_branch_summation_one_direction (eMr_sumvalue, elemMR, elemMI, face_per_elemM, eMi_nfaces_dir, eMr_columnDir) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMr_sumvalue real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: face_per_elemM integer, intent(in) :: eMi_nfaces_dir integer, intent(in) :: eMr_columnDir (:) private subroutine junction_branch_velocities_one_direction (elemMR, elemMI, dir_face_per_elemM, eMi_nfaces_dir, eMr_FlowrateDir, eMr_AreaDir, eMr_VelocityDir) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: dir_face_per_elemM integer, intent(in) :: eMi_nfaces_dir integer, intent(in) :: eMr_FlowrateDir (:) integer, intent(in) :: eMr_AreaDir (:) integer, intent(in) :: eMr_VelocityDir (:) private subroutine junction_net_flow_in_or_out (eMr_flow, elemMR, elemMI, dir_face_per_elemM, eMi_nfaces_dir, eMr_FlowrateDir1, eMr_flowrateDir2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMr_flow real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: dir_face_per_elemM integer, intent(in) :: eMi_nfaces_dir integer, intent(in) :: eMr_FlowrateDir1 (:) integer, intent(in) :: eMr_flowrateDir2 (:) private subroutine junction_net_inflow_and_outflow (eMr_inflow, eMr_outflow, elemMR, elemMI) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMr_inflow integer, intent(in) :: eMr_outflow real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) private subroutine junction_summation_from_adjacent_elements_one_direction (eMr_sumvalue, elem2R, elemMR, elemMI, faceI, dir_face_per_elemM, eMi_nfaces_dir, eMi_MfaceDir, fi_Melem_dir, e2r_data) Arguments Type Intent Optional Attributes Name integer, intent(in) :: eMr_sumvalue real, intent(in) :: elem2R (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) integer, intent(in), target :: faceI (:,:) integer, intent(in) :: dir_face_per_elemM integer, intent(in) :: eMi_nfaces_dir integer, intent(in) :: eMi_MfaceDir (:) integer, intent(in) :: fi_Melem_dir integer, intent(in) :: e2r_data","title":"junction – SWMMengine","tags":"","loc":"module/junction.html"},{"text":"Uses array_index data_keys globals module~~initialization~~UsesGraph module~initialization initialization module~globals globals module~initialization->module~globals module~data_keys data_keys module~initialization->module~data_keys module~array_index array_index module~initialization->module~array_index module~setting_definition setting_definition module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~data_keys->module~globals module~array_index->module~globals module~setting_definition->module~type_definitions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~initialization~~UsedByGraph module~initialization initialization program~main main program~main->module~initialization module~network_define network_define program~main->module~network_define module~network_define->module~initialization Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines initialize_arrayindex initialize_arrayindex_status initialize_array_zerovalues initialize_dummy_values Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Subroutines public subroutine initialize_arrayindex () Arguments None public subroutine initialize_arrayindex_status () Arguments None public subroutine initialize_array_zerovalues (elemMR) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elemMR (:,:) public subroutine initialize_dummy_values (elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, faceI, faceYN) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(inout) :: elem2I (:,:) logical, intent(inout) :: elem2YN (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(inout) :: elemMI (:,:) logical, intent(inout) :: elemMYN (:,:) real, intent(inout) :: faceR (:,:) integer, intent(inout) :: faceI (:,:) logical, intent(inout) :: faceYN (:,:)","title":"initialization – SWMMengine","tags":"","loc":"module/initialization.html"},{"text":"Uses array_index bc data_keys globals setting_definition type_definitions utility module~~diagnostic~~UsesGraph module~diagnostic diagnostic module~globals globals module~diagnostic->module~globals module~utility utility module~diagnostic->module~utility module~array_index array_index module~diagnostic->module~array_index module~type_definitions type_definitions module~diagnostic->module~type_definitions module~setting_definition setting_definition module~diagnostic->module~setting_definition module~bc bc module~diagnostic->module~bc module~data_keys data_keys module~diagnostic->module~data_keys module~globals->module~type_definitions module~globals->module~setting_definition module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~utility->module~data_keys module~array_index->module~globals module~setting_definition->module~type_definitions module~bc->module~globals module~bc->module~utility module~bc->module~array_index module~bc->module~type_definitions module~bc->module~setting_definition module~bc->module~data_keys module~data_keys->module~globals var panmodulediagnosticUsesGraph = svgPanZoom('#modulediagnosticUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~diagnostic~~UsedByGraph module~diagnostic diagnostic program~main main program~main->module~diagnostic module~time_loop time_loop program~main->module~time_loop module~runge_kutta runge_kutta module~runge_kutta->module~diagnostic module~time_loop->module~diagnostic module~time_loop->module~runge_kutta Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Functions diagnostic_CFL Subroutines diagnostic_element_volume_conservation_fluxes diagnostic_element_volume_conservation diagnostic_froude_number diagnostic_initialize diagnostic_volume_conservation diagnostic_froude_number_one total_inout_flowrate inout_flowrate_from_bcdata Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Functions public pure function diagnostic_CFL (elemR, er_Timescale_u, er_Timescale_d) result(cflmax) Arguments Type Intent Optional Attributes Name real, intent(in) :: elemR (:,:) integer, intent(in) :: er_Timescale_u integer, intent(in) :: er_Timescale_d Return Value real Subroutines public subroutine diagnostic_element_volume_conservation_fluxes (elem2R, elem2I, elemMR, elemMI, faceR) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(in) :: faceR (:,:) public subroutine diagnostic_element_volume_conservation (elem2R, elem2I, elemMR, elemMI, e2r_Volume_new, eMr_Volume_new) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: e2r_Volume_new integer, intent(in) :: eMr_Volume_new public subroutine diagnostic_froude_number (elem2R, elem2I, elemMR, elemMI) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) public subroutine diagnostic_initialize (diagnostic, elem2R, elem2I, elemMR, elemMI, faceR, bcdataUp, bcdataDn) Arguments Type Intent Optional Attributes Name type(diagnosticType), intent(out), allocatable, dimension(:) :: diagnostic real, intent(inout) :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(inout) :: faceR (:,:) type(bcType), intent(in) :: bcdataUp (:) type(bcType), intent(in) :: bcdataDn (:) public subroutine diagnostic_volume_conservation (diagnostic, elem2R, elem2I, elemMR, elemMI, faceR, bcdataUp, bcdataDn, thisStep, diagnosticTask) Arguments Type Intent Optional Attributes Name type(diagnosticType), intent(inout) :: diagnostic (:) real, intent(inout) :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(inout) :: faceR (:,:) type(bcType), intent(in) :: bcdataUp (:) type(bcType), intent(in) :: bcdataDn (:) integer, intent(in) :: thisStep integer, intent(in) :: diagnosticTask private subroutine diagnostic_froude_number_one (elemR, elemI, er_FroudeNumber, er_Velocity, er_HydDepth, ei_elem_type, thisType) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elemR (:,:) integer, intent(in) :: elemI (:,:) integer, intent(in) :: er_FroudeNumber integer, intent(in) :: er_Velocity integer, intent(in) :: er_HydDepth integer, intent(in) :: ei_elem_type integer, intent(in) :: thisType private subroutine total_inout_flowrate (inflowRate, outflowRate, faceR, bcdataUp, bcdataDn) Arguments Type Intent Optional Attributes Name real, intent(out) :: inflowRate real, intent(out) :: outflowRate real, intent(in), target :: faceR (:,:) type(bcType), intent(in), target :: bcdataUp (:) type(bcType), intent(in), target :: bcdataDn (:) private subroutine inout_flowrate_from_bcdata (inflowRate, outflowRate, faceR, bcdata) Arguments Type Intent Optional Attributes Name real, intent(inout) :: inflowRate real, intent(inout) :: outflowRate real, intent(in), target :: faceR (:,:) type(bcType), intent(in), target :: bcdata (:)","title":"diagnostic – SWMMengine","tags":"","loc":"module/diagnostic.html"},{"text":"Uses array_index data_keys globals setting_definition module~~friction_model~~UsesGraph module~friction_model friction_model module~array_index array_index module~friction_model->module~array_index module~globals globals module~friction_model->module~globals module~data_keys data_keys module~friction_model->module~data_keys module~setting_definition setting_definition module~friction_model->module~setting_definition module~array_index->module~globals module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~data_keys->module~globals module~setting_definition->module~type_definitions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines friction_on_element Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Subroutines public subroutine friction_on_element (elemR, elemI, er_Friction, er_Velocity, er_Volume, er_Roughness, er_HydRadius, ei_elem_type, ei_roughness_type, ThisElemType) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) integer, intent(in) :: elemI (:,:) integer, intent(in) :: er_Friction integer, intent(in) :: er_Velocity integer, intent(in) :: er_Volume integer, intent(in) :: er_Roughness integer, intent(in) :: er_HydRadius integer, intent(in) :: ei_elem_type integer, intent(in) :: ei_roughness_type integer, intent(in) :: ThisElemType","title":"friction_model – SWMMengine","tags":"","loc":"module/friction_model.html"},{"text":"Uses array_index bc case_simple_channel case_y_channel data_keys globals setting_definition utility module~~test_cases~~UsesGraph module~test_cases test_cases module~globals globals module~test_cases->module~globals module~utility utility module~test_cases->module~utility module~array_index array_index module~test_cases->module~array_index module~case_simple_channel case_simple_channel module~test_cases->module~case_simple_channel module~setting_definition setting_definition module~test_cases->module~setting_definition module~case_y_channel case_y_channel module~test_cases->module~case_y_channel module~bc bc module~test_cases->module~bc module~data_keys data_keys module~test_cases->module~data_keys module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~utility->module~data_keys module~array_index->module~globals module~case_simple_channel->module~globals module~case_simple_channel->module~array_index module~case_simple_channel->module~setting_definition module~case_simple_channel->module~bc module~case_simple_channel->module~data_keys module~allocate_storage allocate_storage module~case_simple_channel->module~allocate_storage module~setting_definition->module~type_definitions module~case_y_channel->module~globals module~case_y_channel->module~array_index module~case_y_channel->module~setting_definition module~case_y_channel->module~bc module~case_y_channel->module~data_keys module~case_y_channel->module~allocate_storage module~bc->module~globals module~bc->module~utility module~bc->module~array_index module~bc->module~setting_definition module~bc->module~data_keys module~bc->module~type_definitions module~data_keys->module~globals module~allocate_storage->module~globals module~allocate_storage->module~utility module~allocate_storage->module~array_index var panmoduletest_casesUsesGraph = svgPanZoom('#moduletest_casesUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~test_cases~~UsedByGraph module~test_cases test_cases program~main main program~main->module~test_cases Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Functions get_dt_from_CFL Subroutines test_case_initiation control_variable_allocation this_setting_for_time_and_steps froude_driven_setup write_testcase_setup_file Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Functions private elemental function get_dt_from_CFL (CFL, velocity, depth, element_length) result(dt) Arguments Type Intent Optional Attributes Name real, intent(in) :: CFL real, intent(in) :: velocity real, intent(in) :: depth real, intent(in) :: element_length Return Value real Subroutines public subroutine test_case_initiation (linkR, nodeR, linkI, nodeI, linkYN, nodeYN, linkName, nodeName, bcdataDn, bcdataUp) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:,:), allocatable :: linkR real, intent(out), dimension(:,:), allocatable :: nodeR integer, intent(out), dimension(:,:), allocatable :: linkI integer, intent(out), dimension(:,:), allocatable :: nodeI logical, intent(out), dimension(:,:), allocatable :: linkYN logical, intent(out), dimension(:,:), allocatable :: nodeYN type(string), intent(out), dimension(:), allocatable :: linkName type(string), intent(out), dimension(:), allocatable :: nodeName type(bcType), intent(out), dimension(:), allocatable :: bcdataDn type(bcType), intent(out), dimension(:), allocatable :: bcdataUp private subroutine control_variable_allocation (depth_dnstream, depth_upstream, lowerZ, upperZ, channel_length, channel_breadth, subdivide_length, flowrate, area, velocity, Froude, ManningsN, idepth_type) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:), allocatable :: depth_dnstream real, intent(out), dimension(:), allocatable :: depth_upstream real, intent(out), dimension(:), allocatable :: lowerZ real, intent(out), dimension(:), allocatable :: upperZ real, intent(out), dimension(:), allocatable :: channel_length real, intent(out), dimension(:), allocatable :: channel_breadth real, intent(out), dimension(:), allocatable :: subdivide_length real, intent(out), dimension(:), allocatable :: flowrate real, intent(out), dimension(:), allocatable :: area real, intent(out), dimension(:), allocatable :: velocity real, intent(out), dimension(:), allocatable :: Froude real, intent(out), dimension(:), allocatable :: ManningsN integer, intent(out), dimension(:), allocatable :: idepth_type private subroutine this_setting_for_time_and_steps (CFL, velocity, depth, subdivide_length, first_step, last_step, display_interval, dt_significant_digits) Arguments Type Intent Optional Attributes Name real, intent(in) :: CFL real, intent(in) :: velocity (:) real, intent(in) :: depth (:) real, intent(in) :: subdivide_length (:) integer, intent(in) :: first_step integer, intent(in) :: last_step integer, intent(in) :: display_interval integer, intent(in) :: dt_significant_digits private subroutine froude_driven_setup (upperZ, area, flowrate, velocity, Froude, breadth, ManningsN, total_length, lowerZ, depth) Arguments Type Intent Optional Attributes Name real, intent(out) :: upperZ real, intent(out) :: area real, intent(out) :: flowrate real, intent(out) :: velocity real, intent(in) :: Froude real, intent(in) :: breadth real, intent(in) :: ManningsN real, intent(in) :: total_length real, intent(in) :: lowerZ real, intent(in) :: depth private subroutine write_testcase_setup_file (Froude, CFL, flowrate, velocity, depth_upstream, depth_dnstream, breadth, area, total_length, subdivide_length, lowerZ, upperZ, ManningsN) Arguments Type Intent Optional Attributes Name real, intent(in) :: Froude (:) real, intent(in) :: CFL real, intent(in) :: flowrate (:) real, intent(in) :: velocity (:) real, intent(in) :: depth_upstream (:) real, intent(in) :: depth_dnstream (:) real, intent(in) :: breadth (:) real, intent(in) :: area (:) real, intent(in) :: total_length (:) real, intent(in) :: subdivide_length (:) real, intent(in) :: lowerZ (:) real, intent(in) :: upperZ (:) real, intent(in) :: ManningsN (:)","title":"test_cases – SWMMengine","tags":"","loc":"module/test_cases.html"},{"text":"Uses adjustments array_index bc data_keys junction setting_definition globals utility module~~element_geometry~~UsesGraph module~element_geometry element_geometry module~globals globals module~element_geometry->module~globals module~utility utility module~element_geometry->module~utility module~junction junction module~element_geometry->module~junction module~array_index array_index module~element_geometry->module~array_index module~adjustments adjustments module~element_geometry->module~adjustments module~setting_definition setting_definition module~element_geometry->module~setting_definition module~bc bc module~element_geometry->module~bc module~data_keys data_keys module~element_geometry->module~data_keys module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~utility->module~data_keys module~junction->module~globals module~junction->module~utility module~junction->module~array_index module~junction->module~setting_definition module~junction->module~data_keys module~array_index->module~globals module~adjustments->module~globals module~adjustments->module~utility module~adjustments->module~array_index module~adjustments->module~setting_definition module~adjustments->module~data_keys module~setting_definition->module~type_definitions module~bc->module~globals module~bc->module~utility module~bc->module~array_index module~bc->module~setting_definition module~bc->module~data_keys module~bc->module~type_definitions module~data_keys->module~globals var panmoduleelement_geometryUsesGraph = svgPanZoom('#moduleelement_geometryUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~element_geometry~~UsedByGraph module~element_geometry element_geometry module~explicit_euler explicit_euler module~explicit_euler->module~element_geometry module~initial_condition initial_condition module~initial_condition->module~element_geometry module~runge_kutta runge_kutta module~runge_kutta->module~element_geometry program~main main program~main->module~initial_condition module~time_loop time_loop program~main->module~time_loop module~time_loop->module~explicit_euler module~time_loop->module~runge_kutta Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines element_geometry_update element_geometry_branch_fix rectangular_geometry_update rectangular_channel_or_junction rectangular_junction_leg Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Subroutines public subroutine element_geometry_update (elem2R, elem2I, elem2YN, e2r_VolumeColumn, elemMR, elemMI, elemMYN, eMr_VolumeColumn, faceR, faceI, bcdataDn, bcdataUp, thisTime, method_EtaM) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(inout), target :: elem2I (:,:) logical, intent(inout), target :: elem2YN (:,:) integer, intent(in) :: e2r_VolumeColumn real, intent(inout), target :: elemMR (:,:) integer, intent(inout), target :: elemMI (:,:) logical, intent(inout), target :: elemMYN (:,:) integer, intent(in) :: eMr_VolumeColumn real, intent(in) :: faceR (:,:) integer, intent(in) :: faceI (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) real, intent(in) :: thisTime integer, intent(in) :: method_EtaM public subroutine element_geometry_branch_fix (elemMR, elemMI, faceR, faceI) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) real, intent(in) :: faceR (:,:) integer, intent(in) :: faceI (:,:) private subroutine rectangular_geometry_update (elem2R, elem2I, e2r_Volume_new, elemMR, elemMI, eMr_Volume_new, faceR, eMr_EtaOld, method_EtaM) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) integer, intent(in) :: e2r_Volume_new real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: eMr_Volume_new real, intent(in) :: faceR (:,:) integer, intent(in) :: eMr_EtaOld integer, intent(in) :: method_EtaM private subroutine rectangular_channel_or_junction (elemR, elemI, ei_geometry, ei_elem_type, elem_typ_value, er_Length, er_Zbottom, er_BreadthScale, er_Topwidth, er_Area, er_Eta, er_Perimeter, er_HydDepth, er_HydRadius, er_Volume) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) integer, intent(in) :: elemI (:,:) integer, intent(in) :: ei_geometry integer, intent(in) :: ei_elem_type integer, intent(in) :: elem_typ_value integer, intent(in) :: er_Length integer, intent(in) :: er_Zbottom integer, intent(in) :: er_BreadthScale integer, intent(in) :: er_Topwidth integer, intent(in) :: er_Area integer, intent(in) :: er_Eta integer, intent(in) :: er_Perimeter integer, intent(in) :: er_HydDepth integer, intent(in) :: er_HydRadius integer, intent(in) :: er_Volume private subroutine rectangular_junction_leg (elemMR, elemMI, faceR, face_per_elemM, eMi_nfacesDir, eMi_MfaceDir, eMr_AreaDir, eMr_ZbottomDir, eMr_BreadthScaleDir, eMr_TopwidthDir, eMr_EtaDir, eMr_HydDepthDir, eMr_EtaOld, fr_Eta_dir, method_EtaM) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in) :: face_per_elemM integer, intent(in) :: eMi_nfacesDir integer, intent(in) :: eMi_MfaceDir (:) integer, intent(in) :: eMr_AreaDir (:) integer, intent(in) :: eMr_ZbottomDir (:) integer, intent(in) :: eMr_BreadthScaleDir (:) integer, intent(in) :: eMr_TopwidthDir (:) integer, intent(in) :: eMr_EtaDir (:) integer, intent(in) :: eMr_HydDepthDir (:) integer, intent(in) :: eMr_EtaOld integer, intent(in) :: fr_Eta_dir integer, intent(in) :: method_EtaM","title":"element_geometry – SWMMengine","tags":"","loc":"module/element_geometry.html"},{"text":"Uses type_definitions module~~setting_definition~~UsesGraph module~setting_definition setting_definition module~type_definitions type_definitions module~setting_definition->module~type_definitions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~setting_definition~~UsedByGraph module~setting_definition setting_definition module~globals globals module~globals->module~setting_definition module~output output module~output->module~setting_definition module~output->module~globals module~utility utility module~output->module~utility module~bc bc module~output->module~bc module~array_index array_index module~output->module~array_index module~data_keys data_keys module~output->module~data_keys module~runge_kutta runge_kutta module~runge_kutta->module~setting_definition module~runge_kutta->module~globals module~runge_kutta->module~utility module~element_dynamics element_dynamics module~runge_kutta->module~element_dynamics module~diagnostic diagnostic module~runge_kutta->module~diagnostic module~element_geometry element_geometry module~runge_kutta->module~element_geometry module~adjustments adjustments module~runge_kutta->module~adjustments module~face_values face_values module~runge_kutta->module~face_values module~runge_kutta->module~bc module~runge_kutta->module~array_index module~runge_kutta->module~data_keys module~utility->module~setting_definition module~utility->module~globals module~utility->module~array_index module~utility->module~data_keys module~junction junction module~junction->module~setting_definition module~junction->module~globals module~junction->module~utility module~junction->module~array_index module~junction->module~data_keys module~element_dynamics->module~setting_definition module~element_dynamics->module~globals module~element_dynamics->module~utility module~element_dynamics->module~junction module~element_dynamics->module~adjustments module~element_dynamics->module~bc module~element_dynamics->module~array_index module~element_dynamics->module~data_keys module~friction_model friction_model module~friction_model->module~setting_definition module~friction_model->module~globals module~friction_model->module~array_index module~friction_model->module~data_keys module~diagnostic->module~setting_definition module~diagnostic->module~globals module~diagnostic->module~utility module~diagnostic->module~bc module~diagnostic->module~array_index module~diagnostic->module~data_keys program~main main program~main->module~setting_definition program~main->module~globals program~main->module~output program~main->module~utility program~main->module~junction program~main->module~diagnostic program~main->module~bc module~debug debug program~main->module~debug module~time_loop time_loop program~main->module~time_loop module~initial_condition initial_condition program~main->module~initial_condition module~test_cases test_cases program~main->module~test_cases module~initialization initialization program~main->module~initialization program~main->module~array_index module~allocate_storage allocate_storage program~main->module~allocate_storage module~network_define network_define program~main->module~network_define module~checking checking program~main->module~checking program~main->module~data_keys module~element_geometry->module~setting_definition module~element_geometry->module~globals module~element_geometry->module~utility module~element_geometry->module~junction module~element_geometry->module~adjustments module~element_geometry->module~bc module~element_geometry->module~array_index module~element_geometry->module~data_keys module~adjustments->module~setting_definition module~adjustments->module~globals module~adjustments->module~utility module~adjustments->module~array_index module~adjustments->module~data_keys module~explicit_euler explicit_euler module~explicit_euler->module~setting_definition module~explicit_euler->module~globals module~explicit_euler->module~utility module~explicit_euler->module~element_dynamics module~explicit_euler->module~element_geometry module~explicit_euler->module~adjustments module~explicit_euler->module~face_values module~explicit_euler->module~bc module~explicit_euler->module~array_index module~explicit_euler->module~data_keys module~case_simple_channel case_simple_channel module~case_simple_channel->module~setting_definition module~case_simple_channel->module~globals module~case_simple_channel->module~bc module~case_simple_channel->module~array_index module~case_simple_channel->module~allocate_storage module~case_simple_channel->module~data_keys module~face_values->module~setting_definition module~face_values->module~globals module~face_values->module~utility module~face_values->module~adjustments module~face_values->module~bc module~face_values->module~array_index module~face_values->module~data_keys module~bc->module~setting_definition module~bc->module~globals module~bc->module~utility module~bc->module~array_index module~bc->module~data_keys module~debug->module~setting_definition module~debug->module~globals module~debug->module~utility module~debug->module~bc module~debug->module~array_index module~debug->module~data_keys module~time_loop->module~setting_definition module~time_loop->module~globals module~time_loop->module~output module~time_loop->module~runge_kutta module~time_loop->module~diagnostic module~time_loop->module~explicit_euler module~time_loop->module~face_values module~time_loop->module~bc module~time_loop->module~debug module~time_loop->module~array_index module~time_loop->module~data_keys module~initial_condition->module~setting_definition module~initial_condition->module~globals module~initial_condition->module~utility module~initial_condition->module~junction module~initial_condition->module~element_dynamics module~initial_condition->module~element_geometry module~initial_condition->module~face_values module~initial_condition->module~bc module~initial_condition->module~array_index module~initial_condition->module~data_keys module~case_y_channel case_y_channel module~case_y_channel->module~setting_definition module~case_y_channel->module~globals module~case_y_channel->module~bc module~case_y_channel->module~array_index module~case_y_channel->module~allocate_storage module~case_y_channel->module~data_keys module~test_cases->module~setting_definition module~test_cases->module~globals module~test_cases->module~utility module~test_cases->module~case_simple_channel module~test_cases->module~bc module~test_cases->module~case_y_channel module~test_cases->module~array_index module~test_cases->module~data_keys module~stub stub module~stub->module~setting_definition module~stub->module~globals module~stub->module~array_index module~stub->module~data_keys module~initialization->module~globals module~initialization->module~array_index module~initialization->module~data_keys module~array_index->module~globals module~allocate_storage->module~globals module~allocate_storage->module~utility module~allocate_storage->module~array_index module~network_define->module~globals module~network_define->module~junction module~network_define->module~initialization module~network_define->module~array_index module~network_define->module~allocate_storage module~network_define->module~data_keys module~custom_network custom_network module~custom_network->module~globals module~custom_network->module~array_index module~custom_network->module~data_keys module~checking->module~globals module~checking->module~array_index module~checking->module~data_keys module~data_keys->module~globals var panmodulesetting_definitionUsedByGraph = svgPanZoom('#modulesetting_definitionUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables setting debuglevel Derived Types adjustVshapedFlowrateType BClimiterType flowrateType timescaleType velocityType constantType debugoutType epsilonType limiterType methodType outputThreadedLinkType smallvolumeType stepType testcaseType timeType zerovalueType settingType Subroutines setting_default Variables Type Visibility Attributes Name Initial type( settingType ), public, target :: setting integer, private :: debuglevel = 0 Derived Types type, public :: adjustVshapedFlowrateType Components Type Visibility Attributes Name Initial logical, public :: Apply = .true. real, public :: Coef = 0.1 type, public :: BClimiterType Components Type Visibility Attributes Name Initial logical, public :: UseInflowFroudeNumberLimiter = .true. real, public :: FroudeInflowMaximum = 1.5 type, public :: flowrateType Components Type Visibility Attributes Name Initial logical, public :: UseFaceVolumeTransport = .true. real, public :: FaceVolumeTransport = 0.5 type, public :: timescaleType Components Type Visibility Attributes Name Initial real, public :: Maximum = 1e6 real, public :: Minimum = 1e-6 type, public :: velocityType Components Type Visibility Attributes Name Initial logical, public :: UseLimitMax = .true. real, public :: Maximum = 20 type, public :: constantType Components Type Visibility Attributes Name Initial real, public :: gravity = 9.81 type, public :: debugoutType Components Type Visibility Attributes Name Initial logical, public :: elem2R = .false. logical, public :: elem2I = .false. logical, public :: elem2YN = .false. logical, public :: elemMR = .false. logical, public :: elemMI = .false. logical, public :: elemMYN = .false. logical, public :: faceR = .false. logical, public :: faceI = .false. logical, public :: faceYN = .false. logical, public :: nodeR = .false. logical, public :: nodeI = .false. logical, public :: nodeYN = .false. logical, public :: linkR = .false. logical, public :: linkI = .false. logical, public :: linkYN = .false. integer, public :: DisplayInterval = 1 logical, public :: SuppressAllFiles = .false. logical, public :: SuppressTimeStep = .false. logical, public :: SuppressTimeValue = .false. logical, public :: SuppressNdat = .false. character(len=64), public :: FolderName = 'debugoutputA' character(len=64), public :: FileName = 'debug' character(len=256), public :: FolderPath = './' type, public :: epsilonType Components Type Visibility Attributes Name Initial real, public :: FroudeJump = 0.1 real, public :: InflowDepthIncreaseFroudeLimit = 0.1 type, public :: limiterType Components Type Visibility Attributes Name Initial type( BClimiterType ), public :: BC type( flowrateType ), public :: Flowrate type( velocityType ), public :: Velocity type( timescaleType ), public :: Timescale type, public :: methodType Components Type Visibility Attributes Name Initial type( adjustVshapedFlowrateType ), public :: AdjustVshapedFlowrate type, public :: outputThreadedLinkType Components Type Visibility Attributes Name Initial integer, public :: DisplayInterval = 1 logical, public :: SuppressAllFiles = .false. logical, public :: UseThisOutput = .false. logical, public :: area = .false. logical, public :: flowrate = .false. logical, public :: velocity = .false. logical, public :: eta = .false. logical, public :: depth = .false. character(len=64), public :: FolderName = 'OutputThreaded' character(len=64), public :: FileName = 'out' character(len=256), public :: FolderPath = './' type, public :: smallvolumeType Components Type Visibility Attributes Name Initial logical, public :: UseSmallVolumes = .true. real, public :: DepthCutoff = 0.01 real, public :: ManningsN = 0.01 real, public :: MinimumTopwidth = 0.5 real, public :: MinimumArea = 0.005 real, public :: MinimumPerimeter = 0.52 real, public :: MinimumHydRadius = 0.009 type, public :: stepType Components Type Visibility Attributes Name Initial integer, public :: First integer, public :: Final integer, public :: Current integer, public :: FromRestart type, public :: testcaseType Components Type Visibility Attributes Name Initial logical, public :: UseTestCase character(len=64), public :: TestName type, public :: timeType Components Type Visibility Attributes Name Initial character(len=14), public :: DateTimeStamp real, public :: Dt real, public :: StartTime = 0.0 real, public :: EndTime = 0.0 real, public :: ThisTime real, public :: NextTime type, public :: zerovalueType Components Type Visibility Attributes Name Initial logical, public :: UseZeroValues = .true. real, public :: Area = 1.0e-7 real, public :: Depth = 1.0e-4 real, public :: Flowrate = 0.0 real, public :: Topwidth = 1.0e-4 real, public :: Velocity = 0.0 real, public :: Volume = 1.0e-6 type, public :: settingType Components Type Visibility Attributes Name Initial integer, public :: dummy type( constantType ), public :: Constant type( debugoutType ), public :: DebugOut type( epsilonType ), public :: Eps type( limiterType ), public :: Limiter type( methodType ), public :: Method type( outputThreadedLinkType ), public :: OutputThreadedLink type( smallvolumeType ), public :: SmallVolume type( stepType ), public :: Step type( testcaseType ), public :: TestCase type( timeType ), public :: Time type( zerovalueType ), public :: ZeroValue Subroutines public subroutine setting_default () Arguments None","title":"setting_definition – SWMMengine","tags":"","loc":"module/setting_definition.html"},{"text":"Uses array_index adjustments bc data_keys globals junction setting_definition utility module~~element_dynamics~~UsesGraph module~element_dynamics element_dynamics module~globals globals module~element_dynamics->module~globals module~utility utility module~element_dynamics->module~utility module~junction junction module~element_dynamics->module~junction module~array_index array_index module~element_dynamics->module~array_index module~adjustments adjustments module~element_dynamics->module~adjustments module~setting_definition setting_definition module~element_dynamics->module~setting_definition module~bc bc module~element_dynamics->module~bc module~data_keys data_keys module~element_dynamics->module~data_keys module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~utility->module~data_keys module~junction->module~globals module~junction->module~utility module~junction->module~array_index module~junction->module~setting_definition module~junction->module~data_keys module~array_index->module~globals module~adjustments->module~globals module~adjustments->module~utility module~adjustments->module~array_index module~adjustments->module~setting_definition module~adjustments->module~data_keys module~setting_definition->module~type_definitions module~bc->module~globals module~bc->module~utility module~bc->module~array_index module~bc->module~setting_definition module~bc->module~data_keys module~bc->module~type_definitions module~data_keys->module~globals var panmoduleelement_dynamicsUsesGraph = svgPanZoom('#moduleelement_dynamicsUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~element_dynamics~~UsedByGraph module~element_dynamics element_dynamics module~explicit_euler explicit_euler module~explicit_euler->module~element_dynamics module~initial_condition initial_condition module~initial_condition->module~element_dynamics module~runge_kutta runge_kutta module~runge_kutta->module~element_dynamics program~main main program~main->module~initial_condition module~time_loop time_loop program~main->module~time_loop module~time_loop->module~explicit_euler module~time_loop->module~runge_kutta Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Functions small_chezy_velocity velocity_blend Subroutines element_dynamics_update element_flowrate_update flowrate_from_velocity blended_smallvolume_velocity velocity_blend_with_mask smallvolume_ManningsN element_timescale timescale_value_channel timescale_value_junction timescale_junction_one_direction timescale_limit_junction_one_direction timescale_limiter apply_limiter_with_mask Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Functions private pure elemental function small_chezy_velocity (ManningsN, HydRadius, Slope) Arguments Type Intent Optional Attributes Name real, intent(in) :: ManningsN real, intent(in) :: HydRadius real, intent(in) :: Slope Return Value real private pure elemental function velocity_blend (SmallVolumeRatio, velocity, smallVelocity) Arguments Type Intent Optional Attributes Name real, intent(in) :: SmallVolumeRatio real, intent(in) :: velocity real, intent(in) :: smallVelocity Return Value real Subroutines public subroutine element_dynamics_update (elem2R, elemMR, faceR, elem2I, elemMI, elem2YN, elemMYN, bcdataDn, bcdataUp, e2r_Velocity_new, eMr_Velocity_new, e2r_Volume_new, eMr_Volume_new, thisTime) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) real, intent(inout), target :: elemMR (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in) :: elem2I (:,:) integer, intent(in) :: elemMI (:,:) logical, intent(inout), target :: elem2YN (:,:) logical, intent(inout), target :: elemMYN (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: eMr_Velocity_new integer, intent(in) :: e2r_Volume_new integer, intent(in) :: eMr_Volume_new real, intent(in) :: thisTime private subroutine element_flowrate_update (elem2R, elemMR, faceR, elem2I, elemMI, e2r_Velocity_new, eMr_Velocity_new) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) real, intent(inout), target :: elemMR (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in), target :: elem2I (:,:) integer, intent(in), target :: elemMI (:,:) integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: eMr_Velocity_new private subroutine flowrate_from_velocity (elemR, elemI, er_Flowrate, er_Area, er_Velocity, ei_elem_type, eThisElemType) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) integer, intent(in) :: elemI (:,:) integer, intent(in) :: er_Flowrate integer, intent(in) :: er_Area integer, intent(in) :: er_Velocity integer, intent(in) :: ei_elem_type integer, intent(in) :: eThisElemType private subroutine blended_smallvolume_velocity (elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, e2r_Velocity_new, eMr_Velocity_new) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) logical, intent(in) :: elem2YN (:,:) real, intent(inout), target :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) logical, intent(in) :: elemMYN (:,:) real, intent(in), target :: faceR (:,:) integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: eMr_Velocity_new private subroutine velocity_blend_with_mask (elemR, elemI, elemYN, faceR, next_er_temparray, er_n_temp, er_Temp, er_Velocity_new, er_Flowrate, er_Length, er_Area, er_HydRadius, er_SmallVolumeRatio, eYN_IsSmallVolume, ei_roughness_type, er_Roughness, ei_elem_type, elemType, ei_Mface_u, ei_Mface_d) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) integer, intent(in), target :: elemI (:,:) logical, intent(in) :: elemYN (:,:) real, intent(in) :: faceR (:,:) integer, intent(inout) :: next_er_temparray integer, intent(in) :: er_n_temp integer, intent(in) :: er_Temp (:) integer, intent(in) :: er_Velocity_new integer, intent(in) :: er_Flowrate integer, intent(in) :: er_Length integer, intent(in) :: er_Area integer, intent(in) :: er_HydRadius integer, intent(in) :: er_SmallVolumeRatio integer, intent(in) :: eYN_IsSmallVolume integer, intent(in) :: ei_roughness_type integer, intent(in) :: er_Roughness integer, intent(in) :: ei_elem_type integer, intent(in) :: elemType integer, intent(in) :: ei_Mface_u integer, intent(in) :: ei_Mface_d private subroutine smallvolume_ManningsN (elemR, elemI, elemYN, er_tManningsN, er_tSmallVelocity, eYN_IsSmallVolume, ei_roughness_type, er_Roughness) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) integer, intent(in) :: elemI (:,:) logical, intent(in) :: elemYN (:,:) integer, intent(in) :: er_tManningsN integer, intent(in) :: er_tSmallVelocity integer, intent(in) :: eYN_IsSmallVolume integer, intent(in) :: ei_roughness_type integer, intent(in) :: er_Roughness private subroutine element_timescale (elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, bcdataDn, bcdataUp, e2r_Velocity_new) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) logical, intent(inout) :: elem2YN (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) logical, intent(inout) :: elemMYN (:,:) type(bcType), intent(in) :: bcdataDn (:) type(bcType), intent(in) :: bcdataUp (:) integer, intent(in) :: e2r_Velocity_new private subroutine timescale_value_channel (elem2R, elem2I, elem2YN, e2r_Velocity_new) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) logical, intent(inout), target :: elem2YN (:,:) integer, intent(in) :: e2r_Velocity_new private subroutine timescale_value_junction (elemMR, elemMI, elemMYN) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) logical, intent(inout) :: elemMYN (:,:) private subroutine timescale_junction_one_direction (elemMR, elemMI, dir_face_per_elemM, eMi_nfaces_dir, eMr_LengthDir, eMr_VelocityDir, eMr_TimescaleDir, eMr_waveindx, isUp) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) integer, intent(in) :: dir_face_per_elemM integer, intent(in) :: eMi_nfaces_dir integer, intent(in) :: eMr_LengthDir (:) integer, intent(in) :: eMr_VelocityDir (:) integer, intent(in) :: eMr_TimescaleDir (:) integer, intent(in) :: eMr_waveindx logical, intent(in) :: isUp private subroutine timescale_limit_junction_one_direction (elemMR, elemMI, elemMYN, dir_face_per_elemM, eMi_nfaces_dir, eMr_TimescaleDir) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elemMR (:,:) integer, intent(in) :: elemMI (:,:) logical, intent(inout), target :: elemMYN (:,:) integer, intent(in) :: dir_face_per_elemM integer, intent(in) :: eMi_nfaces_dir integer, intent(in) :: eMr_TimescaleDir (:) private subroutine timescale_limiter (elemR, elemI, elemYN, indx, maskindx1, maskindx2) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: elemR (:,:) integer, intent(in) :: elemI (:,:) logical, intent(inout), target :: elemYN (:,:) integer, intent(in) :: indx (:) integer, intent(in) :: maskindx1 integer, intent(in) :: maskindx2 private pure subroutine apply_limiter_with_mask (inoutarray, maskarray, limitvalue) Arguments Type Intent Optional Attributes Name real, intent(inout) :: inoutarray (:) logical, intent(in) :: maskarray (:) real, intent(in) :: limitvalue","title":"element_dynamics – SWMMengine","tags":"","loc":"module/element_dynamics.html"},{"text":"Uses globals module~~array_index~~UsesGraph module~array_index array_index module~globals globals module~array_index->module~globals module~setting_definition setting_definition module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~setting_definition->module~type_definitions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~array_index~~UsedByGraph module~array_index array_index module~output output module~output->module~array_index module~utility utility module~output->module~utility module~bc bc module~output->module~bc program~main main program~main->module~array_index program~main->module~output module~allocate_storage allocate_storage program~main->module~allocate_storage module~time_loop time_loop program~main->module~time_loop module~test_cases test_cases program~main->module~test_cases module~initialization initialization program~main->module~initialization program~main->module~utility module~diagnostic diagnostic program~main->module~diagnostic module~network_define network_define program~main->module~network_define module~initial_condition initial_condition program~main->module~initial_condition program~main->module~bc module~junction junction program~main->module~junction module~debug debug program~main->module~debug module~checking checking program~main->module~checking module~allocate_storage->module~array_index module~allocate_storage->module~utility module~custom_network custom_network module~custom_network->module~array_index module~time_loop->module~array_index module~time_loop->module~output module~explicit_euler explicit_euler module~time_loop->module~explicit_euler module~time_loop->module~diagnostic module~face_values face_values module~time_loop->module~face_values module~time_loop->module~bc module~runge_kutta runge_kutta module~time_loop->module~runge_kutta module~time_loop->module~debug module~test_cases->module~array_index module~case_simple_channel case_simple_channel module~test_cases->module~case_simple_channel module~case_y_channel case_y_channel module~test_cases->module~case_y_channel module~test_cases->module~utility module~test_cases->module~bc module~initialization->module~array_index module~explicit_euler->module~array_index module~explicit_euler->module~utility module~element_dynamics element_dynamics module~explicit_euler->module~element_dynamics module~adjustments adjustments module~explicit_euler->module~adjustments module~explicit_euler->module~face_values module~explicit_euler->module~bc module~element_geometry element_geometry module~explicit_euler->module~element_geometry module~case_simple_channel->module~array_index module~case_simple_channel->module~allocate_storage module~case_simple_channel->module~bc module~case_y_channel->module~array_index module~case_y_channel->module~allocate_storage module~case_y_channel->module~bc module~stub stub module~stub->module~array_index module~utility->module~array_index module~element_dynamics->module~array_index module~element_dynamics->module~utility module~element_dynamics->module~adjustments module~element_dynamics->module~bc module~element_dynamics->module~junction module~diagnostic->module~array_index module~diagnostic->module~utility module~diagnostic->module~bc module~adjustments->module~array_index module~adjustments->module~utility module~face_values->module~array_index module~face_values->module~utility module~face_values->module~adjustments module~face_values->module~bc module~network_define->module~array_index module~network_define->module~allocate_storage module~network_define->module~initialization module~network_define->module~junction module~initial_condition->module~array_index module~initial_condition->module~utility module~initial_condition->module~element_dynamics module~initial_condition->module~face_values module~initial_condition->module~bc module~initial_condition->module~junction module~initial_condition->module~element_geometry module~bc->module~array_index module~bc->module~utility module~runge_kutta->module~array_index module~runge_kutta->module~utility module~runge_kutta->module~element_dynamics module~runge_kutta->module~diagnostic module~runge_kutta->module~adjustments module~runge_kutta->module~face_values module~runge_kutta->module~bc module~runge_kutta->module~element_geometry module~junction->module~array_index module~junction->module~utility module~friction_model friction_model module~friction_model->module~array_index module~element_geometry->module~array_index module~element_geometry->module~utility module~element_geometry->module~adjustments module~element_geometry->module~bc module~element_geometry->module~junction module~debug->module~array_index module~debug->module~utility module~debug->module~bc module~checking->module~array_index var panmodulearray_indexUsedByGraph = svgPanZoom('#modulearray_indexUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables first_face_index first_elemM_index first_elem2_index face_per_elemM upstream_face_per_elemM dnstream_face_per_elemM links_per_node elem_per_face e2i_idx e2i_elem_type e2i_geometry e2i_roughness_type e2i_link_ID e2i_link_Pos e2i_Mface_u e2i_Mface_d e2i_idx_base1 e2i_temp1 e2i_temp2 e2i_n_temp e2i_idx_max e2i_Temp eMi_idx eMi_elem_type eMi_geometry eMi_nfaces eMi_nfaces_u eMi_nfaces_d eMi_roughness_type eMi_node_ID eMi_temp1 eMi_temp2 eMi_idx_base1 eMi_n_temp eMi_Temp eMi_Mface_u1 eMi_Mface_u2 eMi_Mface_u3 eMi_idx_base2 eMi_Mface_d1 eMi_Mface_d2 eMi_Mface_d3 eMi_idx_max eMi_MfaceUp eMi_MfaceDn eMi_MfaceAll fi_idx fi_type fi_Melem_u fi_Melem_d fi_etype_u fi_etype_d fi_branch_u fi_branch_d fi_jump_type fi_node_ID fi_link_ID fi_link_Pos fi_BC_ID fi_temp1 fi_temp2 fi_idx_max fi_n_temp fi_Temp e2r_Volume e2r_SmallVolume e2r_SmallVolumeRatio e2r_Flowrate e2r_Velocity e2r_Timescale_u e2r_Timescale_d e2r_Friction e2r_Eta e2r_Head e2r_Area e2r_Topwidth e2r_Perimeter e2r_HydDepth e2r_HydRadius e2r_X e2r_Length e2r_Zbottom e2r_BreadthScale e2r_Roughness e2r_VolumeConservation e2r_FroudeNumber e2r_idx_base1 e2r_temp1 e2r_temp2 e2r_temp3 e2r_temp4 e2r_temp5 e2r_temp6 e2r_n_temp e2r_idx_max e2r_Temp eMr_Volume eMr_SmallVolume eMr_SmallVolumeRatio eMr_Flowrate eMr_Velocity eMr_Friction eMr_Eta eMr_Head eMr_Area eMr_Topwidth eMr_Perimeter eMr_HydDepth eMr_HydRadius eMr_X eMr_Length eMr_Zbottom eMr_BreadthScale eMr_Roughness eMr_VolumeConservation eMr_FroudeNumber eMr_idx_base1 eMr_Eta_u1 eMr_Eta_u2 eMr_Eta_u3 eMr_idx_base2 eMr_Eta_d1 eMr_Eta_d2 eMr_Eta_d3 eMr_idx_base3 eMr_Flowrate_u1 eMr_Flowrate_u2 eMr_Flowrate_u3 eMr_idx_base4 eMr_Flowrate_d1 eMr_Flowrate_d2 eMr_Flowrate_d3 eMr_idx_base5 eMr_Velocity_u1 eMr_Velocity_u2 eMr_Velocity_u3 eMr_idx_base6 eMr_Velocity_d1 eMr_Velocity_d2 eMr_Velocity_d3 eMr_idx_base7 eMr_Timescale_u1 eMr_Timescale_u2 eMr_Timescale_u3 eMr_idx_base8 eMr_Timescale_d1 eMr_Timescale_d2 eMr_Timescale_d3 eMr_idx_base9 eMr_Area_u1 eMr_Area_u2 eMr_Area_u3 eMr_idx_base10 eMr_Area_d1 eMr_Area_d2 eMr_Area_d3 eMr_idx_base11 eMr_Topwidth_u1 eMr_Topwidth_u2 eMr_Topwidth_u3 eMr_idx_base12 eMr_Topwidth_d1 eMr_Topwidth_d2 eMr_Topwidth_d3 eMr_idx_base13 eMr_HydDepth_u1 eMr_HydDepth_u2 eMr_HydDepth_u3 eMr_idx_base14 eMr_HydDepth_d1 eMr_HydDepth_d2 eMr_HydDepth_d3 eMr_idx_base15 eMr_Length_u1 eMr_Length_u2 eMr_Length_u3 eMr_idx_base16 eMr_Length_d1 eMr_Length_d2 eMr_Length_d3 eMr_idx_base17 eMr_Zbottom_u1 eMr_Zbottom_u2 eMr_Zbottom_u3 eMr_idx_base18 eMr_Zbottom_d1 eMr_Zbottom_d2 eMr_Zbottom_d3 eMr_idx_base19 eMr_BreadthScale_u1 eMr_BreadthScale_u2 eMr_BreadthScale_u3 eMr_idx_base20 eMr_BreadthScale_d1 eMr_BreadthScale_d2 eMr_BreadthScale_d3 eMr_idx_base21 eMr_temp1 eMr_temp2 eMr_temp3 eMr_temp4 eMr_temp5 eMr_temp6 eMr_n_temp eMr_idx_base22 eMr_idx_max eMr_Temp eMr_EtaUp eMr_FlowrateUp eMr_VelocityUp eMr_TimescaleUp eMr_AreaUp eMr_TopwidthUp eMr_HydDepthUp eMr_LengthUp eMr_ZbottomUp eMr_BreadthScaleUp eMr_EtaDn eMr_FlowrateDn eMr_VelocityDn eMr_TimescaleDn eMr_AreaDn eMr_TopwidthDn eMr_HydDepthDn eMr_LengthDn eMr_ZbottomDn eMr_BreadthScaleDn eMr_EtaAll eMr_FlowrateAll eMr_VelocityAll eMr_TimescaleAll eMr_AreaAll eMr_TopwidthAll eMr_HydDepthAll eMr_LengthAll eMr_ZbottomAll eMr_BreadthScaleAll fr_Area_d fr_Area_u fr_Eta_d fr_Eta_u fr_Flowrate fr_HydDepth_d fr_HydDepth_u fr_Topwidth fr_Velocity_d fr_Velocity_u fr_Zbottom fr_X fr_temp1 fr_temp2 fr_temp3 fr_temp4 fr_idx_max fr_n_temp fr_Temp e2YN_IsSmallVolume e2YN_IsAdhocFlowrate e2YN_temp1 e2YN_temp2 e2YN_temp3 e2YN_temp4 e2YN_idx_max e2YN_n_temp e2YN_Temp eMYN_IsSmallVolume eMYN_IsAdhocFlowrate eMYN_temp1 eMYN_temp2 eMYN_temp3 eMYN_temp4 eMYN_idx_max eMYN_n_temp eMYN_Temp fYN_temp1 fYN_temp2 fYN_idx_max fYN_n_temp fYN_Temp li_idx li_link_type li_geometry li_roughness_type li_N_element li_Mnode_u li_Mnode_d li_Melem_u li_Melem_d li_Mface_u li_Mface_d li_assigned li_InitialDepthType li_temp1 li_idx_max ni_idx ni_node_type ni_N_link_u ni_N_link_d ni_assigned ni_temp1 ni_idx_base1 ni_Mlink_u1 ni_Mlink_u2 ni_Mlink_u3 ni_idx_base2 ni_Mlink_d1 ni_Mlink_d2 ni_Mlink_d3 ni_idx_max ni_MlinkUp ni_MlinkDn lr_Length lr_BreadthScale lr_ElementLength lr_Slope lr_Roughness lr_InitialFlowrate lr_InitialDepth lr_InitialUpstreamDepth lr_InitialDnstreamDepth lr_temp1 lr_idx_max nr_Zbottom nr_temp1 nr_idx_base1 nr_ElementLength_u1 nr_ElementLength_u2 nr_ElementLength_u3 nr_idx_base2 nr_ElementLength_d1 nr_ElementLength_d2 nr_ElementLength_d3 nr_idx_max nr_ElementLengthUp nr_ElementLengthDn nYN_temp1 nYN_idx_max lYN_temp1 lYN_idx_max Variables Type Visibility Attributes Name Initial integer, public, parameter :: first_face_index = 1 integer, public, parameter :: first_elemM_index = 1 integer, public, parameter :: first_elem2_index = 1 integer, public, parameter :: face_per_elemM = 6 integer, public, parameter :: upstream_face_per_elemM = 3 integer, public, parameter :: dnstream_face_per_elemM = 3 integer, public, parameter :: links_per_node = face_per_elemM integer, public, parameter :: elem_per_face = 2 integer, public, parameter :: e2i_idx = 1 integer, public, parameter :: e2i_elem_type = 2 integer, public, parameter :: e2i_geometry = 3 integer, public, parameter :: e2i_roughness_type = 4 integer, public, parameter :: e2i_link_ID = 5 integer, public, parameter :: e2i_link_Pos = 6 integer, public, parameter :: e2i_Mface_u = 7 integer, public, parameter :: e2i_Mface_d = 8 integer, public, parameter :: e2i_idx_base1 = 8 integer, public, parameter :: e2i_temp1 = e2i_idx_base1+1 integer, public, parameter :: e2i_temp2 = e2i_idx_base1+2 integer, public, parameter :: e2i_n_temp = 2 integer, public, parameter :: e2i_idx_max = e2i_idx_base1+e2i_n_temp integer, public, dimension(e2i_n_temp) :: e2i_Temp = nullvalueI integer, public, parameter :: eMi_idx = 1 integer, public, parameter :: eMi_elem_type = 2 integer, public, parameter :: eMi_geometry = 3 integer, public, parameter :: eMi_nfaces = 4 integer, public, parameter :: eMi_nfaces_u = 5 integer, public, parameter :: eMi_nfaces_d = 6 integer, public, parameter :: eMi_roughness_type = 7 integer, public, parameter :: eMi_node_ID = 8 integer, public, parameter :: eMi_temp1 = 9 integer, public, parameter :: eMi_temp2 = 10 integer, public, parameter :: eMi_idx_base1 = 10 integer, public, parameter :: eMi_n_temp = 2 integer, public, dimension(eMi_n_temp) :: eMi_Temp = nullvalueI integer, public, parameter :: eMi_Mface_u1 = eMi_idx_base1+1 integer, public, parameter :: eMi_Mface_u2 = eMi_idx_base1+2 integer, public, parameter :: eMi_Mface_u3 = eMi_idx_base1+3 integer, public, parameter :: eMi_idx_base2 = eMi_idx_base1+upstream_face_per_elemM integer, public, parameter :: eMi_Mface_d1 = eMi_idx_base2+1 integer, public, parameter :: eMi_Mface_d2 = eMi_idx_base2+2 integer, public, parameter :: eMi_Mface_d3 = eMi_idx_base2+3 integer, public, parameter :: eMi_idx_max = eMi_idx_base2+dnstream_face_per_elemM integer, public, dimension(upstream_face_per_elemM) :: eMi_MfaceUp = nullvalueI integer, public, dimension(dnstream_face_per_elemM) :: eMi_MfaceDn = nullvalueI integer, public, dimension(upstream_face_per_elemM + dnstream_face_per_elemM) :: eMi_MfaceAll = nullvalueI integer, public, parameter :: fi_idx = 1 integer, public, parameter :: fi_type = 2 integer, public, parameter :: fi_Melem_u = 3 integer, public, parameter :: fi_Melem_d = 4 integer, public, parameter :: fi_etype_u = 5 integer, public, parameter :: fi_etype_d = 6 integer, public, parameter :: fi_branch_u = 7 integer, public, parameter :: fi_branch_d = 8 integer, public, parameter :: fi_jump_type = 9 integer, public, parameter :: fi_node_ID = 10 integer, public, parameter :: fi_link_ID = 11 integer, public, parameter :: fi_link_Pos = 12 integer, public, parameter :: fi_BC_ID = 13 integer, public, parameter :: fi_temp1 = 14 integer, public, parameter :: fi_temp2 = 15 integer, public, parameter :: fi_idx_max = 15 integer, public, parameter :: fi_n_temp = 2 integer, public, dimension(fi_n_temp) :: fi_Temp = nullvalueI integer, public, parameter :: e2r_Volume = 1 integer, public, parameter :: e2r_SmallVolume = 2 integer, public, parameter :: e2r_SmallVolumeRatio = 3 integer, public, parameter :: e2r_Flowrate = 4 integer, public, parameter :: e2r_Velocity = 5 integer, public, parameter :: e2r_Timescale_u = 6 integer, public, parameter :: e2r_Timescale_d = 7 integer, public, parameter :: e2r_Friction = 8 integer, public, parameter :: e2r_Eta = 9 integer, public, parameter :: e2r_Head = 10 integer, public, parameter :: e2r_Area = 11 integer, public, parameter :: e2r_Topwidth = 12 integer, public, parameter :: e2r_Perimeter = 13 integer, public, parameter :: e2r_HydDepth = 14 integer, public, parameter :: e2r_HydRadius = 15 integer, public, parameter :: e2r_X = 16 integer, public, parameter :: e2r_Length = 17 integer, public, parameter :: e2r_Zbottom = 18 integer, public, parameter :: e2r_BreadthScale = 19 integer, public, parameter :: e2r_Roughness = 20 integer, public, parameter :: e2r_VolumeConservation = 21 integer, public, parameter :: e2r_FroudeNumber = 22 integer, public, parameter :: e2r_idx_base1 = 22 integer, public, parameter :: e2r_temp1 = e2r_idx_base1+1 integer, public, parameter :: e2r_temp2 = e2r_idx_base1+2 integer, public, parameter :: e2r_temp3 = e2r_idx_base1+3 integer, public, parameter :: e2r_temp4 = e2r_idx_base1+4 integer, public, parameter :: e2r_temp5 = e2r_idx_base1+5 integer, public, parameter :: e2r_temp6 = e2r_idx_base1+6 integer, public, parameter :: e2r_n_temp = 6 integer, public, parameter :: e2r_idx_max = e2r_idx_base1+e2r_n_temp integer, public, dimension(e2r_n_temp) :: e2r_Temp = nullvalueI integer, public, parameter :: eMr_Volume = 1 integer, public, parameter :: eMr_SmallVolume = 2 integer, public, parameter :: eMr_SmallVolumeRatio = 3 integer, public, parameter :: eMr_Flowrate = 4 integer, public, parameter :: eMr_Velocity = 5 integer, public, parameter :: eMr_Friction = 6 integer, public, parameter :: eMr_Eta = 7 integer, public, parameter :: eMr_Head = 8 integer, public, parameter :: eMr_Area = 9 integer, public, parameter :: eMr_Topwidth = 10 integer, public, parameter :: eMr_Perimeter = 11 integer, public, parameter :: eMr_HydDepth = 12 integer, public, parameter :: eMr_HydRadius = 13 integer, public, parameter :: eMr_X = 14 integer, public, parameter :: eMr_Length = 15 integer, public, parameter :: eMr_Zbottom = 16 integer, public, parameter :: eMr_BreadthScale = 17 integer, public, parameter :: eMr_Roughness = 18 integer, public, parameter :: eMr_VolumeConservation = 19 integer, public, parameter :: eMr_FroudeNumber = 20 integer, public, parameter :: eMr_idx_base1 = 20 integer, public, parameter :: eMr_Eta_u1 = eMr_idx_base1+1 integer, public, parameter :: eMr_Eta_u2 = eMr_idx_base1+2 integer, public, parameter :: eMr_Eta_u3 = eMr_idx_base1+3 integer, public, parameter :: eMr_idx_base2 = eMr_idx_base1+upstream_face_per_elemM integer, public, parameter :: eMr_Eta_d1 = eMr_idx_base2+1 integer, public, parameter :: eMr_Eta_d2 = eMr_idx_base2+2 integer, public, parameter :: eMr_Eta_d3 = eMr_idx_base2+3 integer, public, parameter :: eMr_idx_base3 = eMr_idx_base2+dnstream_face_per_elemM integer, public, parameter :: eMr_Flowrate_u1 = eMr_idx_base3+1 integer, public, parameter :: eMr_Flowrate_u2 = eMr_idx_base3+2 integer, public, parameter :: eMr_Flowrate_u3 = eMr_idx_base3+3 integer, public, parameter :: eMr_idx_base4 = eMr_idx_base3+upstream_face_per_elemM integer, public, parameter :: eMr_Flowrate_d1 = eMr_idx_base4+1 integer, public, parameter :: eMr_Flowrate_d2 = eMr_idx_base4+2 integer, public, parameter :: eMr_Flowrate_d3 = eMr_idx_base4+3 integer, public, parameter :: eMr_idx_base5 = eMr_idx_base4+dnstream_face_per_elemM integer, public, parameter :: eMr_Velocity_u1 = eMr_idx_base5+1 integer, public, parameter :: eMr_Velocity_u2 = eMr_idx_base5+2 integer, public, parameter :: eMr_Velocity_u3 = eMr_idx_base5+3 integer, public, parameter :: eMr_idx_base6 = eMr_idx_base5+upstream_face_per_elemM integer, public, parameter :: eMr_Velocity_d1 = eMr_idx_base6+1 integer, public, parameter :: eMr_Velocity_d2 = eMr_idx_base6+2 integer, public, parameter :: eMr_Velocity_d3 = eMr_idx_base6+3 integer, public, parameter :: eMr_idx_base7 = eMr_idx_base6+dnstream_face_per_elemM integer, public, parameter :: eMr_Timescale_u1 = eMr_idx_base7+1 integer, public, parameter :: eMr_Timescale_u2 = eMr_idx_base7+2 integer, public, parameter :: eMr_Timescale_u3 = eMr_idx_base7+3 integer, public, parameter :: eMr_idx_base8 = eMr_idx_base7+upstream_face_per_elemM integer, public, parameter :: eMr_Timescale_d1 = eMr_idx_base8+1 integer, public, parameter :: eMr_Timescale_d2 = eMr_idx_base8+2 integer, public, parameter :: eMr_Timescale_d3 = eMr_idx_base8+3 integer, public, parameter :: eMr_idx_base9 = eMr_idx_base8+dnstream_face_per_elemM integer, public, parameter :: eMr_Area_u1 = eMr_idx_base9+1 integer, public, parameter :: eMr_Area_u2 = eMr_idx_base9+2 integer, public, parameter :: eMr_Area_u3 = eMr_idx_base9+3 integer, public, parameter :: eMr_idx_base10 = eMr_idx_base9+upstream_face_per_elemM integer, public, parameter :: eMr_Area_d1 = eMr_idx_base10+1 integer, public, parameter :: eMr_Area_d2 = eMr_idx_base10+2 integer, public, parameter :: eMr_Area_d3 = eMr_idx_base10+3 integer, public, parameter :: eMr_idx_base11 = eMr_idx_base10+dnstream_face_per_elemM integer, public, parameter :: eMr_Topwidth_u1 = eMr_idx_base11+1 integer, public, parameter :: eMr_Topwidth_u2 = eMr_idx_base11+2 integer, public, parameter :: eMr_Topwidth_u3 = eMr_idx_base11+3 integer, public, parameter :: eMr_idx_base12 = eMr_idx_base11+upstream_face_per_elemM integer, public, parameter :: eMr_Topwidth_d1 = eMr_idx_base12+1 integer, public, parameter :: eMr_Topwidth_d2 = eMr_idx_base12+2 integer, public, parameter :: eMr_Topwidth_d3 = eMr_idx_base12+3 integer, public, parameter :: eMr_idx_base13 = eMr_idx_base12+dnstream_face_per_elemM integer, public, parameter :: eMr_HydDepth_u1 = eMr_idx_base13+1 integer, public, parameter :: eMr_HydDepth_u2 = eMr_idx_base13+2 integer, public, parameter :: eMr_HydDepth_u3 = eMr_idx_base13+3 integer, public, parameter :: eMr_idx_base14 = eMr_idx_base13+upstream_face_per_elemM integer, public, parameter :: eMr_HydDepth_d1 = eMr_idx_base14+1 integer, public, parameter :: eMr_HydDepth_d2 = eMr_idx_base14+2 integer, public, parameter :: eMr_HydDepth_d3 = eMr_idx_base14+3 integer, public, parameter :: eMr_idx_base15 = eMr_idx_base14+dnstream_face_per_elemM integer, public, parameter :: eMr_Length_u1 = eMr_idx_base15+1 integer, public, parameter :: eMr_Length_u2 = eMr_idx_base15+2 integer, public, parameter :: eMr_Length_u3 = eMr_idx_base15+3 integer, public, parameter :: eMr_idx_base16 = eMr_idx_base15+upstream_face_per_elemM integer, public, parameter :: eMr_Length_d1 = eMr_idx_base16+1 integer, public, parameter :: eMr_Length_d2 = eMr_idx_base16+2 integer, public, parameter :: eMr_Length_d3 = eMr_idx_base16+3 integer, public, parameter :: eMr_idx_base17 = eMr_idx_base16+dnstream_face_per_elemM integer, public, parameter :: eMr_Zbottom_u1 = eMr_idx_base17+1 integer, public, parameter :: eMr_Zbottom_u2 = eMr_idx_base17+2 integer, public, parameter :: eMr_Zbottom_u3 = eMr_idx_base17+3 integer, public, parameter :: eMr_idx_base18 = eMr_idx_base17+upstream_face_per_elemM integer, public, parameter :: eMr_Zbottom_d1 = eMr_idx_base18+1 integer, public, parameter :: eMr_Zbottom_d2 = eMr_idx_base18+2 integer, public, parameter :: eMr_Zbottom_d3 = eMr_idx_base18+3 integer, public, parameter :: eMr_idx_base19 = eMr_idx_base18+dnstream_face_per_elemM integer, public, parameter :: eMr_BreadthScale_u1 = eMr_idx_base19+1 integer, public, parameter :: eMr_BreadthScale_u2 = eMr_idx_base19+2 integer, public, parameter :: eMr_BreadthScale_u3 = eMr_idx_base19+3 integer, public, parameter :: eMr_idx_base20 = eMr_idx_base19+upstream_face_per_elemM integer, public, parameter :: eMr_BreadthScale_d1 = eMr_idx_base20+1 integer, public, parameter :: eMr_BreadthScale_d2 = eMr_idx_base20+2 integer, public, parameter :: eMr_BreadthScale_d3 = eMr_idx_base20+3 integer, public, parameter :: eMr_idx_base21 = eMr_idx_base20+dnstream_face_per_elemM integer, public, parameter :: eMr_temp1 = eMr_idx_base21+1 integer, public, parameter :: eMr_temp2 = eMr_idx_base21+2 integer, public, parameter :: eMr_temp3 = eMr_idx_base21+3 integer, public, parameter :: eMr_temp4 = eMr_idx_base21+4 integer, public, parameter :: eMr_temp5 = eMr_idx_base21+5 integer, public, parameter :: eMr_temp6 = eMr_idx_base21+6 integer, public, parameter :: eMr_n_temp = 6 integer, public, parameter :: eMr_idx_base22 = eMr_idx_base21+eMr_n_temp integer, public, parameter :: eMr_idx_max = eMr_idx_base22 integer, public, dimension(eMr_n_temp) :: eMr_Temp = nullvalueI integer, public, dimension(upstream_face_per_elemM) :: eMr_EtaUp = nullvalueI integer, public, dimension(upstream_face_per_elemM) :: eMr_FlowrateUp = nullvalueI integer, public, dimension(upstream_face_per_elemM) :: eMr_VelocityUp = nullvalueI integer, public, dimension(upstream_face_per_elemM) :: eMr_TimescaleUp = nullvalueI integer, public, dimension(upstream_face_per_elemM) :: eMr_AreaUp = nullvalueI integer, public, dimension(upstream_face_per_elemM) :: eMr_TopwidthUp = nullvalueI integer, public, dimension(upstream_face_per_elemM) :: eMr_HydDepthUp = nullvalueI integer, public, dimension(upstream_face_per_elemM) :: eMr_LengthUp = nullvalueI integer, public, dimension(upstream_face_per_elemM) :: eMr_ZbottomUp = nullvalueI integer, public, dimension(upstream_face_per_elemM) :: eMr_BreadthScaleUp = nullvalueI integer, public, dimension(dnstream_face_per_elemM) :: eMr_EtaDn = nullvalueI integer, public, dimension(dnstream_face_per_elemM) :: eMr_FlowrateDn = nullvalueI integer, public, dimension(dnstream_face_per_elemM) :: eMr_VelocityDn = nullvalueI integer, public, dimension(dnstream_face_per_elemM) :: eMr_TimescaleDn = nullvalueI integer, public, dimension(dnstream_face_per_elemM) :: eMr_AreaDn = nullvalueI integer, public, dimension(dnstream_face_per_elemM) :: eMr_TopwidthDn = nullvalueI integer, public, dimension(dnstream_face_per_elemM) :: eMr_HydDepthDn = nullvalueI integer, public, dimension(dnstream_face_per_elemM) :: eMr_LengthDn = nullvalueI integer, public, dimension(dnstream_face_per_elemM) :: eMr_ZbottomDn = nullvalueI integer, public, dimension(upstream_face_per_elemM) :: eMr_BreadthScaleDn = nullvalueI integer, public, dimension(face_per_elemM) :: eMr_EtaAll = nullvalueI integer, public, dimension(face_per_elemM) :: eMr_FlowrateAll = nullvalueI integer, public, dimension(face_per_elemM) :: eMr_VelocityAll = nullvalueI integer, public, dimension(face_per_elemM) :: eMr_TimescaleAll = nullvalueI integer, public, dimension(face_per_elemM) :: eMr_AreaAll = nullvalueI integer, public, dimension(face_per_elemM) :: eMr_TopwidthAll = nullvalueI integer, public, dimension(face_per_elemM) :: eMr_HydDepthAll = nullvalueI integer, public, dimension(face_per_elemM) :: eMr_LengthAll = nullvalueI integer, public, dimension(face_per_elemM) :: eMr_ZbottomAll = nullvalueI integer, public, dimension(face_per_elemM) :: eMr_BreadthScaleAll = nullvalueI integer, public, parameter :: fr_Area_d = 1 integer, public, parameter :: fr_Area_u = 2 integer, public, parameter :: fr_Eta_d = 3 integer, public, parameter :: fr_Eta_u = 4 integer, public, parameter :: fr_Flowrate = 5 integer, public, parameter :: fr_HydDepth_d = 6 integer, public, parameter :: fr_HydDepth_u = 7 integer, public, parameter :: fr_Topwidth = 8 integer, public, parameter :: fr_Velocity_d = 9 integer, public, parameter :: fr_Velocity_u = 10 integer, public, parameter :: fr_Zbottom = 11 integer, public, parameter :: fr_X = 12 integer, public, parameter :: fr_temp1 = 13 integer, public, parameter :: fr_temp2 = 14 integer, public, parameter :: fr_temp3 = 15 integer, public, parameter :: fr_temp4 = 16 integer, public, parameter :: fr_idx_max = 16 integer, public, parameter :: fr_n_temp = 4 integer, public, dimension(fr_n_temp) :: fr_Temp = nullvalueI integer, public, parameter :: e2YN_IsSmallVolume = 1 integer, public, parameter :: e2YN_IsAdhocFlowrate = 2 integer, public, parameter :: e2YN_temp1 = 3 integer, public, parameter :: e2YN_temp2 = 4 integer, public, parameter :: e2YN_temp3 = 5 integer, public, parameter :: e2YN_temp4 = 6 integer, public, parameter :: e2YN_idx_max = 6 integer, public, parameter :: e2YN_n_temp = 4 integer, public, dimension(e2YN_n_temp) :: e2YN_Temp = nullvalueI integer, public, parameter :: eMYN_IsSmallVolume = 1 integer, public, parameter :: eMYN_IsAdhocFlowrate = 2 integer, public, parameter :: eMYN_temp1 = 3 integer, public, parameter :: eMYN_temp2 = 4 integer, public, parameter :: eMYN_temp3 = 5 integer, public, parameter :: eMYN_temp4 = 6 integer, public, parameter :: eMYN_idx_max = 6 integer, public, parameter :: eMYN_n_temp = 4 integer, public, dimension(eMYN_n_temp) :: eMYN_Temp = nullvalueI integer, public, parameter :: fYN_temp1 = 1 integer, public, parameter :: fYN_temp2 = 2 integer, public, parameter :: fYN_idx_max = 2 integer, public, parameter :: fYN_n_temp = 2 integer, public, dimension(fYN_n_temp) :: fYN_Temp = nullvalueI integer, public, parameter :: li_idx = 1 integer, public, parameter :: li_link_type = 2 integer, public, parameter :: li_geometry = 3 integer, public, parameter :: li_roughness_type = 4 integer, public, parameter :: li_N_element = 5 integer, public, parameter :: li_Mnode_u = 6 integer, public, parameter :: li_Mnode_d = 7 integer, public, parameter :: li_Melem_u = 8 integer, public, parameter :: li_Melem_d = 9 integer, public, parameter :: li_Mface_u = 10 integer, public, parameter :: li_Mface_d = 11 integer, public, parameter :: li_assigned = 12 integer, public, parameter :: li_InitialDepthType = 13 integer, public, parameter :: li_temp1 = 14 integer, public, parameter :: li_idx_max = 14 integer, public, parameter :: ni_idx = 1 integer, public, parameter :: ni_node_type = 2 integer, public, parameter :: ni_N_link_u = 3 integer, public, parameter :: ni_N_link_d = 4 integer, public, parameter :: ni_assigned = 5 integer, public, parameter :: ni_temp1 = 6 integer, public, parameter :: ni_idx_base1 = 6 integer, public, parameter :: ni_Mlink_u1 = ni_idx_base1+1 integer, public, parameter :: ni_Mlink_u2 = ni_idx_base1+2 integer, public, parameter :: ni_Mlink_u3 = ni_idx_base1+3 integer, public, parameter :: ni_idx_base2 = ni_idx_base1+upstream_face_per_elemM integer, public, parameter :: ni_Mlink_d1 = ni_idx_base2+1 integer, public, parameter :: ni_Mlink_d2 = ni_idx_base2+2 integer, public, parameter :: ni_Mlink_d3 = ni_idx_base2+3 integer, public, parameter :: ni_idx_max = ni_idx_base2+dnstream_face_per_elemM integer, public, dimension(upstream_face_per_elemM) :: ni_MlinkUp = nullvalueI integer, public, dimension(dnstream_face_per_elemM) :: ni_MlinkDn = nullvalueI integer, public, parameter :: lr_Length = 1 integer, public, parameter :: lr_BreadthScale = 2 integer, public, parameter :: lr_ElementLength = 3 integer, public, parameter :: lr_Slope = 4 integer, public, parameter :: lr_Roughness = 5 integer, public, parameter :: lr_InitialFlowrate = 6 integer, public, parameter :: lr_InitialDepth = 7 integer, public, parameter :: lr_InitialUpstreamDepth = 8 integer, public, parameter :: lr_InitialDnstreamDepth = 9 integer, public, parameter :: lr_temp1 = 10 integer, public, parameter :: lr_idx_max = 10 integer, public, parameter :: nr_Zbottom = 1 integer, public, parameter :: nr_temp1 = 2 integer, public, parameter :: nr_idx_base1 = 2 integer, public, parameter :: nr_ElementLength_u1 = nr_idx_base1+1 integer, public, parameter :: nr_ElementLength_u2 = nr_idx_base1+2 integer, public, parameter :: nr_ElementLength_u3 = nr_idx_base1+3 integer, public, parameter :: nr_idx_base2 = nr_idx_base1+upstream_face_per_elemM integer, public, parameter :: nr_ElementLength_d1 = nr_idx_base2+1 integer, public, parameter :: nr_ElementLength_d2 = nr_idx_base2+2 integer, public, parameter :: nr_ElementLength_d3 = nr_idx_base2+3 integer, public, parameter :: nr_idx_max = nr_idx_base2+dnstream_face_per_elemM integer, public, dimension(upstream_face_per_elemM) :: nr_ElementLengthUp = nullvalueI integer, public, dimension(dnstream_face_per_elemM) :: nr_ElementLengthDn = nullvalueI integer, public, parameter :: nYN_temp1 = 1 integer, public, parameter :: nYN_idx_max = 1 integer, public, parameter :: lYN_temp1 = 1 integer, public, parameter :: lYN_idx_max = 1","title":"array_index – SWMMengine","tags":"","loc":"module/array_index.html"},{"text":"Uses array_index data_keys globals module~~custom_network~~UsesGraph module~custom_network custom_network module~globals globals module~custom_network->module~globals module~data_keys data_keys module~custom_network->module~data_keys module~array_index array_index module~custom_network->module~array_index module~setting_definition setting_definition module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~data_keys->module~globals module~array_index->module~globals module~setting_definition->module~type_definitions Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines custom_1link_network custom_6link_1_line_network custom_3link_Y_network custom_6link_Y_network Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Subroutines public subroutine custom_1link_network (linkR, nodeR, linkI, nodeI, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(inout) :: linkR (:,:) real, intent(inout) :: nodeR (:,:) integer, intent(inout) :: linkI (:,:) integer, intent(inout) :: nodeI (:,:) type(string), intent(inout), dimension(:) :: linkName type(string), intent(inout), dimension(:) :: nodeName public subroutine custom_6link_1_line_network (linkR, nodeR, linkI, nodeI, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(inout) :: linkR (:,:) real, intent(inout) :: nodeR (:,:) integer, intent(inout) :: linkI (:,:) integer, intent(inout) :: nodeI (:,:) type(string), intent(inout), dimension(:) :: linkName type(string), intent(inout), dimension(:) :: nodeName public subroutine custom_3link_Y_network (linkR, nodeR, linkI, nodeI, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(inout) :: linkR (:,:) real, intent(inout) :: nodeR (:,:) integer, intent(inout) :: linkI (:,:) integer, intent(inout) :: nodeI (:,:) type(string), intent(inout), dimension(:) :: linkName type(string), intent(inout), dimension(:) :: nodeName public subroutine custom_6link_Y_network (linkR, nodeR, linkI, nodeI, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(inout) :: linkR (:,:) real, intent(inout) :: nodeR (:,:) integer, intent(inout) :: linkI (:,:) integer, intent(inout) :: nodeI (:,:) type(string), intent(inout), dimension(:) :: linkName type(string), intent(inout), dimension(:) :: nodeName","title":"custom_network – SWMMengine","tags":"","loc":"module/custom_network.html"},{"text":"Uses adjustments array_index bc data_keys globals setting_definition utility module~~face_values~~UsesGraph module~face_values face_values module~globals globals module~face_values->module~globals module~utility utility module~face_values->module~utility module~array_index array_index module~face_values->module~array_index module~adjustments adjustments module~face_values->module~adjustments module~setting_definition setting_definition module~face_values->module~setting_definition module~bc bc module~face_values->module~bc module~data_keys data_keys module~face_values->module~data_keys module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~utility->module~data_keys module~array_index->module~globals module~adjustments->module~globals module~adjustments->module~utility module~adjustments->module~array_index module~adjustments->module~setting_definition module~adjustments->module~data_keys module~setting_definition->module~type_definitions module~bc->module~globals module~bc->module~utility module~bc->module~array_index module~bc->module~setting_definition module~bc->module~data_keys module~bc->module~type_definitions module~data_keys->module~globals var panmoduleface_valuesUsesGraph = svgPanZoom('#moduleface_valuesUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~face_values~~UsedByGraph module~face_values face_values module~explicit_euler explicit_euler module~explicit_euler->module~face_values module~initial_condition initial_condition module~initial_condition->module~face_values module~runge_kutta runge_kutta module~runge_kutta->module~face_values module~time_loop time_loop module~time_loop->module~face_values module~time_loop->module~explicit_euler module~time_loop->module~runge_kutta program~main main program~main->module~initial_condition program~main->module~time_loop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines face_update face_bc_flowrate_update face_bc_flowrate_update_onevalue face_interp_for_elem2 face_interp_for_upstreamchannel_to_downstreamjunction face_interp_for_downstreamchannel_to_upstreamjunction face_hydraulic_jump face_surface_elevation_interp interp_channel_onetype interp_with_junction_downstream interp_with_junction_upstream linear_interpolation Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Subroutines public subroutine face_update (elem2R, elem2I, elemMR, faceR, faceI, faceYN, bcdataDn, bcdataUp, e2r_Velocity_new, eMr_Velocity_new, e2r_Volume_new, eMr_Volume_new, thisTime, thisIter) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(in) :: elem2I (:,:) real, intent(in) :: elemMR (:,:) real, intent(inout) :: faceR (:,:) integer, intent(inout) :: faceI (:,:) logical, intent(inout) :: faceYN (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: eMr_Velocity_new integer, intent(in) :: e2r_Volume_new integer, intent(in) :: eMr_Volume_new real, intent(in) :: thisTime integer, intent(in) :: thisIter private subroutine face_bc_flowrate_update (bcdataDn, bcdataUp, faceR) Arguments Type Intent Optional Attributes Name type(bcType), intent(inout), target :: bcdataDn (:) type(bcType), intent(inout), target :: bcdataUp (:) real, intent(in) :: faceR (:,:) private subroutine face_bc_flowrate_update_onevalue (bcdata, faceR) Arguments Type Intent Optional Attributes Name type(bcType), intent(inout), target :: bcdata (:) real, intent(in) :: faceR (:,:) private subroutine face_interp_for_elem2 (elem2R, faceR, faceI, faceYN, bcdataDn, bcdataUp, e2r_Volume_new) Arguments Type Intent Optional Attributes Name real, intent(in), target :: elem2R (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(in) :: faceI (:,:) logical, intent(inout), target :: faceYN (:,:) type(bcType), intent(in) :: bcdataDn (:) type(bcType), intent(in) :: bcdataUp (:) integer, intent(in) :: e2r_Volume_new private subroutine face_interp_for_upstreamchannel_to_downstreamjunction (elem2R, elemMR, faceR, faceI, faceYN, e2r_Volume_new, eMr_Volume_new) Arguments Type Intent Optional Attributes Name real, intent(in), target :: elem2R (:,:) real, intent(in), target :: elemMR (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(in) :: faceI (:,:) logical, intent(inout), target :: faceYN (:,:) integer, intent(in) :: e2r_Volume_new integer, intent(in) :: eMr_Volume_new private subroutine face_interp_for_downstreamchannel_to_upstreamjunction (elem2R, elemMR, faceR, faceI, faceYN, e2r_Volume_new, eMr_Volume_new) Arguments Type Intent Optional Attributes Name real, intent(in), target :: elem2R (:,:) real, intent(in), target :: elemMR (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(in) :: faceI (:,:) logical, intent(inout), target :: faceYN (:,:) integer, intent(in) :: e2r_Volume_new integer, intent(in) :: eMr_Volume_new private subroutine face_hydraulic_jump (elem2R, elemMR, faceR, faceI, e2r_Velocity_new, eMr_Velocity_new) Arguments Type Intent Optional Attributes Name real, intent(in) :: elem2R (:,:) real, intent(in) :: elemMR (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(inout), target :: faceI (:,:) integer, intent(in) :: e2r_Velocity_new integer, intent(in) :: eMr_Velocity_new private subroutine face_surface_elevation_interp (elem2R, elemMR, faceR, faceI, faceYN) Arguments Type Intent Optional Attributes Name real, intent(in) :: elem2R (:,:) real, intent(in) :: elemMR (:,:) real, intent(inout), target :: faceR (:,:) integer, intent(in) :: faceI (:,:) logical, intent(inout), target :: faceYN (:,:) private subroutine interp_channel_onetype (faceR, facemask, faceI, elem2R, weightUp, weightDn, valueUp, valueDn, e2r_ThisType, fr_ThisType) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: faceR (:,:) logical, intent(in) :: facemask (:) integer, intent(in) :: faceI (:,:) real, intent(in) :: elem2R (:,:) real, intent(in) :: weightUp (:) real, intent(in) :: weightDn (:) real, intent(inout) :: valueUp (:) real, intent(inout) :: valueDn (:) integer, intent(in) :: e2r_ThisType integer, intent(in) :: fr_ThisType private subroutine interp_with_junction_downstream (faceR, facemask, faceI, elem2R, elemMR, weightUp, weightDn, valueUp, valueDn, e2r_ThisValue, eMr_ThisValueUp, fr_ThisValue) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: faceR (:,:) logical, intent(in) :: facemask (:) integer, intent(in) :: faceI (:,:) real, intent(in) :: elem2R (:,:) real, intent(in) :: elemMR (:,:) real, intent(in) :: weightUp (:) real, intent(in) :: weightDn (:) real, intent(inout) :: valueUp (:) real, intent(inout) :: valueDn (:) integer, intent(in) :: e2r_ThisValue integer, intent(in) :: eMr_ThisValueUp (:) integer, intent(in) :: fr_ThisValue private subroutine interp_with_junction_upstream (faceR, facemask, faceI, elem2R, elemMR, weightUp, weightDn, valueUp, valueDn, e2r_ThisValue, eMr_ThisValueDn, fr_ThisValue) Arguments Type Intent Optional Attributes Name real, intent(inout), target :: faceR (:,:) logical, intent(in) :: facemask (:) integer, intent(in) :: faceI (:,:) real, intent(in) :: elem2R (:,:) real, intent(in) :: elemMR (:,:) real, intent(in) :: weightUp (:) real, intent(in) :: weightDn (:) real, intent(inout) :: valueUp (:) real, intent(inout) :: valueDn (:) integer, intent(in) :: e2r_ThisValue integer, intent(in) :: eMr_ThisValueDn (:) integer, intent(in) :: fr_ThisValue private pure subroutine linear_interpolation (inoutarray, facemask, upstreamWeight, downstreamWeight, upstreamValue, downstreamValue) Arguments Type Intent Optional Attributes Name real, intent(inout) :: inoutarray (:) logical, intent(in) :: facemask (:) real, intent(in) :: upstreamWeight (:) real, intent(in) :: downstreamWeight (:) real, intent(in) :: upstreamValue (:) real, intent(in) :: downstreamValue (:)","title":"face_values – SWMMengine","tags":"","loc":"module/face_values.html"},{"text":"Uses array_index bc data_keys element_geometry element_dynamics face_values globals junction setting_definition utility module~~initial_condition~~UsesGraph module~initial_condition initial_condition module~globals globals module~initial_condition->module~globals module~utility utility module~initial_condition->module~utility module~junction junction module~initial_condition->module~junction module~array_index array_index module~initial_condition->module~array_index module~element_dynamics element_dynamics module~initial_condition->module~element_dynamics module~element_geometry element_geometry module~initial_condition->module~element_geometry module~face_values face_values module~initial_condition->module~face_values module~setting_definition setting_definition module~initial_condition->module~setting_definition module~bc bc module~initial_condition->module~bc module~data_keys data_keys module~initial_condition->module~data_keys module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~utility->module~data_keys module~junction->module~globals module~junction->module~utility module~junction->module~array_index module~junction->module~setting_definition module~junction->module~data_keys module~array_index->module~globals module~element_dynamics->module~globals module~element_dynamics->module~utility module~element_dynamics->module~junction module~element_dynamics->module~array_index module~element_dynamics->module~setting_definition module~element_dynamics->module~bc module~element_dynamics->module~data_keys module~adjustments adjustments module~element_dynamics->module~adjustments module~element_geometry->module~globals module~element_geometry->module~utility module~element_geometry->module~junction module~element_geometry->module~array_index module~element_geometry->module~setting_definition module~element_geometry->module~bc module~element_geometry->module~data_keys module~element_geometry->module~adjustments module~face_values->module~globals module~face_values->module~utility module~face_values->module~array_index module~face_values->module~setting_definition module~face_values->module~bc module~face_values->module~data_keys module~face_values->module~adjustments module~setting_definition->module~type_definitions module~bc->module~globals module~bc->module~utility module~bc->module~array_index module~bc->module~setting_definition module~bc->module~data_keys module~bc->module~type_definitions module~data_keys->module~globals module~adjustments->module~globals module~adjustments->module~utility module~adjustments->module~array_index module~adjustments->module~setting_definition module~adjustments->module~data_keys var panmoduleinitial_conditionUsesGraph = svgPanZoom('#moduleinitial_conditionUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~initial_condition~~UsedByGraph module~initial_condition initial_condition program~main main program~main->module~initial_condition Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines initial_condition_setup initial_conditions_from_linkdata initial_junction_conditions Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Subroutines public subroutine initial_condition_setup (elem2R, elem2I, elem2YN, elemMR, elemMI, elemMYN, faceR, faceI, faceYN, linkR, linkI, nodeR, nodeI, bcdataDn, bcdataUp, thisTime) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(inout) :: elem2I (:,:) logical, intent(inout) :: elem2YN (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(inout) :: elemMI (:,:) logical, intent(inout) :: elemMYN (:,:) real, intent(inout) :: faceR (:,:) integer, intent(inout) :: faceI (:,:) logical, intent(inout) :: faceYN (:,:) real, intent(in) :: linkR (:,:) integer, intent(in), target :: linkI (:,:) real, intent(in) :: nodeR (:,:) integer, intent(in), target :: nodeI (:,:) type(bcType), intent(inout) :: bcdataDn (:) type(bcType), intent(inout) :: bcdataUp (:) real, intent(in) :: thisTime private subroutine initial_conditions_from_linkdata (elem2R, elem2I, elemMR, elemMI, linkR, linkI) Arguments Type Intent Optional Attributes Name real, intent(inout) :: elem2R (:,:) integer, intent(inout) :: elem2I (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(inout) :: elemMI (:,:) real, intent(in), target :: linkR (:,:) integer, intent(in), target :: linkI (:,:) private subroutine initial_junction_conditions (faceR, faceI, elem2R, elem2I, elemMR, elemMI, nodeR, nodeI) Arguments Type Intent Optional Attributes Name real, intent(in), target :: faceR (:,:) integer, intent(in), target :: faceI (:,:) real, intent(in), target :: elem2R (:,:) integer, intent(in), target :: elem2I (:,:) real, intent(inout) :: elemMR (:,:) integer, intent(in), target :: elemMI (:,:) real, intent(in), target :: nodeR (:,:) integer, intent(in), target :: nodeI (:,:)","title":"initial_condition – SWMMengine","tags":"","loc":"module/initial_condition.html"},{"text":"Uses allocate_storage array_index bc data_keys globals setting_definition module~~case_simple_channel~~UsesGraph module~case_simple_channel case_simple_channel module~globals globals module~case_simple_channel->module~globals module~array_index array_index module~case_simple_channel->module~array_index module~allocate_storage allocate_storage module~case_simple_channel->module~allocate_storage module~setting_definition setting_definition module~case_simple_channel->module~setting_definition module~bc bc module~case_simple_channel->module~bc module~data_keys data_keys module~case_simple_channel->module~data_keys module~globals->module~setting_definition module~type_definitions type_definitions module~globals->module~type_definitions module~array_index->module~globals module~allocate_storage->module~globals module~allocate_storage->module~array_index module~utility utility module~allocate_storage->module~utility module~setting_definition->module~type_definitions module~bc->module~globals module~bc->module~array_index module~bc->module~setting_definition module~bc->module~data_keys module~bc->module~utility module~bc->module~type_definitions module~data_keys->module~globals module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~utility->module~data_keys var panmodulecase_simple_channelUsesGraph = svgPanZoom('#modulecase_simple_channelUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~case_simple_channel~~UsedByGraph module~case_simple_channel case_simple_channel module~test_cases test_cases module~test_cases->module~case_simple_channel program~main main program~main->module~test_cases Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables debuglevel Subroutines case_simple_channel_initialize case_simple_channel_links_and_nodes Variables Type Visibility Attributes Name Initial integer, private :: debuglevel = 0 Subroutines public subroutine case_simple_channel_initialize (channel_length, channel_breadth, subdivide_length, lowerZ, upperZ, initial_flowrate, depth_upstream, depth_dnstream, ManningsN, roughness_type, idepth_type, linkR, nodeR, linkI, nodeI, linkYN, nodeYN, linkName, nodeName, bcdataDn, bcdataUp) Arguments Type Intent Optional Attributes Name real, intent(in) :: channel_length real, intent(in) :: channel_breadth real, intent(in) :: subdivide_length real, intent(in) :: lowerZ real, intent(in) :: upperZ real, intent(in) :: initial_flowrate real, intent(in) :: depth_upstream real, intent(in) :: depth_dnstream real, intent(in) :: ManningsN integer, intent(in) :: roughness_type integer, intent(in) :: idepth_type real, intent(out), dimension(:,:), allocatable, target :: linkR real, intent(out), dimension(:,:), allocatable, target :: nodeR integer, intent(out), dimension(:,:), allocatable, target :: linkI integer, intent(out), dimension(:,:), allocatable, target :: nodeI logical, intent(out), dimension(:,:), allocatable, target :: linkYN logical, intent(out), dimension(:,:), allocatable, target :: nodeYN type(string), intent(out), dimension(:), allocatable, target :: linkName type(string), intent(out), dimension(:), allocatable, target :: nodeName type(bcType), intent(out), dimension(:), allocatable :: bcdataDn type(bcType), intent(out), dimension(:), allocatable :: bcdataUp private subroutine case_simple_channel_links_and_nodes (channel_length, channel_breadth, subdivide_length, lowerZ, upperZ, initial_flowrate, depth_upstream, depth_dnstream, ManningsN, roughness_type, idepth_type, linkR, nodeR, linkI, nodeI, linkYN, nodeYN, linkName, nodeName) Arguments Type Intent Optional Attributes Name real, intent(in) :: channel_length real, intent(in) :: channel_breadth real, intent(in) :: subdivide_length real, intent(in) :: lowerZ real, intent(in) :: upperZ real, intent(in) :: initial_flowrate real, intent(in) :: depth_upstream real, intent(in) :: depth_dnstream real, intent(in) :: ManningsN integer, intent(in) :: roughness_type integer, intent(in) :: idepth_type real, intent(out), dimension(:,:), allocatable, target :: linkR real, intent(out), dimension(:,:), allocatable, target :: nodeR integer, intent(out), dimension(:,:), allocatable, target :: linkI integer, intent(out), dimension(:,:), allocatable, target :: nodeI logical, intent(out), dimension(:,:), allocatable, target :: linkYN logical, intent(out), dimension(:,:), allocatable, target :: nodeYN type(string), intent(out), dimension(:), allocatable, target :: linkName type(string), intent(out), dimension(:), allocatable, target :: nodeName","title":"case_simple_channel – SWMMengine","tags":"","loc":"module/case_simple_channel.html"},{"text":"Uses allocate_storage array_index bc checking data_keys debug diagnostic globals initialization initial_condition junction network_define output setting_definition type_definitions test_cases time_loop utility program~~main~~UsesGraph program~main main module~globals globals program~main->module~globals module~output output program~main->module~output module~initialization initialization program~main->module~initialization module~utility utility program~main->module~utility module~junction junction program~main->module~junction module~array_index array_index program~main->module~array_index module~diagnostic diagnostic program~main->module~diagnostic module~allocate_storage allocate_storage program~main->module~allocate_storage module~type_definitions type_definitions program~main->module~type_definitions module~checking checking program~main->module~checking module~bc bc program~main->module~bc module~debug debug program~main->module~debug module~network_define network_define program~main->module~network_define module~time_loop time_loop program~main->module~time_loop module~initial_condition initial_condition program~main->module~initial_condition module~setting_definition setting_definition program~main->module~setting_definition module~test_cases test_cases program~main->module~test_cases module~data_keys data_keys program~main->module~data_keys module~globals->module~type_definitions module~globals->module~setting_definition module~output->module~globals module~output->module~utility module~output->module~array_index module~output->module~bc module~output->module~setting_definition module~output->module~data_keys module~initialization->module~globals module~initialization->module~array_index module~initialization->module~data_keys module~utility->module~globals module~utility->module~array_index module~utility->module~setting_definition module~utility->module~data_keys module~junction->module~globals module~junction->module~utility module~junction->module~array_index module~junction->module~setting_definition module~junction->module~data_keys module~array_index->module~globals module~diagnostic->module~globals module~diagnostic->module~utility module~diagnostic->module~array_index module~diagnostic->module~type_definitions module~diagnostic->module~bc module~diagnostic->module~setting_definition module~diagnostic->module~data_keys module~allocate_storage->module~globals module~allocate_storage->module~utility module~allocate_storage->module~array_index module~checking->module~globals module~checking->module~array_index module~checking->module~data_keys module~bc->module~globals module~bc->module~utility module~bc->module~array_index module~bc->module~type_definitions module~bc->module~setting_definition module~bc->module~data_keys module~debug->module~globals module~debug->module~utility module~debug->module~array_index module~debug->module~type_definitions module~debug->module~bc module~debug->module~setting_definition module~debug->module~data_keys module~network_define->module~globals module~network_define->module~initialization module~network_define->module~junction module~network_define->module~array_index module~network_define->module~allocate_storage module~network_define->module~data_keys module~time_loop->module~globals module~time_loop->module~output module~time_loop->module~array_index module~time_loop->module~diagnostic module~time_loop->module~bc module~time_loop->module~debug module~time_loop->module~setting_definition module~time_loop->module~data_keys module~runge_kutta runge_kutta module~time_loop->module~runge_kutta module~explicit_euler explicit_euler module~time_loop->module~explicit_euler module~face_values face_values module~time_loop->module~face_values module~initial_condition->module~globals module~initial_condition->module~utility module~initial_condition->module~junction module~initial_condition->module~array_index module~initial_condition->module~bc module~initial_condition->module~setting_definition module~initial_condition->module~data_keys module~element_dynamics element_dynamics module~initial_condition->module~element_dynamics module~element_geometry element_geometry module~initial_condition->module~element_geometry module~initial_condition->module~face_values module~setting_definition->module~type_definitions module~test_cases->module~globals module~test_cases->module~utility module~test_cases->module~array_index module~test_cases->module~bc module~test_cases->module~setting_definition module~test_cases->module~data_keys module~case_simple_channel case_simple_channel module~test_cases->module~case_simple_channel module~case_y_channel case_y_channel module~test_cases->module~case_y_channel module~data_keys->module~globals module~runge_kutta->module~globals module~runge_kutta->module~utility module~runge_kutta->module~array_index module~runge_kutta->module~diagnostic module~runge_kutta->module~bc module~runge_kutta->module~setting_definition module~runge_kutta->module~data_keys module~runge_kutta->module~element_dynamics module~runge_kutta->module~element_geometry module~runge_kutta->module~face_values module~adjustments adjustments module~runge_kutta->module~adjustments module~element_dynamics->module~globals module~element_dynamics->module~utility module~element_dynamics->module~junction module~element_dynamics->module~array_index module~element_dynamics->module~bc module~element_dynamics->module~setting_definition module~element_dynamics->module~data_keys module~element_dynamics->module~adjustments module~element_geometry->module~globals module~element_geometry->module~utility module~element_geometry->module~junction module~element_geometry->module~array_index module~element_geometry->module~bc module~element_geometry->module~setting_definition module~element_geometry->module~data_keys module~element_geometry->module~adjustments module~explicit_euler->module~globals module~explicit_euler->module~utility module~explicit_euler->module~array_index module~explicit_euler->module~bc module~explicit_euler->module~setting_definition module~explicit_euler->module~data_keys module~explicit_euler->module~element_dynamics module~explicit_euler->module~element_geometry module~explicit_euler->module~face_values module~explicit_euler->module~adjustments module~case_simple_channel->module~globals module~case_simple_channel->module~array_index module~case_simple_channel->module~allocate_storage module~case_simple_channel->module~bc module~case_simple_channel->module~setting_definition module~case_simple_channel->module~data_keys module~face_values->module~globals module~face_values->module~utility module~face_values->module~array_index module~face_values->module~bc module~face_values->module~setting_definition module~face_values->module~data_keys module~face_values->module~adjustments module~case_y_channel->module~globals module~case_y_channel->module~array_index module~case_y_channel->module~allocate_storage module~case_y_channel->module~bc module~case_y_channel->module~setting_definition module~case_y_channel->module~data_keys module~adjustments->module~globals module~adjustments->module~utility module~adjustments->module~array_index module~adjustments->module~setting_definition module~adjustments->module~data_keys var panprogrammainUsesGraph = svgPanZoom('#programmainUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~main~~CallsGraph program~main main proc~initialize_arrayindex initialize_arrayindex program~main->proc~initialize_arrayindex proc~test_case_initiation test_case_initiation program~main->proc~test_case_initiation proc~checking_consistency checking_consistency program~main->proc~checking_consistency proc~checking_smallvolume_consistency checking_smallvolume_consistency program~main->proc~checking_smallvolume_consistency emr_flowratedn emr_flowratedn program~main->emr_flowratedn emr_flowrateup emr_flowrateup program~main->emr_flowrateup proc~utility_get_datetime_stamp utility_get_datetime_stamp program~main->proc~utility_get_datetime_stamp emr_velocityup emr_velocityup program~main->emr_velocityup proc~initialize_arrayindex_status initialize_arrayindex_status program~main->proc~initialize_arrayindex_status proc~debug_initialize debug_initialize program~main->proc~debug_initialize proc~diagnostic_initialize diagnostic_initialize program~main->proc~diagnostic_initialize emr_velocitydn emr_velocitydn program~main->emr_velocitydn proc~output_threaded_by_link_initialize output_threaded_by_link_initialize program~main->proc~output_threaded_by_link_initialize proc~debug_finalize debug_finalize program~main->proc~debug_finalize proc~initial_condition_setup initial_condition_setup program~main->proc~initial_condition_setup proc~time_marching time_marching program~main->proc~time_marching proc~network_initiation network_initiation program~main->proc~network_initiation proc~setting_default setting_default program~main->proc~setting_default proc~bc_checks bc_checks program~main->proc~bc_checks proc~initialize_arrayindex->emr_flowratedn proc~initialize_arrayindex->emr_flowrateup proc~initialize_arrayindex->emr_velocityup proc~initialize_arrayindex->emr_velocitydn emr_timescaleall emr_timescaleall proc~initialize_arrayindex->emr_timescaleall emi_temp emi_temp proc~initialize_arrayindex->emi_temp emi_mfaceup emi_mfaceup proc~initialize_arrayindex->emi_mfaceup emr_breadthscaleup emr_breadthscaleup proc~initialize_arrayindex->emr_breadthscaleup emr_lengthdn emr_lengthdn proc~initialize_arrayindex->emr_lengthdn emr_zbottomall emr_zbottomall proc~initialize_arrayindex->emr_zbottomall emr_areadn emr_areadn proc~initialize_arrayindex->emr_areadn emr_etaup emr_etaup proc~initialize_arrayindex->emr_etaup emr_etaall emr_etaall proc~initialize_arrayindex->emr_etaall nr_elementlengthdn nr_elementlengthdn proc~initialize_arrayindex->nr_elementlengthdn fi_temp fi_temp proc~initialize_arrayindex->fi_temp emr_etadn emr_etadn proc~initialize_arrayindex->emr_etadn emr_lengthup emr_lengthup proc~initialize_arrayindex->emr_lengthup fyn_temp fyn_temp proc~initialize_arrayindex->fyn_temp emr_timescaleup emr_timescaleup proc~initialize_arrayindex->emr_timescaleup emr_breadthscaleall emr_breadthscaleall proc~initialize_arrayindex->emr_breadthscaleall emr_temp emr_temp proc~initialize_arrayindex->emr_temp fr_temp fr_temp proc~initialize_arrayindex->fr_temp emr_flowrateall emr_flowrateall proc~initialize_arrayindex->emr_flowrateall emr_topwidthup emr_topwidthup proc~initialize_arrayindex->emr_topwidthup emr_topwidthall emr_topwidthall proc~initialize_arrayindex->emr_topwidthall e2i_temp e2i_temp proc~initialize_arrayindex->e2i_temp emr_timescaledn emr_timescaledn proc~initialize_arrayindex->emr_timescaledn emr_velocityall emr_velocityall proc~initialize_arrayindex->emr_velocityall ni_mlinkdn ni_mlinkdn proc~initialize_arrayindex->ni_mlinkdn emr_areaup emr_areaup proc~initialize_arrayindex->emr_areaup nr_elementlengthup nr_elementlengthup proc~initialize_arrayindex->nr_elementlengthup emr_zbottomdn emr_zbottomdn proc~initialize_arrayindex->emr_zbottomdn emr_topwidthdn emr_topwidthdn proc~initialize_arrayindex->emr_topwidthdn emi_mfacedn emi_mfacedn proc~initialize_arrayindex->emi_mfacedn emi_mfaceall emi_mfaceall proc~initialize_arrayindex->emi_mfaceall e2yn_temp e2yn_temp proc~initialize_arrayindex->e2yn_temp e2r_temp e2r_temp proc~initialize_arrayindex->e2r_temp emr_zbottomup emr_zbottomup proc~initialize_arrayindex->emr_zbottomup ni_mlinkup ni_mlinkup proc~initialize_arrayindex->ni_mlinkup emr_breadthscaledn emr_breadthscaledn proc~initialize_arrayindex->emr_breadthscaledn emr_areaall emr_areaall proc~initialize_arrayindex->emr_areaall emr_lengthall emr_lengthall proc~initialize_arrayindex->emr_lengthall emr_hyddepthup emr_hyddepthup proc~initialize_arrayindex->emr_hyddepthup emyn_temp emyn_temp proc~initialize_arrayindex->emyn_temp emr_hyddepthdn emr_hyddepthdn proc~initialize_arrayindex->emr_hyddepthdn emr_hyddepthall emr_hyddepthall proc~initialize_arrayindex->emr_hyddepthall proc~this_setting_for_time_and_steps this_setting_for_time_and_steps proc~test_case_initiation->proc~this_setting_for_time_and_steps proc~control_variable_allocation control_variable_allocation proc~test_case_initiation->proc~control_variable_allocation proc~write_testcase_setup_file write_testcase_setup_file proc~test_case_initiation->proc~write_testcase_setup_file proc~case_y_channel_initialize case_y_channel_initialize proc~test_case_initiation->proc~case_y_channel_initialize proc~initialize_arrayindex_status->emr_flowratedn proc~initialize_arrayindex_status->emr_flowrateup proc~initialize_arrayindex_status->emr_velocityup proc~initialize_arrayindex_status->emr_velocitydn proc~initialize_arrayindex_status->emi_mfaceup proc~initialize_arrayindex_status->emr_breadthscaleup proc~initialize_arrayindex_status->emr_lengthdn proc~initialize_arrayindex_status->emr_areadn proc~initialize_arrayindex_status->emr_etaup proc~initialize_arrayindex_status->nr_elementlengthdn proc~initialize_arrayindex_status->emr_etadn proc~initialize_arrayindex_status->emr_lengthup proc~initialize_arrayindex_status->emr_timescaleup proc~initialize_arrayindex_status->emr_temp proc~initialize_arrayindex_status->emr_topwidthup proc~initialize_arrayindex_status->emr_timescaledn proc~initialize_arrayindex_status->ni_mlinkdn proc~initialize_arrayindex_status->emr_areaup proc~initialize_arrayindex_status->nr_elementlengthup proc~initialize_arrayindex_status->emr_zbottomdn proc~initialize_arrayindex_status->emr_topwidthdn proc~initialize_arrayindex_status->emi_mfacedn proc~initialize_arrayindex_status->e2r_temp proc~initialize_arrayindex_status->emr_zbottomup proc~initialize_arrayindex_status->ni_mlinkup proc~initialize_arrayindex_status->emr_breadthscaledn proc~initialize_arrayindex_status->emr_hyddepthup proc~initialize_arrayindex_status->emr_hyddepthdn proc~utility_check_allocation utility_check_allocation proc~debug_initialize->proc~utility_check_allocation proc~diagnostic_initialize->proc~utility_check_allocation proc~diagnostic_volume_conservation diagnostic_volume_conservation proc~diagnostic_initialize->proc~diagnostic_volume_conservation proc~output_threaded_by_link_initialize->proc~utility_check_allocation proc~bc_nullify_ghost_elem bc_nullify_ghost_elem proc~initial_condition_setup->proc~bc_nullify_ghost_elem proc~initial_conditions_from_linkdata initial_conditions_from_linkdata proc~initial_condition_setup->proc~initial_conditions_from_linkdata proc~element_dynamics_update element_dynamics_update proc~initial_condition_setup->proc~element_dynamics_update proc~initial_junction_conditions initial_junction_conditions proc~initial_condition_setup->proc~initial_junction_conditions proc~face_update face_update proc~initial_condition_setup->proc~face_update proc~element_geometry_update element_geometry_update proc~initial_condition_setup->proc~element_geometry_update proc~bc_applied_onelement bc_applied_onelement proc~time_marching->proc~bc_applied_onelement proc~output_all_threaded_data_by_link output_all_threaded_data_by_link proc~time_marching->proc~output_all_threaded_data_by_link proc~diagnostic_froude_number diagnostic_froude_number proc~time_marching->proc~diagnostic_froude_number proc~diagnostic_cfl diagnostic_CFL proc~time_marching->proc~diagnostic_cfl proc~debug_output debug_output proc~time_marching->proc~debug_output proc~time_marching->proc~diagnostic_volume_conservation proc~rk2 rk2 proc~time_marching->proc~rk2 proc~bc_applied_onface bc_applied_onface proc~time_marching->proc~bc_applied_onface proc~network_data_create network_data_create proc~network_initiation->proc~network_data_create proc~network_check_bc network_check_BC proc~network_initiation->proc~network_check_bc proc~network_adjust_link_length network_adjust_link_length proc~network_initiation->proc~network_adjust_link_length proc~network_check_node_link_match network_check_node_link_match proc~network_initiation->proc~network_check_node_link_match proc~initialize_array_zerovalues initialize_array_zerovalues proc~network_initiation->proc~initialize_array_zerovalues proc~network_get_link_slope network_get_link_slope proc~network_initiation->proc~network_get_link_slope proc~network_count_elements_and_faces network_count_elements_and_faces proc~network_initiation->proc~network_count_elements_and_faces proc~network_node_assignment network_node_assignment proc~network_initiation->proc~network_node_assignment proc~junction_geometry_setup junction_geometry_setup proc~network_initiation->proc~junction_geometry_setup proc~allocate_data_storage allocate_data_storage proc~network_initiation->proc~allocate_data_storage proc~initialize_dummy_values initialize_dummy_values proc~network_initiation->proc~initialize_dummy_values proc~junction_branch_assigned_to_faces junction_branch_assigned_to_faces proc~network_initiation->proc~junction_branch_assigned_to_faces proc~bc_adequate_coverage bc_adequate_coverage proc~bc_checks->proc~bc_adequate_coverage proc~bc_node_assignment_error_check bc_node_assignment_error_check proc~bc_checks->proc~bc_node_assignment_error_check proc~bc_updatevalue bc_updatevalue proc~bc_checks->proc~bc_updatevalue proc~bc_assign_faceid bc_assign_faceID proc~bc_checks->proc~bc_assign_faceid proc~bc_onelement bc_onelement proc~bc_applied_onelement->proc~bc_onelement proc~handle_thisnode handle_thisnode proc~network_data_create->proc~handle_thisnode proc~setassigned setAssigned proc~network_data_create->proc~setassigned proc~subdivide_link_going_upstream subdivide_link_going_upstream proc~network_data_create->proc~subdivide_link_going_upstream proc~utility_scale_of_number utility_scale_of_number proc~this_setting_for_time_and_steps->proc~utility_scale_of_number proc~get_dt_from_cfl get_dt_from_CFL proc~this_setting_for_time_and_steps->proc~get_dt_from_cfl proc~utility_round_to_significant_digits utility_round_to_significant_digits proc~this_setting_for_time_and_steps->proc~utility_round_to_significant_digits proc~link_shortening link_shortening proc~network_adjust_link_length->proc~link_shortening proc~output_one_threaded_data_by_link output_one_threaded_data_by_link proc~output_all_threaded_data_by_link->proc~output_one_threaded_data_by_link proc~network_check_node_link_match->ni_mlinkdn proc~network_check_node_link_match->ni_mlinkup proc~diagnostic_froude_number_one diagnostic_froude_number_one proc~diagnostic_froude_number->proc~diagnostic_froude_number_one proc~bc_adequate_coverage_onedir bc_adequate_coverage_onedir proc~bc_adequate_coverage->proc~bc_adequate_coverage_onedir proc~utility_check_fileopen utility_check_fileopen proc~write_testcase_setup_file->proc~utility_check_fileopen proc~initialize_array_zerovalues->emr_lengthdn proc~initialize_array_zerovalues->emr_areadn proc~initialize_array_zerovalues->emr_lengthup proc~initialize_array_zerovalues->emr_topwidthup proc~initialize_array_zerovalues->emr_areaup proc~initialize_array_zerovalues->emr_topwidthdn proc~initialize_array_zerovalues->emr_hyddepthup proc~initialize_array_zerovalues->emr_hyddepthdn proc~total_inout_flowrate total_inout_flowrate proc~diagnostic_volume_conservation->proc~total_inout_flowrate proc~element_dynamics_update->proc~bc_applied_onelement proc~adjust_zero_velocity_at_zero_volume adjust_zero_velocity_at_zero_volume proc~element_dynamics_update->proc~adjust_zero_velocity_at_zero_volume proc~adjust_channel_velocity_limiter adjust_channel_velocity_limiter proc~element_dynamics_update->proc~adjust_channel_velocity_limiter proc~element_flowrate_update element_flowrate_update proc~element_dynamics_update->proc~element_flowrate_update proc~blended_smallvolume_velocity blended_smallvolume_velocity proc~element_dynamics_update->proc~blended_smallvolume_velocity proc~element_timescale element_timescale proc~element_dynamics_update->proc~element_timescale proc~junction_branch_summation_and_updown_average junction_branch_summation_and_updown_average proc~junction_geometry_setup->proc~junction_branch_summation_and_updown_average proc~junction_branch_average_for_directions_then_sum junction_branch_average_for_directions_then_sum proc~junction_geometry_setup->proc~junction_branch_average_for_directions_then_sum proc~rk2->emr_temp proc~rk2->e2r_temp proc~rk2_update_auxiliary_variables rk2_update_auxiliary_variables proc~rk2->proc~rk2_update_auxiliary_variables proc~diagnostic_element_volume_conservation_fluxes diagnostic_element_volume_conservation_fluxes proc~rk2->proc~diagnostic_element_volume_conservation_fluxes proc~diagnostic_element_volume_conservation diagnostic_element_volume_conservation proc~rk2->proc~diagnostic_element_volume_conservation proc~utility_advance_temp_array utility_advance_temp_array proc~rk2->proc~utility_advance_temp_array proc~overwrite_old_values overwrite_old_values proc~rk2->proc~overwrite_old_values proc~junction_branch_velocities junction_branch_velocities proc~initial_junction_conditions->proc~junction_branch_velocities proc~junction_adjacent_element_average junction_adjacent_element_average proc~initial_junction_conditions->proc~junction_adjacent_element_average proc~junction_adjacent_element_values_to_branches junction_adjacent_element_values_to_branches proc~initial_junction_conditions->proc~junction_adjacent_element_values_to_branches proc~junction_branch_average_of_inflows_and_outflows junction_branch_average_of_inflows_and_outflows proc~initial_junction_conditions->proc~junction_branch_average_of_inflows_and_outflows proc~bc_allocate bc_allocate proc~case_y_channel_initialize->proc~bc_allocate proc~case_y_channel_links_and_nodes case_y_channel_links_and_nodes proc~case_y_channel_initialize->proc~case_y_channel_links_and_nodes proc~allocate_data_storage->proc~utility_check_allocation proc~face_update->proc~bc_applied_onface proc~face_hydraulic_jump face_hydraulic_jump proc~face_update->proc~face_hydraulic_jump proc~face_interp_for_upstreamchannel_to_downstreamjunction face_interp_for_upstreamchannel_to_downstreamjunction proc~face_update->proc~face_interp_for_upstreamchannel_to_downstreamjunction proc~face_interp_for_downstreamchannel_to_upstreamjunction face_interp_for_downstreamchannel_to_upstreamjunction proc~face_update->proc~face_interp_for_downstreamchannel_to_upstreamjunction proc~face_surface_elevation_interp face_surface_elevation_interp proc~face_update->proc~face_surface_elevation_interp proc~face_bc_flowrate_update face_bc_flowrate_update proc~face_update->proc~face_bc_flowrate_update proc~face_interp_for_elem2 face_interp_for_elem2 proc~face_update->proc~face_interp_for_elem2 proc~element_geometry_update->proc~bc_applied_onelement proc~element_geometry_update->emr_temp proc~adjust_for_zero_geometry adjust_for_zero_geometry proc~element_geometry_update->proc~adjust_for_zero_geometry proc~rectangular_geometry_update rectangular_geometry_update proc~element_geometry_update->proc~rectangular_geometry_update proc~element_geometry_update->proc~utility_advance_temp_array proc~adjust_smallvolumes adjust_smallvolumes proc~element_geometry_update->proc~adjust_smallvolumes proc~bc_onface bc_onface proc~bc_applied_onface->proc~bc_onface proc~bc_ghost_othervalues bc_ghost_othervalues proc~bc_applied_onface->proc~bc_ghost_othervalues proc~bc_face_othervalues bc_face_othervalues proc~bc_applied_onface->proc~bc_face_othervalues proc~utility_linear_interpolate_within_indexlist utility_linear_interpolate_within_indexlist proc~bc_updatevalue->proc~utility_linear_interpolate_within_indexlist proc~initialize_dummy_values->emi_mfaceup proc~initialize_dummy_values->emi_mfacedn proc~junction_branch_assigned_to_faces->emi_mfaceup proc~junction_branch_assigned_to_faces->emi_mfacedn proc~reset_juctionbranches_for_zero_values reset_juctionbranches_for_zero_values proc~adjust_for_zero_geometry->proc~reset_juctionbranches_for_zero_values proc~reset_element_for_zero_values reset_element_for_zero_values proc~adjust_for_zero_geometry->proc~reset_element_for_zero_values proc~handle_thisnode->emi_mfaceup proc~handle_thisnode->emr_breadthscaleup proc~handle_thisnode->emr_lengthdn proc~handle_thisnode->nr_elementlengthdn proc~handle_thisnode->emr_lengthup proc~handle_thisnode->emr_topwidthup proc~handle_thisnode->ni_mlinkdn proc~handle_thisnode->nr_elementlengthup proc~handle_thisnode->emr_zbottomdn proc~handle_thisnode->emr_topwidthdn proc~handle_thisnode->emi_mfacedn proc~handle_thisnode->emr_zbottomup proc~handle_thisnode->ni_mlinkup proc~handle_thisnode->emr_breadthscaledn proc~handle_thisnode->proc~handle_thisnode proc~handle_thisnode->proc~setassigned proc~handle_thisnode->proc~subdivide_link_going_upstream proc~setfacetype setFaceType proc~handle_thisnode->proc~setfacetype proc~face_hydraulic_jump->fr_temp proc~face_hydraulic_jump->proc~utility_advance_temp_array proc~bc_onface->proc~bc_updatevalue proc~output_one_threaded_data_by_link->emr_lengthdn proc~output_one_threaded_data_by_link->proc~utility_check_allocation proc~output_one_threaded_data_by_link->emr_lengthup proc~junction_branch_summation_and_updown_average->emr_temp proc~junction_branch_summation_and_updown_average->proc~utility_advance_temp_array proc~junction_branch_summation_one_direction junction_branch_summation_one_direction proc~junction_branch_summation_and_updown_average->proc~junction_branch_summation_one_direction proc~rk2_update_auxiliary_variables->proc~element_dynamics_update proc~rk2_update_auxiliary_variables->proc~face_update proc~rk2_update_auxiliary_variables->proc~element_geometry_update proc~adjust_vshaped_flowrate adjust_Vshaped_flowrate proc~rk2_update_auxiliary_variables->proc~adjust_vshaped_flowrate proc~element_geometry_branch_fix element_geometry_branch_fix proc~rk2_update_auxiliary_variables->proc~element_geometry_branch_fix proc~bc_allocate->proc~utility_check_allocation proc~junction_branch_velocities_one_direction junction_branch_velocities_one_direction proc~junction_branch_velocities->proc~junction_branch_velocities_one_direction proc~zero_velocity_at_zero_volume zero_velocity_at_zero_volume proc~adjust_zero_velocity_at_zero_volume->proc~zero_velocity_at_zero_volume proc~junction_adjacent_element_average->emr_temp proc~junction_adjacent_element_average->proc~utility_advance_temp_array proc~junction_summation_from_adjacent_elements_one_direction junction_summation_from_adjacent_elements_one_direction proc~junction_adjacent_element_average->proc~junction_summation_from_adjacent_elements_one_direction proc~diagnostic_element_volume_conservation_fluxes->emi_mfaceup proc~diagnostic_element_volume_conservation_fluxes->emi_mfacedn proc~rectangular_junction_leg rectangular_junction_leg proc~rectangular_geometry_update->proc~rectangular_junction_leg proc~rectangular_channel_or_junction rectangular_channel_or_junction proc~rectangular_geometry_update->proc~rectangular_channel_or_junction proc~inout_flowrate_from_bcdata inout_flowrate_from_bcdata proc~total_inout_flowrate->proc~inout_flowrate_from_bcdata proc~allocate_linknode_storage allocate_linknode_storage proc~case_y_channel_links_and_nodes->proc~allocate_linknode_storage proc~face_interp_for_upstreamchannel_to_downstreamjunction->fyn_temp proc~face_interp_for_upstreamchannel_to_downstreamjunction->emr_timescaleup proc~face_interp_for_upstreamchannel_to_downstreamjunction->fr_temp proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~utility_advance_temp_array proc~interp_with_junction_downstream interp_with_junction_downstream proc~face_interp_for_upstreamchannel_to_downstreamjunction->proc~interp_with_junction_downstream proc~face_interp_for_downstreamchannel_to_upstreamjunction->fyn_temp proc~face_interp_for_downstreamchannel_to_upstreamjunction->fr_temp proc~face_interp_for_downstreamchannel_to_upstreamjunction->emr_timescaledn proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~utility_advance_temp_array proc~interp_with_junction_upstream interp_with_junction_upstream proc~face_interp_for_downstreamchannel_to_upstreamjunction->proc~interp_with_junction_upstream proc~junction_branch_average_for_directions_then_sum->emr_temp proc~junction_branch_average_for_directions_then_sum->proc~utility_advance_temp_array proc~junction_branch_average_for_directions_then_sum->proc~junction_branch_summation_one_direction proc~junction_adjacent_element_values_one_direction junction_adjacent_element_values_one_direction proc~junction_adjacent_element_values_to_branches->proc~junction_adjacent_element_values_one_direction proc~element_flowrate_update->emr_temp proc~element_flowrate_update->proc~utility_advance_temp_array proc~junction_branch_sum_areas_by_direction junction_branch_sum_areas_by_direction proc~element_flowrate_update->proc~junction_branch_sum_areas_by_direction proc~adjust_junction_branch_velocity_limit adjust_junction_branch_velocity_limit proc~element_flowrate_update->proc~adjust_junction_branch_velocity_limit proc~flowrate_from_velocity flowrate_from_velocity proc~element_flowrate_update->proc~flowrate_from_velocity proc~junction_branch_velocity_and_flowrate_proportional_to_area junction_branch_velocity_and_flowrate_proportional_to_area proc~element_flowrate_update->proc~junction_branch_velocity_and_flowrate_proportional_to_area proc~bc_onelement->proc~bc_updatevalue proc~face_surface_elevation_interp->emr_lengthdn proc~face_surface_elevation_interp->emr_lengthup proc~face_surface_elevation_interp->fyn_temp proc~face_surface_elevation_interp->fr_temp proc~face_surface_elevation_interp->proc~utility_advance_temp_array proc~subdivide_link_going_upstream->proc~setfacetype proc~junction_branch_average_of_inflows_and_outflows->emr_temp proc~junction_branch_average_of_inflows_and_outflows->proc~utility_advance_temp_array proc~junction_net_inflow_and_outflow junction_net_inflow_and_outflow proc~junction_branch_average_of_inflows_and_outflows->proc~junction_net_inflow_and_outflow proc~face_bc_flowrate_update_onevalue face_bc_flowrate_update_onevalue proc~face_bc_flowrate_update->proc~face_bc_flowrate_update_onevalue proc~face_interp_for_elem2->fyn_temp proc~face_interp_for_elem2->fr_temp proc~face_interp_for_elem2->proc~utility_advance_temp_array proc~utility_round_to_significant_digits->proc~utility_scale_of_number proc~blended_smallvolume_velocity->emr_flowratedn proc~blended_smallvolume_velocity->emr_flowrateup proc~blended_smallvolume_velocity->emr_velocityup proc~blended_smallvolume_velocity->emr_velocitydn proc~blended_smallvolume_velocity->emi_mfaceup proc~blended_smallvolume_velocity->emr_lengthdn proc~blended_smallvolume_velocity->emr_areadn proc~blended_smallvolume_velocity->emr_lengthup proc~blended_smallvolume_velocity->emr_areaup proc~blended_smallvolume_velocity->emi_mfacedn proc~velocity_blend_with_mask velocity_blend_with_mask proc~blended_smallvolume_velocity->proc~velocity_blend_with_mask proc~smallvolume_identification smallvolume_identification proc~adjust_smallvolumes->proc~smallvolume_identification proc~smallvolume_geometry smallvolume_geometry proc~adjust_smallvolumes->proc~smallvolume_geometry proc~bc_timescale_value bc_timescale_value proc~element_timescale->proc~bc_timescale_value proc~timescale_value_junction timescale_value_junction proc~element_timescale->proc~timescale_value_junction proc~timescale_value_channel timescale_value_channel proc~element_timescale->proc~timescale_value_channel proc~smallvolume_identification_for_element smallvolume_identification_for_element proc~smallvolume_identification->proc~smallvolume_identification_for_element proc~timescale_value_junction->emr_temp proc~timescale_value_junction->proc~utility_advance_temp_array proc~timescale_limit_junction_one_direction timescale_limit_junction_one_direction proc~timescale_value_junction->proc~timescale_limit_junction_one_direction proc~timescale_junction_one_direction timescale_junction_one_direction proc~timescale_value_junction->proc~timescale_junction_one_direction proc~linear_interpolation linear_interpolation proc~interp_with_junction_downstream->proc~linear_interpolation proc~velocity_blend_with_mask->proc~utility_advance_temp_array proc~velocity_blend velocity_blend proc~velocity_blend_with_mask->proc~velocity_blend proc~smallvolume_manningsn smallvolume_ManningsN proc~velocity_blend_with_mask->proc~smallvolume_manningsn proc~small_chezy_velocity small_chezy_velocity proc~velocity_blend_with_mask->proc~small_chezy_velocity proc~adjust_junction_branch_velocity_limit->emr_flowratedn proc~adjust_junction_branch_velocity_limit->emr_flowrateup proc~adjust_junction_branch_velocity_limit->emr_velocityup proc~adjust_junction_branch_velocity_limit->emr_velocitydn proc~adjust_junction_branch_velocity_limit->emr_areadn proc~adjust_junction_branch_velocity_limit->emr_areaup proc~junction_net_flow_in_or_out junction_net_flow_in_or_out proc~junction_net_inflow_and_outflow->proc~junction_net_flow_in_or_out proc~smallvolume_junctionbranch_reset smallvolume_junctionbranch_reset proc~smallvolume_geometry->proc~smallvolume_junctionbranch_reset proc~smallvolume_element_geometry_reset smallvolume_element_geometry_reset proc~smallvolume_geometry->proc~smallvolume_element_geometry_reset proc~allocate_linknode_storage->proc~utility_check_allocation proc~adjust_vshaped_flowrate->e2yn_temp proc~adjust_vshaped_flowrate->e2r_temp proc~adjust_vshaped_flowrate->proc~utility_advance_temp_array proc~utility_sign_with_ones utility_sign_with_ones proc~adjust_vshaped_flowrate->proc~utility_sign_with_ones proc~timescale_value_channel->e2yn_temp proc~timescale_value_channel->e2r_temp proc~timescale_value_channel->proc~utility_advance_temp_array proc~timescale_limiter timescale_limiter proc~timescale_value_channel->proc~timescale_limiter proc~element_geometry_branch_fix->emr_temp proc~element_geometry_branch_fix->proc~utility_advance_temp_array proc~element_geometry_branch_fix->proc~rectangular_junction_leg proc~element_geometry_branch_fix->proc~junction_branch_sum_areas_by_direction proc~element_geometry_branch_fix->proc~adjust_junction_branch_velocity_limit proc~element_geometry_branch_fix->proc~junction_branch_velocity_and_flowrate_proportional_to_area proc~interp_with_junction_upstream->proc~linear_interpolation proc~timescale_limit_junction_one_direction->emyn_temp proc~timescale_limit_junction_one_direction->proc~utility_advance_temp_array proc~timescale_limit_junction_one_direction->proc~timescale_limiter proc~apply_limiter_with_mask apply_limiter_with_mask proc~timescale_limiter->proc~apply_limiter_with_mask var panprogrammainCallsGraph = svgPanZoom('#programmainCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables elem2R elem2I elem2YN elem2Name elemMR elemMI elemMYN elemMName faceR faceI faceYN faceName linkR linkI linkYN linkName nodeR nodeI nodeYN nodeName bcdataUp bcdataDn debugfile diagnostic threadedfile Variables Type Attributes Name Initial real, dimension(:,:), allocatable, target :: elem2R integer, dimension(:,:), allocatable, target :: elem2I logical, dimension(:,:), allocatable, target :: elem2YN type( string ), dimension(:), allocatable, target :: elem2Name real, dimension(:,:), allocatable, target :: elemMR integer, dimension(:,:), allocatable, target :: elemMI logical, dimension(:,:), allocatable, target :: elemMYN type( string ), dimension(:), allocatable, target :: elemMName real, dimension(:,:), allocatable, target :: faceR integer, dimension(:,:), allocatable, target :: faceI logical, dimension(:,:), allocatable, target :: faceYN type( string ), dimension(:), allocatable, target :: faceName real, dimension(:,:), allocatable, target :: linkR integer, dimension(:,:), allocatable, target :: linkI logical, dimension(:,:), allocatable, target :: linkYN type( string ), dimension(:), allocatable, target :: linkName real, dimension(:,:), allocatable, target :: nodeR integer, dimension(:,:), allocatable, target :: nodeI logical, dimension(:,:), allocatable, target :: nodeYN type( string ), dimension(:), allocatable, target :: nodeName type(bcType), dimension(:), allocatable :: bcdataUp type(bcType), dimension(:), allocatable :: bcdataDn type(debugfileType), dimension(:), allocatable :: debugfile type(diagnosticType), allocatable, dimension(:) :: diagnostic type(threadedfileType), allocatable, dimension(:) :: threadedfile","title":"main – SWMMengine","tags":"","loc":"program/main.html"}]}